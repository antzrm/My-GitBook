# JWT

{% embed url="https://github.com/Sjord/jwtdemo/" %}

## JWT Security Scanner

[https://jwtlens.netlify.app/](https://jwtlens.netlify.app/)

## Overview

Json Web Token's are a fairly interesting case, as it isn't a vulnerability itself. Infact, it's a fairly popular, and if done right very secure method of authentication. The basic structure of a JWT is this, it goes "header.payload.secret", the secret is only known to the server, and is used to make sure that data wasn't changed along the way. Everything is then base64 encoded. so an example JWT token would look like&#x20;

{% code overflow="wrap" %}
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
{% endcode %}

Meaning that if we are able to control the secret, we can effectively control the data. To be able to do this we have to understand how the secret is calculated. This requires knowing the structure of the header, a typical JWT header looks like this `{"typ":"JWT","alg":"RS256"}`. We're interested in the alg field. RS256 uses a private RSA key that's only available to the server, so that's not vulnerable. However, We can change that field to HS256, This is calculated using the server's public key, which in certain circumstances we may have access too.

## Steps

1. Modify the header section of the token so that the `alg` header would contain the value `none`.
2. Remove the signature part.

Use Cookie Editor and include/exclude the final letters or = from base64 encoding. Do not forget the final . for signature even though signature part is removed.

## Manual exploitation

We start off with a basic application

![](<../../.gitbook/assets/image (42).png>)

With a JWT, and a JWT verifier. Sending it garbage results in a failure, so let's try decoding the JWT.

![](<../../.gitbook/assets/image (77).png>)

Decoding the JWT gives us our header, payload, and a bunch of garbage which is the secret.

![](<../../.gitbook/assets/image (82).png>)

Unfortunately it seems the algorithm is RS256, which doesn't have any vulnerabilities. Fortunately for us though, this server leaves its public key lying around, which means we can change the algorithm and sign a new secret! The first step is to change the algorithm in the header to HS256, and then re encode it in base64. Our new JWT is `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0IiwiaWF0IjoxNTg1MzIzNzg0LCJleHAiOjE1ODUzMjM5MDQsImRhdGEiOnsiaGVsbG8iOiJ3b3JsZCJ9fQ.FXj9F1jIXlhMyoQAo5-XPOiZeP4Ltw5XXZGqgX49tKkYUOeirOXUDgWL4bqP9nRXIODqOByqS_9O11nQN5bC_LTpfBWG2WZXg0tKIDAbKTxVkrytXBmOkP1qRK_Apv-CQs-mouuS1we8SHYShW_r4DEj0qAF3dsWVVzbRWNMH4Oc_odHNogv00dVlABcxMyXFpNJbeRS6-GCS-A4SFM32gMv_mkfkXrQPdejKDU_sKZrD5VVAmDlu0BainIvD28l8uV3OCc37shtPW0TKoIwUXmGsFYouKqk-h0dz4aTBLKJk7L64XdrA7ts1oOtzk8KqV6gnqXDXUNkzDX3qd9JKA`

The next step is to convert the public key to hex so openssl will use it.

![](<../../.gitbook/assets/image (37).png>)

(Explanation: a is the file with the public key, `xxd -p` turns the contents of a file to hex, and `tr` is there to get rid of any newlines)

The next step is to use openssl to sign that as a valid HS256 key.

![](<../../.gitbook/assets/image (22).png>)

Everything is going just fine so far!. The final step is to decode that hex to binary data, and reencode it in base64, luckily python makes this really easy for us.

![](<../../.gitbook/assets/image (104).png>)

That's our final secret, now we just put that where the secret should go, and the server should accept it.

So our final JWT would be`eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<payload>.<new secret>`

![](<../../.gitbook/assets/image (124).png>)

## Automatic exploitation

Due to the fact that JWT tokens often expire, there's no real way to guarantee that finding the public key is possible, and that there is no way to keep the data portion of the JWT consistent, there aren't tools avaliable that automatically exploit JWT vulnerabilities. JWT vulns have to be exploited on a case by case basis.

Now that doesn't mean you can't write a script that does everything automatically for a specific website that you know is vulnerable, it's just that by the time you succeed in doing that, you could have already exploited the vulnerability.

## Forge tokens

{% code overflow="wrap" fullWidth="true" %}
```sh
https://jwt.rocks/
https://github.com/ticarpi/jwt_tool

python /opt/jwt_tool/jwt_tool.py ey...
# With the following args, it will modify the cookie:
    -pk and -pr specify the public and private keys
    -S givens the algorithm
    -I to inject claims
    -pc role specifies the claim to target
    -pv administrator gives the value for that claim
python /opt/jwt_tool/jwt_tool.py -pk id_rsa.pub -pr id_rsa -S rs256 -I -pc role -pv administrator -pc exp -pv 2728560132 ey...
```
{% endcode %}

## None algorithm

There is no tool that can check the library, get the token, and make sure this is vulnerable. Therefore, you're gonna have to do this manually. The header for each JWT none vuln though is the same, which can help you out. Here's the header\


```
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0
```

```
Which decodes to {"type": "JWT", "alg": "none"}
```

## Bruteforce HS256

Recall that JWT HS256 is calculated using a secret.The exact format of the calculation is

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

Therefore, it stands to reason that, since we have the full jwt token, and the header and payload, the secret can be brute forced to obtain the full JWT token. If the secret can be brute forced then the attacker could sign his own JWT tokens.

To brute force these secrets we'll be using a tool called [jwt-cracker](https://github.com/lmammino/jwt-cracker). The syntax of jwt-cracker is`jwt-cracker <token> [alphabet] [max-length]` where alphabet and max-length are optional parameters.

Explanation of Paramaters:

| <p>Token<br></p>      | <p>The HS256 JWT token<br></p>                                                                              |
| --------------------- | ----------------------------------------------------------------------------------------------------------- |
| <p>Alphabet<br></p>   | <p>The alphabet that the cracker will use to check passwords(default: "abcdefghijklmnopqrstuvwxyz")<br></p> |
| <p>max-length<br></p> | <p>The max expected length of the secret(12 by default)<br></p>                                             |

Using an example token from jwt.io lets see how long it takes to crack.

![](<../../.gitbook/assets/image (51).png>)

&#x20;In 4 seconds, we've tried 300000 passwords and cracked the secret!
