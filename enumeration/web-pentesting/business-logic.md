# Business Logic

## What are business logic vulnerabilities?

Business logic vulnerabilities are flaws in the design and implementation of an application that allow an attacker to elicit unintended behavior.

Flaws in the logic can allow attackers to circumvent these rules. For example, they might be able to complete a transaction without going through the intended purchase workflow. In other cases, broken or non-existent validation of user-supplied data might allow users to make arbitrary changes to transaction-critical values or submit nonsensical input.

## How do business logic vulnerabilities arise?

Business logic vulnerabilities often arise because the design and development teams make flawed assumptions about how users will interact with the application. These bad assumptions can lead to inadequate validation of user input.

To avoid logic flaws, developers need to understand the application as a whole. This includes being aware of how different functions can be combined in unexpected ways.

## What is the impact of business logic vulnerabilities?

Any unintended behavior can potentially lead to high-severity attacks if an attacker is able to manipulate the app in the right way. For this reason, quirky logic should ideally be fixed even if you can't work out how to exploit it yourself.

Even though logic flaws may not allow an attacker to benefit directly, they could still allow a malicious party to damage the business in some way.

## What are some examples of business logic vulnerabilities?

{% code overflow="wrap" fullWidth="true" %}
```sh
######################################### Excessive trust in client-side controls
Assumption that client-side validation will prevent users from supplying malicious input -> tamper it w/ Burp
Without server-side validation, an attacker can do all kinds of damage with relatively minimal effort.
# EXAMPLE: Excessive trust in client-side controls
- Find a parameter such as quantity, price and modify it w/ Burp


######################################### Failing to handle unconventional input
NOTE: fuzz/try every parameter, also see how they are reflected on the response (negative, truncation, long, short...)
One aim of the application logic is to restrict user input to values that adhere to the business rules.
Although any int is a valid input, the business logic might prevent users from ordering more units than are in stock.
# Consider a funds transfer between two bank accounts. Check if sender has enough funds before completing the transfer: 
$transferAmount = $_POST['amount'];
$currentBalance = $user->getBalance();
if ($transferAmount <= $currentBalance) {
    // Complete the transfer
} else {
    // Block the transfer: insufficient funds
}
# But if logic doesn't prevent users from supplying a negative value as amount parameter -> end up receiveing money
Burp Proxy/Repeater -> submit unconventional values, ranges that users are unlikely to ever enter. This includes 
very high/low numeric inputs, abnormally long strings for text-based fields, unexpected data types... 
By observing the app response, you should try and answer the following questions:
    Are there any limits that are imposed on the data?
    What happens when you reach those limits? (try to reach positive/negative boundaries of quantity/price/etc.)
    Is any transformation or normalization being performed on your input?
# EXAMPLE: High-level logic vulnerability
- Logic allow to order negative amounts.
- Order expensive thing and then negative amount of another thing to compensate the price and pay very little
# EXAMPLE: Low-level logic flaw
- We cannot order negative amounts, and if we try to order positive amounts, limit is 100.
- We start adding 99 lots of times using Turbo Intruder
- At a certain point such as 20691 units -> big negative value
- If we keep increasing the quantity -> big negative value tends to 0
- Play with +/- quantity until we reach a negative "low" price of the jacket, sth like - 1200$
- Now buy other stuff to have a positive purchase value (above 0$)
# EXAMPLE: Inconsistent handling of exceptional input
- Register a new user.
- Fuzz the app to find /admin panel, but only users registered w/ @domain.com emails are allowed
- Identify every request w/ parameters, notice also which are reflected on the response.
- Submit unexpected data such as very short/long strings.
- Notice that on another response, if email is very long, it gets truncated.
- We can register a very long email that gets truncated so let''s do @domain.com.our-real-domain.com and when email
gets truncated, our email will be @domain.com
&username=test2&email=attackers1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111%40dontwannacry.com.exploit-0ae700c403bd202880107f6201d6008c.exploit-server.net&password=test


################################################ Making flawed assumptions about user behavior
#### Trusted users won't always remain trustworthy
Some apps assume that, after passing initial controls, the user and their data can be trusted indefinitely.
Relatively lax enforcement of controls from that point on (security not applied consistently throughout the app).
# EXAMPLE: Inconsistent security controls
- Register new user.
- Find /admin panel and see only users with a specific email domain account can access it.
- Notice the account panel allows to change your email.
- Update your email to that specific mail account and access admin panel.
#### Users won't always supply mandatory input
Attackers can tamper with parameters in transit. This even extends to removing parameters entirely. 
Removing parameter values may allow an attacker to access code paths that are supposed to be out of reach. 
Try removing each parameter in turn and observing what effect this has on the response:
    Only remove one parameter at a time to ensure all relevant code paths are reached.
    Try deleting the name of the parameter as well as the value. The server should handle both cases differently.
    Follow multi-stage processes through to completion. Sometimes tampering with a parameter in one step
    will have an effect on another step further along in the workflow.
This applies to both URL and POST parameters, but do not forget to check the cookies too. 
# EXAMPLE: Weak isolation on dual-use endpoint
- Register a new account.
- Notice the password change feature when we are required a username, current password and new password.
- Replace username for administrator and remove current password parameter to change the administrator password.
#### Users won't always follow the intended sequence
The web interface will typically guide users through this workflow process. However, attackers might not follow that.
For example, 2FA require users to log in on one page before entering a verification code on a separate page. Not verifying
that they do, may allow attackers to bypass the 2FA step entirely. 
Using tools like Burp Proxy/Repeater, once an attacker has seen a request, they can replay it at will and use 
forced browsing to perform any interactions with the server in any order they want.
Identify -> forced browsing to submit requests in an unintended sequence (skip certain steps, access a single step
more than once, return to earlier steps, and so on). Take note of how different steps are accessed.
Although you often just submit a GET/POST request to a specific URL, sometimes you can access steps by submitting
different sets of parameters to the same URL. 
Pay attention to any error messages or debug information that you encounter -> information disclosure.
# EXAMPLE: Insufficient workflow validation
- Log in and complete a purchase. Notice every request and that there is one with a message saying purchase successful.
- Try another purchase with insufficient founds, use Burp Proxy and when there is an error message, change it for
the successful message.
# EXAMPLE: Authentication bypass via flawed state machine
- Log in and see there is a role selector workflow. After that, when I go to /admin, it says only admin can enter.
- Use Burp Proxy > log in > just after log in, tamper the request to go to /admin and skip the other stuff.


############################################### Domain-specific flaws
In many cases, you will encounter logic flaws that are specific to the business domain or the purpose of the site. 
The discounting functionality of online shops is a classic attack surface when hunting for logic flaws.
For example, consider an online shop that offers a 10% discount on orders over $1000. This could be vulnerable 
to abuse if the business logic fails to check whether the order was changed after the discount is applied.
Attacker could simply add items to their cart until they hit the $1000 threshold, then remove some items before ordering.
You should pay particular attention to any situation where prices or other sensitive values are adjusted based 
on criteria determined by user actions. 
# EXAMPLE: Flawed enforcement of business rules
- You can input different coupon codes.
- If you enter the same twice in a row it says coupon already applied, but there is no limit if you alternate them.
# EXAMPLE: Infinite money logic flaw
- Login and see we can buy a gift card as it is one of the available products.
- If we suscribe to a newsletter, we also have a 30 % coupon.
- We buy the gift card with 30 % off and we redeem the gift card. That means we have 3$ more on our store credit.
- If we repeat this many times, our store credit will keep growing and growing till we can buy anything we want.
- Burp > Project > Session handling rules > Add > Scope > Include all URLs > Rule actions > Run a macro
- Add a new macro > select requests in order from buying gift card until redeeming it.
- Macro Editor > configure item on checkout requests > Custom parameter location > parameter name: gift-card > fetch value
- Then on last request > Configure Macro Item > gift-card > derive from previous response 4
- Click on Test Macro > confirm it works and our store credit is higher > Ok > Ok > Ok
- Now go to /my-account request > Intruder > Null payloads > Generate 400 payloads > Resource pool > max 1 sim. request
- This means when we run any payload on any request as /my-account, our rule will be executed following macro steps.


################################################# Providing an encryption oracle
When user-controllable input is encrypted and the resulting ciphertext is then made available to the user in some way
-> encryption oracle -> attacker can use this input to encrypt arbitrary data using the correct algorithm and asym. key. 
Dangerous -> other user-controllable inputs in the app that expect data encrypted with the same algorithm. In this case,
use the encryption oracle to generate valid, encrypted input and then pass it into other sensitive functions.
This issue can be compounded if there is another user-controllable input on the site that provides the reverse function
This would enable the attacker to decrypt other data to identify the expected structure. 


################################################# Email address parser discrepancies
https://portswigger.net/research/splitting-the-email-atom
Some websites parse email addresses to extract the domain and determine which organization the email owner belongs to.
Discrepancies in how email addresses are parsed -> encoding to disguise parts of the email address to pass valid. checks
The main impact of email address parser discrepancies is unauthorized access (register emails from restricted domains)
```
{% endcode %}
