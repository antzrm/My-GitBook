# ðŸ“± Mobile Pentesting

#### [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)

<figure><img src="../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

## VULN APPS / EASY CHALLENGES

[https://github.com/rewanthtammana/Damn-Vulnerable-Bank](https://github.com/rewanthtammana/Damn-Vulnerable-Bank)

[https://github.com/OWASP/igoat](https://github.com/OWASP/igoat)

[https://github.com/DERE-ad2001/Frida-Labs](https://github.com/DERE-ad2001/Frida-Labs)

[https://github.com/B3nac/InjuredAndroid](https://github.com/B3nac/InjuredAndroid)

[https://github.com/payatu/diva-android](https://github.com/payatu/diva-android)

## ADVANCED-LEVEL COURSE

[https://www.mobilehackinglab.com/](https://www.mobilehackinglab.com/)

## BEGINNER GUIDES

[https://blog.lrvt.de/android-penetration-testing-lab-environment/](https://blog.lrvt.de/android-penetration-testing-lab-environment/)

[https://mas.owasp.org/MASTG/](https://mas.owasp.org/MASTG/)

[https://gist.github.com/OTaKuHP/c0a8d8ca68842e30a2178a4ba5d8fc03](https://gist.github.com/OTaKuHP/c0a8d8ca68842e30a2178a4ba5d8fc03)

[https://www.youtube.com/watch?v=P41g7f1UHaQ\&list=PLqjhBzfQS7YL-vLIaXmD0-wGN5m8uhJwp](https://www.youtube.com/watch?v=P41g7f1UHaQ\&list=PLqjhBzfQS7YL-vLIaXmD0-wGN5m8uhJwp)

#### https://www.youtube.com/watch?v=4rCNc3uhLJE

#### https://developer.android.com/studio/run/managing-avds

[https://www.youtube.com/watch?v=KL1jUvNSL94\&list=TLPQMTYwMTIwMjQV83R1P4JZtw\&index=2\&pp=gAQBiAQB](https://www.youtube.com/watch?v=KL1jUvNSL94\&list=TLPQMTYwMTIwMjQV83R1P4JZtw\&index=2\&pp=gAQBiAQB)

## TIPS

* Look for files under resources (res) folder such as xml
* Look for files under /storage/emulated/0 (go there even if it seems permission denied)
* Insecure storage > search any odd function/code/string/variable to find hardcoded strings
* External storage > files saved to external storage are world-readable /// CHECK /storage/emulated/0/Documents and /data/media/0
* WebViews > Load Arbitrary URL > see if WebView is exported on AndroidManifest.xml

[https://www.hackingarticles.in/android-penetration-testing-webview-attacks/](https://www.hackingarticles.in/android-penetration-testing-webview-attacks/)

* Insecure Database > Firebase > a misconfigured Firebase database can be identified by calling https://firebaseProjectName.firebaseio.com/.json
* If there are passwords, hashes, values, etc. hardcoded, we can decompile the apk, edit them to a known value and rebuild it to bypass that authentication.
* Unprotected Activity >
* Exported Content Provided

```
dz> run app.provider.info -a app.beetlebug
# Search Content Provider string to find URI (content://XXX)
dz> run app.provider.query content://app.X.provider/users
```

## Tools

JADX: Java decompiler

APKTOOL: compile/decompile APK

GENYMOTION: Android emulator

ADB: send orders to the device

Dex2jar: convert to Java files

MobSF: auto analysis

Frid: hooking

Objection: hooking

Drozer: vuln analysis

Ipatool: ipa download

Xcode: IDE for Apple OS

Ideviceinstaller:iOS application installer

## First steps with AVD

```sh
# AVD -> Developer -> note IP
adb connect $AVD_IP:5555
adb shell pm list packages | grep myapp
adb shell pm path com.example.myapp
adb pull /data/app/com.example.myapp-1/base.apk

apktool b Andro_test -o Andro_test.apk
keytool -genkey -keystore prueba.keystore -validity 10000 -alias prueba -keyalg rsa
keytool -genkey -keystore prueba.keystore -validity 10000 -alias andro -keyalg rsa
jarsigner keystore andro.keystore -verbose Andro_test.apk Andro
adb uninstall com.example.demo
# Now app can be installed
adb install Andro_test.apk


##### AUTOPSY -> FIRST ROOT THE DEVICE
mount
# acquires the disk image, and starts a listener
adb shell "dd if=/dev/block/dm-0 | busybox nc -l -p 8888" &
# Next, we forward the traffic on port 8888, using ADB.
adb forward tcp:8888 tcp:8888
# Finally, we run the following command to get the disk image locally.
nc 127.0.0.1 8888 > disk.dd


# With adb installed, we connect to the AVD
â””â”€$ adb connect 192.168.56.145:5555                                                                                                                                                     1 â¨¯
connected to 192.168.56.145:5555

â”Œâ”€â”€(kaliã‰¿kali)-[~/Downloads]
â””â”€$ adb devices
List of devices attached
192.168.56.145:5555     device

/storage/self/primary
adb push # upload file to phone
adb pull # download file from phome
â””â”€$ adb push test.txt /storage/self/primary/Download                                                                                                                                    1 â¨¯
test.txt: 1 file pushed, 0 skipped. 0.0 MB/s (5 bytes in 0.000s)
```

## APK Decompilation

{% hint style="info" %}
Decompile > go to smali > modify logic or constants to bypass functions and rebuild APK
{% endhint %}

{% code overflow="wrap" fullWidth="true" %}
```sh
apktool d file.apk
# Android manifest -> check uses-permission

jadx-gui # then open .apk
# TIP ABOUT jadx: go to search text in order to finish decompilation (sometimes it does not automatically)
Text Search -> password

# IN REAL WORLD -> apktool d file.apk, look under /assets, interesting files, etc.

dex2jar file.apk -o file.jar

https://github.com/linkedin/qark
```
{% endcode %}

## Burp Proxy + certificate

### Root

{% code overflow="wrap" fullWidth="true" %}
```sh
# Download Genymotion
wget .../.sh
chmod +x ...sh
./...sh

# Install Virtualbox and adb
sudo apt install virtualbox adb

# Download Burp certificate, format and push it to the phone
curl localhost:8080/cert -O burpcert.der # With Burp open
openssl x509 -inform DER -in burpcert.der -out burpcert.pem
openssl x509 -inform PEM -subject_hash_old -in burpcert.pem | head -1
mv burpcert.pem $HEAD-1_RESULT.0 # for exmaple, rename to 9a5ba575.0
Phone > Settings > Security > Encryption & credentials > Trusted certificates > we do not see Portswigger there
# Now we copy the cert; first check adb device is attached
adb devices -l
adb push xxx.0 /system/etc/security/cacerts # we cannot, we need a root shell on the phone
adb shell
su
mount -o remount,rw / 
# Push again
adb push xxx.0 /system/etc/security/cacerts
# Now we should find Portswigger Settings > Security > Encryption & credentials > Trusted certificates
# Set Burp proxy
adb shell settings put global http_proxy LHOST:8080
- Change Burp listener to *:8080 (all interfaces)
Now we should see traffic if we open web browser on the phone
# Unset proxy
adb shell settings put global http_proxy :0
# Put these as aliases on ~/.zshrc
ip -o -4 addr show ens33 | awk '{print $4}' | sed 's/\/.*//g'
alias adb_set_proxy="adb shell settings put global http_proxy $(ip -o -4 addr show INTERFACE | awk '{print $4}' | sed 's/\/.*//g'):8080"
alias adb_unset_proxy="adb shell settings put global http_proxy :0"
# Now we go to Google Play and input a Google account to be able to install apps
Then we install Wayzn as an example and see if we can intercept login request

# When we install Instagram we see we cannot intercept anything because we need Frida to inject Javascript to inject/hook apps
# INSTALL FRIDA
pipx install frida-tools
# To know our phone arch, run
adb shell
uname -a
# Research Instagram intercept SSL github and download the .js
https://github.com/Eltion/Instagram-SSL-Pinning-Bypass
frida -U -l instagram-ssl-pinning-bypass.js -f com.instagram.android 
```
{% endcode %}

### Non-root

{% code overflow="wrap" fullWidth="true" %}
```sh
# - Decompile apk
# - Go to res/xml/network_security_config.xml (if file/structure is not created, do it)
# - network_security_config.xml should be sth like
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
            certificates src="user" />
        </trust-anchors>
    </domain-config>
</network-security-config> 
# - Then go to the Android Manifest and if we do not see android:networkSecurityConfig pointing to that file, add it
    <application android:allowBackup="true" android:appComponentFactory="androidx.core.app.CoreComponentFactory" ... android:networkSecurityConfig="@xml/network_security_config" ...>
# Rebuild apk to create a new one with our changes
apk b app/ -o app-updated.apk
# Now we need to sign the APK before installing (need to set a password of at least 6 chars such as test1234)
keytool -genkey -v -keystore mykeystore -keyalg RSA -keysize 2048 -validity 1000 -alias android 
apksigner sign -ks-key-alias android -ks mykeystore app-updated.apk
# And now we can finally install the modified app
adb install app-updated.apk
# Now we export the certificate from Burp as .der and transfer it to the device
adb push burpcert.der /sdcard
# On the device > Settings > Encryption & credentials > Install certificate from SD Card
# Then open Burp, set up Wi-Fi on the device with proxy 
```
{% endcode %}

### Physical Device

We need a physical device, rooted and with Magisk installed.

{% code overflow="wrap" fullWidth="true" %}
```sh
Use this Magisk plugin to install certs
https://github.com/NVISOsecurity/MagiskTrustUserCerts
Go to Releases > download .zip > push it to our device
adb push AlwaysTrustUserCerts.zip sdcard/
- Magisk app > Modules > Install from storage > select the .zip
- Now on Burp > Listener > Choose the right IP address > Export certificate > DER format > save as burp.ct
adb push burp.crt sdcard/
Encryption & credentials > Install a certificate > CA certificate > Install anyway > select .crt
Now go to Trusted Credentials and we should see it under User section
Then reboot the device and we should see it also under System section
```
{% endcode %}

## SSL Pinning Bypass

SSL Pinning means bypass those apps that do not allow Burp proxy to intercept network requests.

This example is for the app Twitter which requires SSL Pinning.

### Frida

{% code overflow="wrap" fullWidth="true" %}
```sh
pip3 install frida-tools --break-system-packages
# Now we need to dowload Frida server from https://github.com/frida/frida/releases
# To know our phone arch, run
adb shell getprop ro.product.cpu.abi
# Now we download frida-server-android-ARCH.xz
xz -d frida-server-16.5.5-android-x86.xz
mv frida-server-16.5.5-android-x86 frida-server
adb push frida-server /data/local/tmp
adb shell "chmod +x /data/local/tmp/frida-server"
adb shell "/data/local/tmp/frida-server" &
# Check frida server is running and we can see Android processes
frida-ps -U

# Now for SSL Pinning, we need community projects from Frida users
https://codeshare.frida.re/
https://codeshare.frida.re/@sowdust/universal-android-ssl-pinning-bypass-2/
frida --codeshare sowdust/universal-android-ssl-pinning-bypass-2 -f YOUR_BINARY
# We need the binary name
adb shell
genymotion:/data/data # ls com.twitter.android/
# We find the name com.twitter.android
frida --codeshare sowdust/universal-android-ssl-pinning-bypass-2 -U -f com.twitter.android
...
# We type %resume
Spawned `com.twitter.android`. Resuming main thread!
[Phone::com.twitter.android ]-> %resume
# Now we can interact with the app normally even with Burp
```
{% endcode %}

### Without being root

Useful in case we cannot root the device or we are running an app which detects root execution (e.g., banking apps).

{% code overflow="wrap" fullWidth="true" %}
```sh
pip3 install objection --break-system-packages
sudo apt install apksigner
objection patchapk -s app.apk
# If we see apksigner error
sudo apt purge apktool
# Follow these steps https://apktool.org/docs/install/
# If we see zipalign error, follow this video https://youtu.be/Ya97QHLXCyw
# If we see no space left referred to /tmp, search about sudo mount remount and assign more space

# Finally, try again the objection command
objection patchapk -s com.twitter.android_10.50.0-alpha...apk
# We will se a new .objection.apk; install that one
adb install com.twitter....objection.apk
# Now we can use Burp with the app without using Frida
```
{% endcode %}

## Bypassing Root Detection

### Frida

```sh
# USE FRIDA TO BYPASS ROOT DETECTION DINAMICALLY
https://codeshare.frida.re/@dzonerzy/fridantiroot/
# To confirm Frida is correctly installed and see the package names
frida-ps -Uia
# Now try the codeshare with -U to indicate we are using USB connection
frida --codeshare dzonerzy/fridantiroot -f YOUR_BINARY -U
frida --codeshare KaiserBloo/ssl-and-root-bypass -f owasp.sat.agoat -U 
```

### Frida & Objection

```sh
# Bypass root detection with objection
adb shell "/data/local/tmp/frida-server" &      
objection -g owasp.sat.agoat explore
...
[usb] android root disable

# Bypass SSL Pinning with objection
[usb] android sslpinning disable

# Bypass root detection and SSL Pinning with frida
frida --codeshare KaiserBloo/ssl-and-root-bypass -f owasp.sat.agoat -U 

# Clipboard Monitor Data
adb shell "/data/local/tmp/frida-server" & 
objection -g app.package explore
[usb] # android clipboard monitor
```

## Reversing with GHIDRA

If an APK has private functions or we cannot see strings and sensitive info, always try to open lib files or any other files with GHIDRA.

{% code overflow="wrap" fullWidth="true" %}
```sh
GHIDRA > New Project > Code Browser > once inside go to Import File > select .apk > System Files > open lib folder's files 
(typically x86 or x86_64, try the first one mainly if that is our arch but if no clue try both, there might be slight differences on
 variables and strings that might mean correct decryption or gibberish so pay attention and try harder)
Then go to Symbol Tree > Exports and check those functions

nahT f sk a ro tll \0hsif eh
```
{% endcode %}

## Dynamic Analysis&#x20;

### attach gdb to an Android process

{% code overflow="wrap" fullWidth="true" %}
```sh
adb shell
su
# check the system partition with mount
/dev/block/platform/soc.0/f9824900.sdhci/by-name/system /system ext4 ro,seclabel,noatime,data=ordered 0 0
# remounted the system partition read-write
mount -o rw,remount /dev/block/platform/soc.0/f9824900.sdhci/by-name/system /system
# copy gdbserver into the /system/bin folder. Then add execute rights to the binary and remount the system partition again with read-only mode
mount -o ro,remount /dev/block/platform/soc.0/f9824900.sdhci/by-name/system /system
# Determine the PID of the application
ps | grep uncrackable
# Attache the gdbserver to the process
gdbserver :8888 â€“attach <PID>
# Forwarded the port 8888 to our attacking machine
adb forward tcp:8888 tcp:8888
# Start gdb and attach to the remote process
./gdb
(gdb) target remote :8888
# List all the imported libraries
(gdb) info sharedlibrary
```
{% endcode %}

## Root a physical Android Device

{% code overflow="wrap" fullWidth="true" %}
```sh
# Become Developer
System > About > Find Build Number > Tap 7 times
Then Enable USB Debugging
adb devices > Authorize it on the phone
Then, if it is a Google phone, look for factory images (Nexus and Pixel for example)
EXPLANATION: Binary image files allow you to restore your Nexus or Pixel device's original factory firmware. You will find these files useful if you have flashed custom builds on your device, and wish to return your device to its factory state.

- Download .zip, unzip it, push boot.img to /sdcard/Downloads for example
- Download Magisk apk and install it on the device
- On Magisk, Install, install and patch, select boot.img
- Now we should see magisk_patchex_X.img on Downloads folder of the phone
- Pull that to our PC
adb reboot bootlader # reboot your device in fast-boot mode
# In case the DEVICE STATE on the phone's screen shows locked instead of unlocked, run the following command
fastboot flashing unlock
# After that, run
fastboot flash boot magisk_patched_X.img
# After rebooting the device, we can run
adb shell
# If we type su, we will see on the phone's screen a granting message and if we accept, we have a root shell!!!!
```
{% endcode %}

## Bypass Frida Dection (Tampering)

<pre class="language-javascript" data-overflow="wrap" data-full-width="true"><code class="lang-javascript"><strong># METHOD BELOW INCLUDES ROOT DETECTION BYPASS AS WELL
</strong><strong>
</strong><strong>https://codeshare.frida.re/@enovella/anti-frida-bypass/
</strong>
# Add script below to our previous 
frida --codeshare KaiserBloo/ssl-and-root-bypass
# Or use this alternative
https://codeshare.frida.re/@dzonerzy/fridantiroot/

# Result is this file we call crackme3.js /// we also add some console.log commands for debugging purposes
...
Java.perform(function() {

    var RootPackages = ["com.noshufou.android.su", "com.noshufou.android.su.elite", "eu.chainfire.supersu",

        "com.koushikdutta.superuser", "com.thirdparty.superuser", "com.yellowes.su", "com.koushikdutta.rommanager",

        "com.koushikdutta.rommanager.license", "com.dimonvideo.luckypatcher", "com.chelpus.lackypatch",

        "com.ramdroid.appquarantine", "com.ramdroid.appquarantinepro", "com.devadvance.rootcloak", "com.devadvance.rootcloakplus",

        "de.robv.android.xposed.installer", "com.saurik.substrate", "com.zachspong.temprootremovejb", "com.amphoras.hidemyroot",

        "com.amphoras.hidemyrootadfree", "com.formyhm.hiderootPremium", "com.formyhm.hideroot", "me.phh.superuser",

        "eu.chainfire.supersu.pro", "com.kingouser.com", "com.topjohnwu.magisk"

    ];



    var RootBinaries = ["su", "busybox", "supersu", "Superuser.apk", "KingoUser.apk", "SuperSu.apk", "magisk"];



    var RootProperties = {

        "ro.build.selinux": "1",

        "ro.debuggable": "0",

        "service.adb.root": "0",

        "ro.secure": "1"

    };

...
console.log("Root Detection and SSL Pinning Bypass!");



    onLeave: function(retval) {

        if (this.frida) {
            retval.replace(0);
        }
        return retval;
    }
});

console.log("Frida Detection Bypass!");
...

# Now we use this script with Frida to bypass root detection, SSL Pinning and Frida detection
frida -l MY_SCRIPT.js -f COM.MY.PACKAGE -U
</code></pre>

## Capture traffic

[https://github.com/ThatNotEasy/NetGaze/](https://github.com/ThatNotEasy/NetGaze/)

## Drozer

{% code overflow="wrap" fullWidth="true" %}
```sh
https://labs.withsecure.com/tools/drozer

docker pull withsecurelabs/drozer  
docker run -it withsecurelabs/drozer  
# Install drozer agent from https://github.com/WithSecureLabs/drozer-agent
adb install drozer-agent.apk
# Open the app and set ON at the bottom
# Port forwarding
adb forward tcp:31415 tcp:31415
# Connect to Drozer console
sudo docker run --net host -it withsecurelabs/drozer console connect --server localhost   
dz> list
# Get package name
dz> run app.package.list
# Knowing app (package) keyword
dz> run app.package.list -f goat
dz> run app.package.attacksurface -h
dz> run app.package.attacksurface owasp.sat.agoat # pay attention to exported elements
# if says is debuggable, we can attach a debugger and stop the execution, set breakpoints and so on
# See which activities are exported
dz> run app.activity.info -a owasp.sat.agoat
# Run those activies from Drozer console
dz> run app.activity.start --component com.withsecure.example.sieve com.withsecure.example.sieve.activity.PWList
# Find database leaks
dz> run scanner.provider.finduris -a com.withsecure.example.sieve
# If there are broadcasts recievers exported
dz> run app.broadcast.info -a owasp.sat.agoat
# If there are services exported
dz> run app.service.info -a owasp.sat.agoat
Attempting to run shell module
Package: owasp.sat.agoat
  owasp.sat.agoat.DownloadInvoiceService
    Permission: null
dz> run app.service.start --component owasp.sat.agoat owasp.sat.agoat.DownloadInvoiceService


https://www.infosecinstitute.com/resources/penetration-testing/android-penetration-tools-walkthrough-series-drozer/
```
{% endcode %}

## MobSF

Great tool to scan mobile apps

{% code overflow="wrap" fullWidth="true" %}
```sh
https://github.com/MobSF/Mobile-Security-Framework-MobSF

# Docker install
docker pull opensecurity/mobile-security-framework-mobsf:latest
docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest

# Then go to  http://0.0.0.0:8000 use mobsf:mobsf as creds and upload the .apk
# We could test a vulnerable app such as https://github.com/rewanthtammana/Damn-Vulnerable-Bank

Static Analyzer > upload .apk 
Things to check: 
- Exported activities/services/receivers/providers
- Android Manifest
- Source/smali code
- Signer certificate (to detect forging signatures, see if app is signed only with v1 signature or with a short signing key coudl be vulnerable)
- Permission (problematic like reading sdcard)
- Browsable Activities
- Network Analysis
- Manifest Analysis (useful for pentests)
- Code Analysis (useful for pentests)
- Next 4/5 sections are only useful for malware analysis
- IMPORTANT: Possible Hardcoded Secrets
```
{% endcode %}

## VULNERABILITIES

### Insecure Storage

{% code overflow="wrap" fullWidth="true" %}
```sh
# Places to look for
/sdcard
/cache
/data/data # apps data is there
/data/data/$APP/shared_prefs
# We could pull files, modify then and pushing them to /shared_prefs or other places to modify the app behaviour (restart the app to see those changes)

# Shared Preferences
Play with the app, after some new content might be stored under /data/data/app.package/shared_prefs folder

# FIND TEMP FILES CREATED ON THE FLY (USEFUL TO LEAVE IT RUNNING BEFORE LOGIN/AUTH TO SEE IF STH IS STORED TEMPORARILY)
inotifyd - /data/data/$APP/

# SEE DIFF BETWEEN 2 APP STATES
adb pull /data/data/$APP
# Then we interact more with the app and pull it again w/ another name
adb pull /data/data/$APP myapp
diff -r /$APP /myapp 

# If AndroidManifest.xml has WRITE_EXTERNAL_STORAGE, make sure to check /sdcard and similar places where we could find files
```
{% endcode %}

### Insecure Logging

```
Suspect any data could be logged
adb logcat  # then check for sensitive data there
```

### SQL

```
# Data Storage -> SQL Database
After input some data -> /data/data/app.package/databases folder

# Databases -> SQL Injection
On any input field, try SQLi // try LIMIT 1 to not break or crash stuff
```

### Binary Patching

{% code overflow="wrap" fullWidth="true" %}
```sh
# In case an option/button is disabled
Go to jadx-gui > Search that option by its name (e.g., Access) and see where it is
apktool d app.apk # decompile apk and modify the specific part we want to "patch"
# Before continuing, remove the original APK, otherwise the mod one will not be installed
# Last steps are rebuilding the app with apktool, certificate sign and installation on AVD
```
{% endcode %}

### React Native Apps

```sh
# Discover secrets
Decompile code with jadx-gui
Always check Source code > com > XXXX > MainActivity
Always check Resources > assets # this is a React place to check
```

## Android Studio - AVD

{% code overflow="wrap" fullWidth="true" %}
```sh
############## ROOTING
https://youtu.be/QzsNn3GhYYk
# Create an emulator with API 31 for example, not newer
https://gitlab.com/newbit/rootAVD
# Use the adequate API version of our AVD 
# After the device reboots by itself, we will see Magisk installed and when we open 
adb shell
su # we should see Magisk notification, we grant and we become root


############ INSTALL BURP SUITE CERTIFICATE
https://github.com/NVISOsecurity/MagiskTrustUserCerts
Go to Releases > Download .zip > push it to the AVD
Open Magisk > Modules > Install from storage > Open .zip > Install > Device will reboot and we will see the Module installed
Open Burp and see Proxy 127.0.0.1 8080
Go to AVD > 3 dots > Settings > Proxy > Manual proxy > 127.0.0.1 8080
Burp > Export certificate > burp.crt > Push file to AVD > Open it and installed > See it is on the Users section > Reboot AVD

############### FRIDA
https://github.com/frida/frida
```
{% endcode %}

## Biometrics Bypass

{% code overflow="wrap" fullWidth="true" %}
```sh
# iOS -> we need to jailbreak iOS 15
https://github.com/prateek147/DVIA-v2
# We need to decompile and resign this .ipa
frida-ps Uia
objection -g com.package explore
ios ui biometrics_bypass

# ANDROID
# To test, we can use https://github.com/St3v3nsS/InsecureBanking
# We can use these Frida scripts
github.com/WithSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass.js
codeshare.frida.re/@krapgras/android-biometric-bypass-update-android-11 # for this, when running frida script, type bypass() on the console
```
{% endcode %}

## Flutter SSL Bypass

[https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088](https://m4kr0x.medium.com/flutter-tls-bypass-how-to-intercept-https-traffic-when-all-other-frida-scripts-fail-bd3d04489088)

## Root / unroot on Genymotion

<pre class="language-sh"><code class="lang-sh">https://docs.genymotion.com/paas/10_Using_root_access/
<strong># Unroot / unable privileged actions and superuser shell
</strong>adb shell setprop persist.sys.root_access 0
adb shell setprop ctl.restart adbd
adb shell setprop service.adb.root 0
# Root again
adb root
adb shell setprop persist.sys.root_access 3
</code></pre>

## Compile and sign apk

{% code fullWidth="true" %}
```java
apktool b Andro_test -o Andro_test.apk
keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore your_app_recompiled.apk alias_name
# Now app can be installed
adb install Andro_test.apk
```
{% endcode %}

El anÃ¡lisis dinÃ¡mico se llevarÃ¡ a cabo con Exposed, Inspeckage y MobSF.&#x20;

Se usarÃ¡ Drozer como framework para la explotaciÃ³n de vulnerabilidades.&#x20;

La interceptaciÃ³n de trÃ¡fico de red se llevarÃ¡ a cabo con Tcpdump, Wireshark y Burp.&#x20;

Las herramienta onlines utilizadas serÃ¡n AVC UnDroid y VirusTotal.

## iOS

HackerOne -> iOS Hacking videos

* MobSF is recommended for static analysis
* Manual static analysis with IDA Pro (reverse engineering) or looking for strings

```
otool -Iv <app> | grep -w "CC_MD5" otool -Iv <app> | grep -w "_CC_SHA1"
```

* Frida: compatible with hooking
* Memory dump: Fridump + rabin2/strings
* Logs extraction: idevicesyslog
* iOS equivalent to "Manifest.xml" is "info.plist"
* iOS does nto have exported components but exported functions (URL schemes, Custom URL schemes, App Extensions, App Groups and XPC) that can be invoked/exploited by other applications.

### Paths

Main directories:

/var/mboile/containers/Data/Application/\*

/var/containers/Bundle/Application/\*

Some interesting directories:

../Containers/Data/Application/ contains application-generated data such as database

../Documents/ contains data generated by the user

../Library/Caches/ HTTP requests and responses on database Cache.db. It does usually contain sensitive data such as tokens, usernames and so on.

../Library/Preferences conains application properties and can persist even after app reboot.

../Library/Cookies contains app cookies.

../tmp contain temp data.

### Automation

[https://github.com/darklotuskdb/ios-buster](https://github.com/darklotuskdb/ios-buster)
